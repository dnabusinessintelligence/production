"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// globally unique, to up to repeated usages of this module in different JS context
var ENVELOP_COUNTER = 1;
exports.ChannelEndPoint = function (base) {
    return /** @class */ (function (_super) {
        __extends(ChannelEndPoint, _super);
        function ChannelEndPoint() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.connectionInterval = 1000;
            _this.awaitingResponses = new Map();
            return _this;
        }
        ChannelEndPoint.prototype.doConnect = function (channel) {
            throw "Abstract method `doConnect`";
        };
        ChannelEndPoint.prototype.doDisconnect = function () {
            throw "Abstract method `doDisconnect`";
        };
        ChannelEndPoint.prototype.sendMessage = function (message) {
            throw "Abstract method `sendMessage`";
        };
        ChannelEndPoint.prototype.messageToEnvelop = function (message) {
            throw "Abstract method `messageToEnvelop`";
        };
        ChannelEndPoint.prototype.envelopToMessage = function (envelop) {
            throw "Abstract method `envelopToMessage`";
        };
        ChannelEndPoint.prototype.doProcessRawChannelMessage = function (message, envelop) {
            throw "Abstract method `doProcessRawChannelMessage`";
        };
        ChannelEndPoint.prototype.doDispatchEnvelop = function (envelop) {
            throw "Abstract method `doDispatchEnvelop`";
        };
        ChannelEndPoint.prototype.connect = function (channel) {
            var _this = this;
            var start = new Date().getTime();
            return new Promise(function (resolve, reject) {
                var connectionAttempt = function () {
                    _this.doConnect(channel).then(resolve, function (reason) {
                        if (new Date().getTime() - start > (_this.connectionTimeout || 3000))
                            reject(reason);
                        else
                            setTimeout(connectionAttempt, _this.connectionInterval);
                    });
                };
                connectionAttempt();
            });
        };
        ChannelEndPoint.prototype.onRawChannelMessage = function (message) {
            this.info("Received raw message: " + JSON.stringify(message));
            var envelop = this.messageToEnvelop(message);
            if (envelop !== undefined && envelop.id != null) {
                if (envelop.inResponseOf != null) {
                    var id = envelop.inResponseOf;
                    var handlers = this.awaitingResponses.get(id);
                    if (!handlers) {
                        this.warn("Response for unknown envelop, timeout occurred?:\n" + JSON.stringify(envelop));
                    }
                    else {
                        this.awaitingResponses.delete(id);
                        handlers[envelop.isRejection ? 1 : 0](envelop.payload);
                    }
                }
                else
                    this.doDispatchEnvelop(envelop);
            }
            else {
                this.doProcessRawChannelMessage(message, envelop);
            }
        };
        ChannelEndPoint.prototype.disconnect = function () {
            this.awaitingResponses.forEach(function (value, id) {
                value[1]("Disconnecting");
            });
            this.awaitingResponses.clear();
            return this.doDisconnect();
        };
        ChannelEndPoint.prototype.getFreshEnvelopId = function () {
            return ENVELOP_COUNTER++;
        };
        ChannelEndPoint.prototype.replyWith = function (envelop, result, isRejection) {
            if (isRejection === void 0) { isRejection = false; }
            this.sendMessage(this.envelopToMessage({
                id: this.getFreshEnvelopId(),
                inResponseOf: envelop.id,
                isRejection: isRejection,
                payload: result
            }));
        };
        ChannelEndPoint.prototype.sendRpcCall = function (payload, timeout) {
            var _this = this;
            this.debug("Sending command: " + payload.toString());
            var id = this.getFreshEnvelopId();
            var envelop = { id: id, payload: payload };
            return new Promise(function (resolve, reject) {
                var timeoutHandler;
                if (timeout != null) {
                    var timeoutHandler_1 = setTimeout(function () {
                        _this.debug("Timeout occurred for: " + JSON.stringify(envelop));
                        if (_this.awaitingResponses.has(id)) {
                            _this.awaitingResponses.delete(id);
                            reject("Timeout while waiting for command result: " + JSON.stringify(payload));
                        }
                    }, timeout);
                }
                _this.awaitingResponses.set(id, [resolve, reject, envelop, timeoutHandler]);
                _this.sendMessage(_this.envelopToMessage(envelop));
            });
        };
        return ChannelEndPoint;
    }(base));
};
