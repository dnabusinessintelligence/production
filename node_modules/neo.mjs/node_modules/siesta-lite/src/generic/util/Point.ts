export type Point   = [ number, number ]

// copied from Siesta.Test.Simulate.Mouse
export const getPathBetweenPoints = function (from : Point, to : Point) : Point[] {
    if (
        typeof from[ 0 ] !== 'number' || typeof from[ 1 ] !== 'number'
        || typeof to[ 0 ] !== 'number' || typeof to[ 1 ] !== 'number'
        || isNaN(from[ 0 ]) || isNaN(from[ 1 ])
        || isNaN(to[ 0 ]) || isNaN(to[ 1 ])
    ) {
        throw new Error('Incorrect arguments passed to getPathBetweenPoints: ' + from + ', ' + to);
    }

    var stops   = [],
        x0      = Math.floor(from[ 0 ]),
        y0      = Math.floor(from[ 1 ]),

        x1      = Math.floor(to[ 0 ]),
        y1      = Math.floor(to[ 1 ]),

        dx      = Math.abs(x1 - x0),
        dy      = Math.abs(y1 - y0),

        err, e2;

    let sx      = x0 < x1 ? 1 : -1
    let sy      = y0 < y1 ? 1 : -1

    err         = dx - dy;

    while (x0 !== x1 || y0 !== y1) {
        e2      = 2 * err;

        if (e2 > -dy) {
            err     = err - dy;
            x0      = x0 + sx;
        }

        if (e2 < dx) {
            err     = err + dx;
            y0      = y0 + sy;
        }
        stops.push([ x0, y0 ]);
    }

    var last        = stops[ stops.length - 1 ];

    if (stops.length > 0 && (last[ 0 ] !== to[ 0 ] || last[ 1 ] !== to[ 1 ])) {
        stops.push(to.slice());
    }

    return stops;
}


export const filterPathAccordingToPrecision = (path : Point[], precision : number = 1) : Point[] => {
    const pathLength    = path.length

    // we always want to simulate the events for 2 initial and 2 final points of the path
    if (pathLength <= 4) return path.slice()

    const filtered      = [ path[ 0 ], path[ 1 ] ]

    for (let i = 3; i < pathLength - 2; i += precision) filtered.push(path[ i ])

    filtered.push(path[ pathLength - 2 ], path[ pathLength - 1])

    return filtered
}
