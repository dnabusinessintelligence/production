// import GridBase from '../../../Grid0.x/lib/Common/Base.js';
// import GridModel from '../../../Grid0.x/lib/Common/data/Model.js';
//
// //---------------------------------------------------------------------------------------
// declare class MyBase {
//     constructor(...args : any[])
//
//     construct(...args : any[])
// }
//
// declare class MyModel extends MyBase {
//     static fields       : any[]
//
//     id                  : ModelId
//     internalId          : ModelInternalId
//
//     parent
//
//     traverse (fn : (model : Model) => any, skipSelf? : boolean)
// }
//
// export const Base : Constructable<MyBase> = GridBase
// export const Model : Constructable<MyModel> = GridModel
//
// export type Base = MyBase
// export type Model = MyModel


//---------------------------------------------------------------------------------------
// One should use Base as a base class, instead of Object
// this is because, when compiled to ES3 (which we use for NodeJS / IE11 compatibility), Object is called as a
// super constructor and returned value from it is used as an instance object
// that instance object will be missing prototype inheritance
export class Base {}


//---------------------------------------------------------------------------------------
export type Constructable<T = Base> = new (...args : any[]) => T

// See https://github.com/Microsoft/TypeScript/issues/21994
// and https://github.com/Microsoft/TypeScript/issues/21997
export type ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never;
export type InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : never;
export type Mixin<T extends (...args:any[]) => any> = InstanceType<ReturnType<T>>;


//---------------------------------------------------------------------------------------
export const binarySearch = <T = number>(

    value       : T,
    array       : T[],
    comparator  : (a : T, b : T) => number = <any>((a : number, b : number) => a - b)

) : { found : boolean, index : number } => {

    let left    = 0
    let right   = array.length

    while (left < right) {
        // | 0 to make it integer, faster according to: https://jsperf.com/or-vs-floor/2
        const mid   = (left + right) / 2 | 0

        const compare = comparator(value, array[ mid ])

        if (compare === 0)
            return { found : true, index : mid }
        else if (compare < 0)
            right   = mid
        else
            left    = mid + 1
    }

    return { found : false, index : right }
}


//---------------------------------------------------------------------------------------
export const stripDuplicates = <T>(array : T[]) : T[] => {
    const seen  : Map<T, boolean> = new Map()

    return array.filter(el => {
        if (seen.has(el)) return false

        seen.set(el, true)

        return true
    })
}
