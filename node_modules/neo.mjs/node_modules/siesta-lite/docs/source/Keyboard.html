<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
<span id='Siesta-Test-UserAgent-Keyboard'>/**
</span>@class Siesta.Test.UserAgent.Keyboard

This is a mixin, providing the keyboard events simulation functionality.


*/

Role(&#39;Siesta.Test.UserAgent.Keyboard&#39;, {

    requires        : [ &#39;normalizeElement&#39;, &#39;runPromiseAsync&#39;, &#39;activeElement&#39; ],

    does : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Test.Browser.Role.CanWorkWithKeyboard
    ],

    has : {
    },

    methods: {

<span id='Siesta-Test-UserAgent-Keyboard-method-type'>        /**
</span>         * This method will simulate keyboard typing on either a provided DOM element, or, if omitted, on the currently focuced DOM element.
         * Simulation of certain special keys such as ENTER, ESC, LEFT etc is supported.
         * You can type these special keys by using the all uppercase name the key inside square brackets: `[ENTER]`, `[BACKSPACE]`.
         * See {@link Siesta.Test.UserAgent.KeyCodes} for a list of key names.
         *
         * For example:
         *
    t.type(el, &#39;Foo bar[ENTER]&#39;, function () {
        ...
    })
         *
         * To type the `[ENTER]` as plain text and not as a special character - use double square brackets: `[[ENTER]]`
         *
         * To specify a control key like &quot;shift/control/alt&quot; of to be pressed during typing, use the `options` argument, for example:

    t.type(el, &#39;Foo bar[ENTER]&#39;, callback, scope, { shiftKey : true, ctrlKey : true, altKey : true });

         *
         * This method returns a `Promise` which is resolved once the click has completed:
         *
         *      t.type(&#39;#someEl&#39;, &#39;someText&#39;).then(function () {
         *          return t.type(&#39;#anotherEl&#39;, &#39;someText&#39;)
         *      }).then(function () {
         *          return t.type(&#39;#yetAnotherEl&#39;, &#39;someText&#39;)
         *      })
         *
         * See also {@link Siesta.Test#chain chain} method for slimer chaining notation.
         *
         * @param {Siesta.Test.ActionTarget} el The element to type into. If not provided, currently focused element will be used as target.
         * @param {String} text The text to type, including any names of special keys in square brackets.
         * @param {Function} callback A function to be called after the type operation is completed.
         * @param {Object} scope The scope for the callback
         * @param {Object} options (optional) any extra options used to configure the DOM key events (like holding shiftKey, ctrlKey, altKey etc).
         * @param {Boolean} clearExisting (optional) true to clear existing text in the target before typing
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        type : function (el, text, callback, scope, options, clearExisting, performTargetCheck) {
            if (text == null) throw &#39;Must supply a string to type&#39;;

            // Skip target check if user is simply targeting whatever is focused
            if (!el) performTargetCheck = false;

            el              = el || this.activeElement();

            var targetCheckPromise =
                performTargetCheck !== false
                    ?
                this.waitForTargetAndSyncMousePosition(el, null, &#39;Type: &#39; + text, [], false, false)
                    :
                Promise.resolve()

            var me          = this

            return me.runPromiseAsync(targetCheckPromise.then(function () {
                el              = me.normalizeElement(el);

                if (!el || el.disabled) {
                    return;
                }

                if (clearExisting) {
                    el.value    = &#39;&#39;
                }

                var queue       = new Siesta.Util.Queue({
                    deferer         : me.originalSetTimeout,
                    deferClearer    : me.originalClearTimeout,

                    interval        : me.simulator.actionDelay,
                    callbackDelay   : me.simulator.afterActionDelay,

                    observeTest     : me
                })

                // Manually focus the element to type into first
                queue.addStep({
                    processor       : function () {
                        me.focus(el)
                    }
                })

                // focus the element one more time for IE - me seems to fix the weird sporadic failures in 042_keyevent_simulation3.t.js
                // failures are caused by the field &quot;blur&quot; immediately after 1st focus
                // no Ext &quot;focus/blur&quot; methods seems to be called, so it can be a browser behavior
                bowser.msie &amp;&amp; queue.addStep({
                    processor       : function () {
                        me.focus(el)
                    }
                })

                queue.addStep({
                    isAsync         : true,

                    processor       : function (stepData) {
                        var promise     = me.simulator.simulateType(text, options, { el : el })

                        me.runPromiseAsync(promise, &#39;&#39;, stepData.next)
                    }
                })

                return new Promise(function (resolve, reject) {
                    queue.run(function () {
                        resolve()
                    })
                })
            }), &#39;type : `&#39; + text + &#39;`&#39;, callback, scope)
        },

<span id='Siesta-Test-UserAgent-Keyboard-method-keyPress'>        /**
</span>         * @param {Siesta.Test.ActionTarget} el
         * @param {String} key
         * @param {Object} options any extra options used to configure the DOM event. This argument can be omitted.
         * @param {Function} callback A function to be called after the type operation is completed.
         * @param {Object} scope The scope for the callback
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         *
         * This method will simluate the key press, translated to the specified DOM element. It is generally exactly equivalent of
         * typing a single character, special characters are supported in the same way as in {@link #type} method.
         */
        keyPress: function (el, key, options, callback, scope) {
            if (typeof options === &#39;function&#39;) {
                callback        = options;
                options         = undefined;
            }

            return this.type(el, key, callback, scope, options)
        }
    }
});


</pre>
</body>
</html>
