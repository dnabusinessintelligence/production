/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {

const Nyc           = require('nyc')

const libReport     = require('nyc/node_modules/istanbul-lib-report')
const reports       = require('nyc/node_modules/istanbul-reports')

const path          = require('path')
const fs            = require('fs')

Role('Siesta.Launcher.Role.CanWorkWithNyc', {

    methods : {

        buildNycArgv : function (rawNycArgs) {
            const configUtil    = require('nyc/lib/config-util')
            const yargs         = configUtil.buildYargs()

            return yargs.parse(rawNycArgs)
        },


        buildNyc : function (argv) {
            if (!argv.instrument)
                argv.instrumenter = './lib/instrumenters/noop'
            else
                argv.instrumenter = './lib/instrumenters/istanbul'

            // otherwise caching of the instrumentation results will be disabled
            argv.isChildProcess = true

            let nyc             = new Nyc(argv)

            if (argv.clean) {
                nyc.reset()
            } else {
                nyc.createTempDirectory()
            }

            return nyc
        },


        // tweaked version of nyc's `nycWriteCoverageFile` method, does not use hard-coded `coverageFinder`
        nycWriteCoverageFile : function (nyc, coverage) {
            // Remove any files that should be excluded but snuck into the coverage
            Object.keys(coverage).forEach(function (absFile) {
                if (!nyc.exclude.shouldInstrument(absFile)) {
                    delete coverage[absFile]
                }
            }, nyc)

            if (nyc.cache) {
                Object.keys(coverage).forEach(function (absFile) {
                    if (nyc.hashCache[absFile] && coverage[absFile]) {
                        coverage[absFile].contentHash = nyc.hashCache[absFile]
                    }
                }, nyc)
            } else {
                coverage = nyc.sourceMaps.remapCoverage(coverage)
            }

            var id = nyc.generateUniqueID()
            var coverageFilename = path.resolve(nyc.tempDirectory(), id + '.json')

            fs.writeFileSync(
                coverageFilename,
                JSON.stringify(coverage),
                'utf-8'
            )
        },


        // tweaked version of nyc's `report` method, uses custom source finder
        nycReport : function (nyc, sourceFinder) {
            var tree
            var map = nyc.getCoverageMapFromAllCoverageFiles()
            var context = libReport.createContext({
                dir : nyc.reportDirectory(),
                watermarks : nyc.config.watermarks,
                sourceFinder : sourceFinder
            })

            tree = libReport.summarizers.pkg(map)

            nyc.reporter.forEach((_reporter) => {
                tree.visit(reports.create(_reporter, {
                    skipEmpty : nyc.config.skipEmpty,
                    skipFull : nyc.config.skipFull
                }), context)
            })
        }

    }
})

}();
