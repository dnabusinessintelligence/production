;if (typeof Joose == "undefined") !function () {;
var Joose = {}

// configuration hash

Joose.C             = typeof JOOSE_CFG != 'undefined' ? JOOSE_CFG : {}

Joose.is_IE         = '\v' == 'v'
Joose.is_NodeJS     = Boolean(typeof process != 'undefined' && process.pid)


Joose.top           = Joose.is_NodeJS && global || this

Joose.stub          = function () {
    return function () { throw new Error("Modules can not be instantiated") }
}


Joose.VERSION       = ({ /*PKGVERSION*/VERSION : '3.50.1' }).VERSION


if (typeof module != 'undefined') module.exports = Joose
/*if (!Joose.is_NodeJS) */
this.Joose = Joose


// Static helpers for Arrays
Joose.A = {

    each : function (array, func, scope) {
        scope = scope || this
        
        for (var i = 0, len = array.length; i < len; i++) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    eachR : function (array, func, scope) {
        scope = scope || this

        for (var i = array.length - 1; i >= 0; i--) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    exists : function (array, value) {
        for (var i = 0, len = array.length; i < len; i++) if (array[i] == value) return true
            
        return false
    },
    
    
    map : function (array, func, scope) {
        scope = scope || this
        
        var res = []
        
        for (var i = 0, len = array.length; i < len; i++) 
            res.push( func.call(scope, array[i], i) )
            
        return res
    },
    

    grep : function (array, func) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (func(t)) a.push(t)
        })
        
        return a
    },
    
    
    remove : function (array, removeEle) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (t !== removeEle) a.push(t)
        })
        
        return a
    }
    
}

// Static helpers for Strings
Joose.S = {
    
    saneSplit : function (str, delimeter) {
        var res = (str || '').split(delimeter)
        
        if (res.length == 1 && !res[0]) res.shift()
        
        return res
    },
    

    uppercaseFirst : function (string) { 
        return string.substr(0, 1).toUpperCase() + string.substr(1, string.length - 1)
    },
    
    
    strToClass : function (name, top) {
        var current = top || Joose.top
        
        Joose.A.each(name.split('.'), function (segment) {
            if (current) 
                current = current[ segment ]
            else
                return false
        })
        
        return current
    }
}

var baseFunc    = function () {}

var enumProps   = [ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ]

var manualEnum  = true

for (var i in { toString : 1 }) manualEnum = false


// Static helpers for objects
Joose.O = {

    each : function (object, func, scope) {
        scope = scope || this
        
        for (var i in object) 
            if (func.call(scope, object[i], i) === false) return false
        
        if (manualEnum) 
            return Joose.A.each(enumProps, function (el) {
                
                if (object.hasOwnProperty(el)) return func.call(scope, object[el], el)
            })
    },
    
    
    eachOwn : function (object, func, scope) {
        scope = scope || this
        
        return Joose.O.each(object, function (value, name) {
            if (object.hasOwnProperty(name)) return func.call(scope, value, name)
        }, scope)
    },
    
    
    copy : function (source, target) {
        target = target || {}
        
        Joose.O.each(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    copyOwn : function (source, target) {
        target = target || {}
        
        Joose.O.eachOwn(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    getMutableCopy : function (object) {
        baseFunc.prototype = object
        
        return new baseFunc()
    },
    
    
    extend : function (target, source) {
        return Joose.O.copy(source, target)
    },
    
    
    isEmpty : function (object) {
        for (var i in object) if (object.hasOwnProperty(i)) return false
        
        return true
    },
    
    
    isInstance: function (obj) {
        return obj && obj.meta && obj.constructor == obj.meta.c
    },
    
    
    isClass : function (obj) {
        return obj && obj.meta && obj.meta.c == obj
    },
    
    
    wantArray : function (obj) {
        if (obj instanceof Array) return obj
        
        return [ obj ]
    },
    
    
    // this was a bug in WebKit, which gives typeof / / == 'function'
    // should be monitored and removed at some point in the future
    isFunction : function (obj) {
        return typeof obj == 'function' && obj.constructor != / /.constructor
    }
}


//initializers

Joose.I = {
    Array       : function () { return [] },
    Object      : function () { return {} },
    Function    : function () { return arguments.callee },
    Now         : function () { return new Date() }
};
Joose.Proto = Joose.stub()

Joose.Proto.Empty = Joose.stub()
    
Joose.Proto.Empty.meta = {};
;(function () {

    Joose.Proto.Object = Joose.stub()
    
    
    var SUPER = function () {
        var self = SUPER.caller
        
        if (self == SUPERARG) self = self.caller
        
        if (!self.SUPER) throw "Invalid call to SUPER"
        
        return self.SUPER[self.methodName].apply(this, arguments)
    }
    
    
    var SUPERARG = function () {
        return this.SUPER.apply(this, arguments[0])
    }
    
    
    
    Joose.Proto.Object.prototype = {
        
        SUPERARG : SUPERARG,
        SUPER : SUPER,
        
        INNER : function () {
            throw "Invalid call to INNER"
        },                
        
        
        BUILD : function (config) {
            return arguments.length == 1 && typeof config == 'object' && config || {}
        },
        
        
        initialize: function () {
        },
        
        
        toString: function () {
            return "a " + this.meta.name
        }
        
    }
        
    Joose.Proto.Object.meta = {
        constructor     : Joose.Proto.Object,
        
        methods         : Joose.O.copy(Joose.Proto.Object.prototype),
        attributes      : {}
    }
    
    Joose.Proto.Object.prototype.meta = Joose.Proto.Object.meta

})();
;(function () {

    Joose.Proto.Class = function () {
        return this.initialize(this.BUILD.apply(this, arguments)) || this
    }
    
    var bootstrap = {
        
        VERSION             : null,
        AUTHORITY           : null,
        
        constructor         : Joose.Proto.Class,
        superClass          : null,
        
        name                : null,
        
        attributes          : null,
        methods             : null,
        
        meta                : null,
        c                   : null,
        
        defaultSuperClass   : Joose.Proto.Object,
        
        
        BUILD : function (name, extend) {
            this.name = name
            
            return { __extend__ : extend || {} }
        },
        
        
        initialize: function (props) {
            var extend      = props.__extend__
            
            this.VERSION    = extend.VERSION
            this.AUTHORITY  = extend.AUTHORITY
            
            delete extend.VERSION
            delete extend.AUTHORITY
            
            this.c = this.extractConstructor(extend)
            
            this.adaptConstructor(this.c)
            
            if (extend.constructorOnly) {
                delete extend.constructorOnly
                return
            }
            
            this.construct(extend)
        },
        
        
        construct : function (extend) {
            if (!this.prepareProps(extend)) return
            
            var superClass = this.superClass = this.extractSuperClass(extend)
            
            this.processSuperClass(superClass)
            
            this.adaptPrototype(this.c.prototype)
            
            this.finalize(extend)
        },
        
        
        finalize : function (extend) {
            this.processStem(extend)
            
            this.extend(extend)
        },
        
        
        //if the extension returns false from this method it should re-enter 'construct'
        prepareProps : function (extend) {
            return true
        },
        
        
        extractConstructor : function (extend) {
            var res = extend.hasOwnProperty('constructor') ? extend.constructor : this.defaultConstructor()
            
            delete extend.constructor
            
            return res
        },
        
        
        extractSuperClass : function (extend) {
            if (extend.hasOwnProperty('isa') && !extend.isa) throw new Error("Attempt to inherit from undefined superclass [" + this.name + "]")
            
            var res = extend.isa || this.defaultSuperClass
            
            delete extend.isa
            
            return res
        },
        
        
        processStem : function () {
            var superMeta       = this.superClass.meta
            
            this.methods        = Joose.O.getMutableCopy(superMeta.methods || {})
            this.attributes     = Joose.O.getMutableCopy(superMeta.attributes || {})
        },
        
        
        initInstance : function (instance, props) {
            Joose.O.copyOwn(props, instance)
        },
        
        
        defaultConstructor: function () {
            return function (arg) {
                var BUILD = this.BUILD
                
                var args = BUILD && BUILD.apply(this, arguments) || arg || {}
                
                var thisMeta    = this.meta
                
                thisMeta.initInstance(this, args)
                
                return thisMeta.hasMethod('initialize') && this.initialize(args) || this
            }
        },
        
        
        processSuperClass: function (superClass) {
            var superProto      = superClass.prototype
            
            //non-Joose superclasses
            if (!superClass.meta) {
                
                var extend = Joose.O.copy(superProto)
                
                extend.isa = Joose.Proto.Empty
                // clear potential value in the `extend.constructor` to prevent it from being modified
                delete extend.constructor
                
                var meta = new this.defaultSuperClass.meta.constructor(null, extend)
                
                superClass.meta = superProto.meta = meta
                
                meta.c = superClass
            }
            
            this.c.prototype    = Joose.O.getMutableCopy(superProto)
            this.c.superClass   = superProto
        },
        
        
        adaptConstructor: function (c) {
            c.meta = this
            
            if (!c.hasOwnProperty('toString')) c.toString = function () { return this.meta.name }
        },
    
        
        adaptPrototype: function (proto) {
            //this will fix weird semantic of native "constructor" property to more intuitive (idea borrowed from Ext)
            proto.constructor   = this.c
            proto.meta          = this
        },
        
        
        addMethod: function (name, func) {
            func.SUPER = this.superClass.prototype
            
            //chrome don't allow to redefine the "name" property
            func.methodName = name
            
            this.methods[name] = func
            this.c.prototype[name] = func
        },
        
        
        addAttribute: function (name, init) {
            this.attributes[name] = init
            this.c.prototype[name] = init
        },
        
        
        removeMethod : function (name) {
            delete this.methods[name]
            delete this.c.prototype[name]
        },
    
        
        removeAttribute: function (name) {
            delete this.attributes[name]
            delete this.c.prototype[name]
        },
        
        
        hasMethod: function (name) { 
            return Boolean(this.methods[name])
        },
        
        
        hasAttribute: function (name) { 
            return this.attributes[name] !== undefined
        },
        
    
        hasOwnMethod: function (name) { 
            return this.hasMethod(name) && this.methods.hasOwnProperty(name)
        },
        
        
        hasOwnAttribute: function (name) { 
            return this.hasAttribute(name) && this.attributes.hasOwnProperty(name)
        },
        
        
        extend : function (props) {
            Joose.O.eachOwn(props, function (value, name) {
                if (name != 'meta' && name != 'constructor') 
                    if (Joose.O.isFunction(value) && !value.meta) 
                        this.addMethod(name, value) 
                    else 
                        this.addAttribute(name, value)
            }, this)
        },
        
        
        subClassOf : function (classObject, extend) {
            return this.subClass(extend, null, classObject)
        },
    
    
        subClass : function (extend, name, classObject) {
            extend      = extend        || {}
            extend.isa  = classObject   || this.c
            
            return new this.constructor(name, extend).c
        },
        
        
        instantiate : function () {
            var f = function () {}
            
            f.prototype = this.c.prototype
            
            var obj = new f()
            
            return this.c.apply(obj, arguments) || obj
        }
    }
    
    //micro bootstraping
    
    Joose.Proto.Class.prototype = Joose.O.getMutableCopy(Joose.Proto.Object.prototype)
    
    Joose.O.extend(Joose.Proto.Class.prototype, bootstrap)
    
    Joose.Proto.Class.prototype.meta = new Joose.Proto.Class('Joose.Proto.Class', bootstrap)
    
    
    
    Joose.Proto.Class.meta.addMethod('isa', function (someClass) {
        var f = function () {}
        
        f.prototype = this.c.prototype
        
        return new f() instanceof someClass
    })
})();
Joose.Managed = Joose.stub()

Joose.Managed.Property = new Joose.Proto.Class('Joose.Managed.Property', {
    
    name            : null,
    
    init            : null,
    value           : null,
    
    definedIn       : null,
    
    
    initialize : function (props) {
        Joose.Managed.Property.superClass.initialize.call(this, props)
        
        this.computeValue()
    },
    
    
    computeValue : function () {
        this.value = this.init
    },    
    
    
    //targetClass is still open at this stage
    preApply : function (targetClass) {
    },
    

    //targetClass is already open at this stage
    postUnApply : function (targetClass) {
    },
    
    
    apply : function (target) {
        target[this.name] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target[this.name] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from[this.name]
    },
    
    
    cloneProps : function () {
        return {
            name        : this.name, 
            init        : this.init,
            definedIn   : this.definedIn
        }
    },

    
    clone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    }
    
    
}).c;
Joose.Managed.Property.ConflictMarker = new Joose.Proto.Class('Joose.Managed.Property.ConflictMarker', {
    
    isa : Joose.Managed.Property,

    apply : function (target) {
        throw new Error("Attempt to apply ConflictMarker [" + this.name + "] to [" + target + "]")
    }
    
}).c;
Joose.Managed.Property.Requirement = new Joose.Proto.Class('Joose.Managed.Property.Requirement', {
    
    isa : Joose.Managed.Property,

    
    apply : function (target) {
        if (!target.meta.hasMethod(this.name)) 
            throw new Error("Requirement [" + this.name + "], defined in [" + this.definedIn.definedIn.name + "] is not satisfied for class [" + target + "]")
    },
    
    
    unapply : function (from) {
    }
    
}).c;
Joose.Managed.Property.Attribute = new Joose.Proto.Class('Joose.Managed.Property.Attribute', {
    
    isa : Joose.Managed.Property,
    
    slot                : null,
    
    
    initialize : function () {
        Joose.Managed.Property.Attribute.superClass.initialize.apply(this, arguments)
        
        this.slot = this.name
    },
    
    
    apply : function (target) {
        target.prototype[ this.slot ] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target.prototype[ this.slot ] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from.prototype[this.slot]
    },
    
    
    clearValue : function (instance) {
        delete instance[ this.slot ]
    },
    
    
    hasValue : function (instance) {
        return instance.hasOwnProperty(this.slot)
    },
        
        
    getRawValueFrom : function (instance) {
        return instance[ this.slot ]
    },
    
    
    setRawValueTo : function (instance, value) {
        instance[ this.slot ] = value
        
        return this
    }
    
}).c;
Joose.Managed.Property.MethodModifier = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier', {
    
    isa : Joose.Managed.Property,

    
    prepareWrapper : function () {
        throw "Abstract method [prepareWrapper] of " + this + " was called"
    },
    
    
    apply : function (target) {
        var name            = this.name
        var targetProto     = target.prototype
        var isOwn           = targetProto.hasOwnProperty(name)
        var original        = targetProto[name]
        var superProto      = target.meta.superClass.prototype
        
        
        var originalCall = isOwn ? original : function () { 
            return superProto[name].apply(this, arguments) 
        }
        
        var methodWrapper = this.prepareWrapper({
            name            : name,
            modifier        : this.value, 
            
            isOwn           : isOwn,
            originalCall    : originalCall, 
            
            superProto      : superProto,
            
            target          : target
        })
        
        if (isOwn) methodWrapper.__ORIGINAL__ = original
        
        methodWrapper.__CONTAIN__   = this.value
        methodWrapper.__METHOD__    = this
        this.value.displayName      = this.getDisplayName(target)
        methodWrapper.displayName   = 'internal wrapper' 
        
        targetProto[name] = methodWrapper
    },
    
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    },
    
    
    isAppliedTo : function (target) {
        var targetCont = target.prototype[this.name]
        
        return targetCont && targetCont.__CONTAIN__ == this.value
    },
    
    
    unapply : function (from) {
        var name = this.name
        var fromProto = from.prototype
        var original = fromProto[name].__ORIGINAL__
        
        if (!this.isAppliedTo(from)) throw "Unapply of method [" + name + "] from class [" + from + "] failed"
        
        //if modifier was applied to own method - restore it
        if (original) 
            fromProto[name] = original
        //otherwise - just delete it, to reveal the inherited method 
        else
            delete fromProto[name]
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Override = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Override', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        var superProto      = params.superProto
        var superMetaConst  = superProto.meta.constructor
        
        //call to Joose.Proto level, require some additional processing
        var isCallToProto = (superMetaConst == Joose.Proto.Class || superMetaConst == Joose.Proto.Object) && !(params.isOwn && originalCall.IS_OVERRIDE) 
        
        var original = originalCall
        
        if (isCallToProto) original = function () {
            var beforeSUPER = this.SUPER
            
            this.SUPER  = superProto.SUPER
            
            var res = originalCall.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }

        var override = function () {
            
            var beforeSUPER = this.SUPER
            
            this.SUPER  = original
            
            var res = modifier.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }
        
        override.IS_OVERRIDE = true
        
        return override
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[override ' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.Put = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Put', {
    
    isa : Joose.Managed.Property.MethodModifier.Override,


    prepareWrapper : function (params) {
        
        if (params.isOwn) throw "Method [" + params.name + "] is applying over something [" + params.originalCall + "] in class [" + params.target + "]"
        
        return Joose.Managed.Property.MethodModifier.Put.superClass.prepareWrapper.call(this, params)
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.After = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.After', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            var res = originalCall.apply(this, arguments)
            modifier.apply(this, arguments)
            return res
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[after ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Before = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Before', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            modifier.apply(this, arguments)
            return originalCall.apply(this, arguments)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[before ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Around = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Around', {
    
    isa : Joose.Managed.Property.MethodModifier,

    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        var me
        
        var bound = function () {
            return originalCall.apply(me, arguments)
        }
            
        return function () {
            me = this
            
            var boundArr = [ bound ]
            boundArr.push.apply(boundArr, arguments)
            
            return modifier.apply(this, boundArr)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[around ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Augment = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Augment', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var AUGMENT = function () {
            
            //populate callstack to the most deep non-augment method
            var callstack = []
            
            var self = AUGMENT
            
            do {
                callstack.push(self.IS_AUGMENT ? self.__CONTAIN__ : self)
                
                self = self.IS_AUGMENT && (self.__ORIGINAL__ || self.SUPER[self.methodName])
            } while (self)
            
            
            //save previous INNER
            var beforeINNER = this.INNER
            
            //create new INNER
            this.INNER = function () {
                var innerCall = callstack.pop()
                
                return innerCall ? innerCall.apply(this, arguments) : undefined
            }
            
            //augment modifier results in hypotetical INNER call of the same method in subclass 
            var res = this.INNER.apply(this, arguments)
            
            //restore previous INNER chain
            this.INNER = beforeINNER
            
            return res
        }
        
        AUGMENT.methodName  = params.name
        AUGMENT.SUPER       = params.superProto
        AUGMENT.IS_AUGMENT  = true
        
        return AUGMENT
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[augment ' + this.name + ']'
    }
    
}).c;
Joose.Managed.PropertySet = new Joose.Proto.Class('Joose.Managed.PropertySet', {
    
    isa                       : Joose.Managed.Property,

    properties                : null,
    
    propertyMetaClass         : Joose.Managed.Property,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.superClass.initialize.call(this, props)
        
        //XXX this guards the meta roles :)
        this.properties = props.properties || {}
    },
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta || this.propertyMetaClass
        delete props.meta
        
        props.definedIn     = this
        props.name          = name
        
        return this.properties[name] = new metaClass(props)
    },
    
    
    addPropertyObject : function (object) {
        return this.properties[object.name] = object
    },
    
    
    removeProperty : function (name) {
        var prop = this.properties[name]
        
        delete this.properties[name]
        
        return prop
    },
    
    
    haveProperty : function (name) {
        return this.properties[name] != null
    },
    

    haveOwnProperty : function (name) {
        return this.haveProperty(name) && this.properties.hasOwnProperty(name)
    },
    
    
    getProperty : function (name) {
        return this.properties[name]
    },
    
    
    //includes inherited properties (probably you wants 'eachOwn', which process only "own" (including consumed from Roles) properties) 
    each : function (func, scope) {
        Joose.O.each(this.properties, func, scope || this)
    },
    
    
    eachOwn : function (func, scope) {
        Joose.O.eachOwn(this.properties, func, scope || this)
    },
    
    
    //synonym for each
    eachAll : function (func, scope) {
        this.each(func, scope)
    },
    
    
    cloneProps : function () {
        var props = Joose.Managed.PropertySet.superClass.cloneProps.call(this)
        
        props.propertyMetaClass     = this.propertyMetaClass
        
        return props
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        clone.properties = Joose.O.copyOwn(this.properties)
        
        return clone
    },
    
    
    cleanClone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    },
    
    
    alias : function (what) {
        var props = this.properties
        
        Joose.O.each(what, function (aliasName, originalName) {
            var original = props[originalName]
            
            if (original) this.addPropertyObject(original.clone(aliasName))
        }, this)
    },
    
    
    exclude : function (what) {
        var props = this.properties
        
        Joose.A.each(what, function (name) {
            delete props[name]
        })
    },
    
    
    beforeConsumedBy : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.eachOwn(function (property, name) {
            var targetProperty = targetProps[name]
            
            if (targetProperty instanceof Joose.Managed.Property.ConflictMarker) return
            
            if (!targetProps.hasOwnProperty(name) || targetProperty == null) {
                target.addPropertyObject(property)
                return
            }
            
            if (targetProperty == property) return
            
            target.removeProperty(name)
            target.addProperty(name, {
                meta : Joose.Managed.Property.ConflictMarker
            })
        }, this)
    },
    
    
    composeTo : function (target) {
        this.eachOwn(function (property, name) {
            if (!target.haveOwnProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeFrom : function () {
        if (!arguments.length) return
        
        var flattening = this.cleanClone()
        
        Joose.A.each(arguments, function (arg) {
            var isDescriptor    = !(arg instanceof Joose.Managed.PropertySet)
            var propSet         = isDescriptor ? arg.propertySet : arg
            
            propSet.beforeConsumedBy(this, flattening)
            
            if (isDescriptor) {
                if (arg.alias || arg.exclude)   propSet = propSet.clone()
                if (arg.alias)                  propSet.alias(arg.alias)
                if (arg.exclude)                propSet.exclude(arg.exclude)
            }
            
            propSet.flattenTo(flattening)
        }, this)
        
        flattening.composeTo(this)
    },
    
    
    preApply : function (target) {
        this.eachOwn(function (property) {
            property.preApply(target)
        })
    },
    
    
    apply : function (target) {
        this.eachOwn(function (property) {
            property.apply(target)
        })
    },
    
    
    unapply : function (from) {
        this.eachOwn(function (property) {
            property.unapply(from)
        })
    },
    
    
    postUnApply : function (target) {
        this.eachOwn(function (property) {
            property.postUnApply(target)
        })
    }
    
}).c
;
var __ID__ = 1


Joose.Managed.PropertySet.Mutable = new Joose.Proto.Class('Joose.Managed.PropertySet.Mutable', {
    
    isa                 : Joose.Managed.PropertySet,

    ID                  : null,
    
    derivatives         : null,
    
    opened              : null,
    
    composedFrom        : null,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.Mutable.superClass.initialize.call(this, props)
        
        //initially opened
        this.opened             = 1
        this.derivatives        = {}
        this.ID                 = __ID__++
        this.composedFrom       = []
    },
    
    
    addComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            this.composedFrom.push(arg)
            
            var propSet = arg instanceof Joose.Managed.PropertySet ? arg : arg.propertySet
                
            propSet.derivatives[this.ID] = this
        }, this)
    },
    
    
    removeComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            
            var i = 0
            
            while (i < this.composedFrom.length) {
                var propSet = this.composedFrom[i]
                propSet = propSet instanceof Joose.Managed.PropertySet ? propSet : propSet.propertySet
                
                if (arg == propSet) {
                    delete propSet.derivatives[this.ID]
                    this.composedFrom.splice(i, 1)
                } else i++
            }
            
        }, this)
    },
    
    
    ensureOpen : function () {
        if (!this.opened) throw "Mutation of closed property set: [" + this.name + "]"
    },
    
    
    addProperty : function (name, props) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addProperty.call(this, name, props)
    },
    

    addPropertyObject : function (object) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addPropertyObject.call(this, object)
    },
    
    
    removeProperty : function (name) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.removeProperty.call(this, name)
    },
    
    
    composeFrom : function () {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.composeFrom.apply(this, this.composedFrom)
    },
    
    
    open : function () {
        this.opened++
        
        if (this.opened == 1) {
        
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.open()
            })
            
            this.deCompose()
        }
    },
    
    
    close : function () {
        if (!this.opened) throw "Unmatched 'close' operation on property set: [" + this.name + "]"
        
        if (this.opened == 1) {
            this.reCompose()
            
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.close()
            })
        }
        this.opened--
    },
    
    
    reCompose : function () {
        this.composeFrom()
    },
    
    
    deCompose : function () {
        this.eachOwn(function (property, name) {
            if (property.definedIn != this) this.removeProperty(name)
        }, this)
    }
    
}).c;
Joose.Managed.StemElement = function () { throw "Modules may not be instantiated." }

Joose.Managed.StemElement.Attributes = new Joose.Proto.Class('Joose.Managed.StemElement.Attributes', {
    
    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Attribute
    
}).c
;
Joose.Managed.StemElement.Methods = new Joose.Proto.Class('Joose.Managed.StemElement.Methods', {
    
    isa : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass : Joose.Managed.Property.MethodModifier.Put,

    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.Requirements = new Joose.Proto.Class('Joose.Managed.StemElement.Requirements', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Requirement,
    
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        this.each(function (property, name) {
            if (!target.haveProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },
    
    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.MethodModifiers = new Joose.Proto.Class('Joose.Managed.StemElement.MethodModifiers', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : null,
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta
        delete props.meta
        
        props.definedIn         = this
        props.name              = name
        
        var modifier            = new metaClass(props)
        var properties          = this.properties
        
        if (!properties[name]) properties[ name ] = []
        
        properties[name].push(modifier)
        
        return modifier
    },
    

    addPropertyObject : function (object) {
        var name            = object.name
        var properties      = this.properties
        
        if (!properties[name]) properties[name] = []
        
        properties[name].push(object)
        
        return object
    },
    
    
    //remove only the last modifier
    removeProperty : function (name) {
        if (!this.haveProperty(name)) return undefined
        
        var properties      = this.properties
        var modifier        = properties[ name ].pop()
        
        //if all modifiers were removed - clearing the properties
        if (!properties[name].length) Joose.Managed.StemElement.MethodModifiers.superClass.removeProperty.call(this, name)
        
        return modifier
    },
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (modifiersArr, name) {
            var targetModifiersArr = targetProps[name]
            
            if (targetModifiersArr == null) targetModifiersArr = targetProps[name] = []
            
            Joose.A.each(modifiersArr, function (modifier) {
                if (!Joose.A.exists(targetModifiersArr, modifier)) targetModifiersArr.push(modifier)
            })
            
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },

    
    deCompose : function () {
        this.each(function (modifiersArr, name) {
            var i = 0
            
            while (i < modifiersArr.length) 
                if (modifiersArr[i].definedIn != this) 
                    modifiersArr.splice(i, 1)
                else 
                    i++
        })
    },
    
    
    preApply : function (target) {
    },

    
    postUnApply : function (target) {
    },
    
    
    apply : function (target) {
        this.each(function (modifiersArr, name) {
            Joose.A.each(modifiersArr, function (modifier) {
                modifier.apply(target)
            })
        })
    },
    
    
    unapply : function (from) {
        this.each(function (modifiersArr, name) {
            for (var i = modifiersArr.length - 1; i >=0 ; i--) modifiersArr[i].unapply(from)
        })
    }
    
    
    
}).c;
Joose.Managed.PropertySet.Composition = new Joose.Proto.Class('Joose.Managed.PropertySet.Composition', {
    
    isa                         : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass           : Joose.Managed.PropertySet.Mutable,
    
    processOrder                : null,

    
    each : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.each(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
    },
    
    
    eachR : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.eachR(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
        
        
//        var props           = this.properties
//        var processOrder    = this.processOrder
//        
//        for(var i = processOrder.length - 1; i >= 0; i--) 
//            func.call(scope || this, props[ processOrder[i] ], processOrder[i])
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        this.each(function (property) {
            clone.addPropertyObject(property.clone())
        })
        
        return clone
    },
    
    
    alias : function (what) {
        this.each(function (property) {
            property.alias(what)
        })
    },
    
    
    exclude : function (what) {
        this.each(function (property) {
            property.exclude(what)
        })
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.flattenTo(subTarget)
        })
    },
    
    
    composeTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.composeTo(subTarget)
        })
    },
    
    
    
    deCompose : function () {
        this.eachR(function (property) {
            property.open()
        })
        
        Joose.Managed.PropertySet.Composition.superClass.deCompose.call(this)
    },
    
    
    reCompose : function () {
        Joose.Managed.PropertySet.Composition.superClass.reCompose.call(this)
        
        this.each(function (property) {
            property.close()
        })
    },
    
    
    unapply : function (from) {
        this.eachR(function (property) {
            property.unapply(from)
        })
    }
    
}).c
;
Joose.Managed.Stem = new Joose.Proto.Class('Joose.Managed.Stem', {
    
    isa                  : Joose.Managed.PropertySet.Composition,
    
    targetMeta           : null,
    
    attributesMC         : Joose.Managed.StemElement.Attributes,
    methodsMC            : Joose.Managed.StemElement.Methods,
    requirementsMC       : Joose.Managed.StemElement.Requirements,
    methodsModifiersMC   : Joose.Managed.StemElement.MethodModifiers,
    
    processOrder         : [ 'attributes', 'methods', 'requirements', 'methodsModifiers' ],
    
    
    initialize : function (props) {
        Joose.Managed.Stem.superClass.initialize.call(this, props)
        
        var targetMeta = this.targetMeta
        
        this.addProperty('attributes', {
            meta : this.attributesMC,
            
            //it can be no 'targetMeta' in clones
            properties : targetMeta ? targetMeta.attributes : {}
        })
        
        
        this.addProperty('methods', {
            meta : this.methodsMC,
            
            properties : targetMeta ? targetMeta.methods : {}
        })
        
        
        this.addProperty('requirements', {
            meta : this.requirementsMC
        })
        
        
        this.addProperty('methodsModifiers', {
            meta : this.methodsModifiersMC
        })
    },
    
    
    reCompose : function () {
        var c       = this.targetMeta.c
        
        this.preApply(c)
        
        Joose.Managed.Stem.superClass.reCompose.call(this)
        
        this.apply(c)
    },
    
    
    deCompose : function () {
        var c       = this.targetMeta.c
        
        this.unapply(c)
        
        Joose.Managed.Stem.superClass.deCompose.call(this)
        
        this.postUnApply(c)
    }
    
    
}).c
;
Joose.Managed.Builder = new Joose.Proto.Class('Joose.Managed.Builder', {
    
    targetMeta          : null,
    
    
    _buildStart : function (targetMeta, props) {
        targetMeta.stem.open()
        
        Joose.A.each([ 'trait', 'traits', 'removeTrait', 'removeTraits', 'does', 'doesnot', 'doesnt' ], function (builder) {
            if (props[builder]) {
                this[builder](targetMeta, props[builder])
                delete props[builder]
            }
        }, this)
    },
    
    
    _extend : function (props) {
        if (Joose.O.isEmpty(props)) return
        
        var targetMeta = this.targetMeta
        
        this._buildStart(targetMeta, props)
        
        Joose.O.eachOwn(props, function (value, name) {
            var handler = this[name]
            
            if (!handler) throw new Error("Unknown builder [" + name + "] was used during extending of [" + targetMeta.c + "]")
            
            handler.call(this, targetMeta, value)
        }, this)
        
        this._buildComplete(targetMeta, props)
    },
    

    _buildComplete : function (targetMeta, props) {
        targetMeta.stem.close()
    },
    
    
    methods : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addMethod(name, value)
        })
    },
    

    removeMethods : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethod(name)
        })
    },
    
    
    have : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addAttribute(name, value)
        })
    },
    
    
    havenot : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeAttribute(name)
        })
    },
    

    havent : function (targetMeta, info) {
        this.havenot(targetMeta, info)
    },
    
    
    after : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.After)
        })
    },
    
    
    before : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Before)
        })
    },
    
    
    override : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Override)
        })
    },
    
    
    around : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Around)
        })
    },
    
    
    augment : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Augment)
        })
    },
    
    
    removeModifier : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethodModifier(name)
        })
    },
    
    
    does : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.addRole(desc)
        })
    },
    

    doesnot : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.removeRole(desc)
        })
    },
    
    
    doesnt : function (targetMeta, info) {
        this.doesnot(targetMeta, info)
    },
    
    
    trait : function () {
        this.traits.apply(this, arguments)
    },
    
    
    traits : function (targetMeta, info) {
        if (targetMeta.firstPass) return
        
        if (!targetMeta.meta.isDetached) throw "Can't apply trait to not detached class"
        
        targetMeta.meta.extend({
            does : info
        })
    },
    
    
    removeTrait : function () {
        this.removeTraits.apply(this, arguments)
    },
     
    
    removeTraits : function (targetMeta, info) {
        if (!targetMeta.meta.isDetached) throw "Can't remove trait from not detached class"
        
        targetMeta.meta.extend({
            doesnot : info
        })
    },
    
    name : function (targetMeta, name) {
        targetMeta.name     = name
    }
    
}).c;
Joose.Managed.Class = new Joose.Proto.Class('Joose.Managed.Class', {
    
    isa                         : Joose.Proto.Class,
    
    stem                        : null,
    stemClass                   : Joose.Managed.Stem,
    stemClassCreated            : false,
    
    builder                     : null,
    builderClass                : Joose.Managed.Builder,
    builderClassCreated         : false,
    
    isDetached                  : false,
    firstPass                   : true,
    
    // a special instance, which, when passed as 1st argument to constructor, signifies that constructor should
    // skips traits processing for this instance
    skipTraitsAnchor            : {},
    
    
    //build for metaclasses - collects traits from roles
    BUILD : function () {
        var sup = Joose.Managed.Class.superClass.BUILD.apply(this, arguments)
        
        var props   = sup.__extend__
        
        var traits = Joose.O.wantArray(props.trait || props.traits || [])
        delete props.trait
        delete props.traits
        
        Joose.A.each(Joose.O.wantArray(props.does || []), function (arg) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            if (role.meta.meta.isDetached) traits.push(role.meta.constructor)
        })
        
        if (traits.length) props.traits = traits 
        
        return sup
    },
    
    
    initInstance : function (instance, props) {
        Joose.O.each(this.attributes, function (attribute, name) {
            
            if (attribute instanceof Joose.Managed.Attribute) 
                attribute.initFromConfig(instance, props)
            else 
                if (props.hasOwnProperty(name)) instance[name] = props[name]
        })
    },
    
    
    // we are using the same constructor for usual and meta- classes
    defaultConstructor: function () {
        return function (skipTraitsAnchor, params) {
            
            var thisMeta    = this.meta
            var skipTraits  = skipTraitsAnchor == thisMeta.skipTraitsAnchor
            
            var BUILD       = this.BUILD
            
            var props       = BUILD && BUILD.apply(this, skipTraits ? params : arguments) || (skipTraits ? params[0] : skipTraitsAnchor) || {}
            
            
            // either looking for traits in __extend__ (meta-class) or in usual props (usual class)
            var extend  = props.__extend__ || props
            
            var traits = extend.trait || extend.traits
            
            if (traits || extend.detached) {
                delete extend.trait
                delete extend.traits
                delete extend.detached
                
                if (!skipTraits) {
                    var classWithTrait  = thisMeta.subClass({ does : traits || [] }, thisMeta.name)
                    var meta            = classWithTrait.meta
                    meta.isDetached     = true
                    
                    return meta.instantiate(thisMeta.skipTraitsAnchor, arguments)
                }
            }
            
            thisMeta.initInstance(this, props)
            
            return thisMeta.hasMethod('initialize') && this.initialize(props) || this
        }
    },
    
    
    finalize: function (extend) {
        Joose.Managed.Class.superClass.finalize.call(this, extend)
        
        this.stem.close()
        
        this.afterMutate()
    },
    
    
    processStem : function () {
        Joose.Managed.Class.superClass.processStem.call(this)
        
        this.builder    = new this.builderClass({ targetMeta : this })
        this.stem       = new this.stemClass({ name : this.name, targetMeta : this })
        
        var builderClass = this.getClassInAttribute('builderClass')
        
        if (builderClass) {
            this.builderClassCreated = true
            this.addAttribute('builderClass', this.subClassOf(builderClass))
        }
        
        
        var stemClass = this.getClassInAttribute('stemClass')
        
        if (stemClass) {
            this.stemClassCreated = true
            this.addAttribute('stemClass', this.subClassOf(stemClass))
        }
    },
    
    
    extend : function (props) {
        if (props.builder) {
            this.getBuilderTarget().meta.extend(props.builder)
            delete props.builder
        }
        
        if (props.stem) {
            this.getStemTarget().meta.extend(props.stem)
            delete props.stem
        }
        
        this.builder._extend(props)
        
        this.firstPass = false
        
        if (!this.stem.opened) this.afterMutate()
    },
    
    
    getBuilderTarget : function () {
        var builderClass = this.getClassInAttribute('builderClass')
        if (!builderClass) throw "Attempt to extend a builder on non-meta class"
        
        return builderClass
    },
    

    getStemTarget : function () {
        var stemClass = this.getClassInAttribute('stemClass')
        if (!stemClass) throw "Attempt to extend a stem on non-meta class"
        
        return stemClass
    },
    
    
    getClassInAttribute : function (attributeName) {
        var attrClass = this.getAttribute(attributeName)
        if (attrClass instanceof Joose.Managed.Property.Attribute) attrClass = attrClass.value
        
        return attrClass
    },
    
    
    addMethodModifier: function (name, func, type) {
        var props = {}
        
        props.init = func
        props.meta = type
        
        return this.stem.properties.methodsModifiers.addProperty(name, props)
    },
    
    
    removeMethodModifier: function (name) {
        return this.stem.properties.methodsModifiers.removeProperty(name)
    },
    
    
    addMethod: function (name, func, props) {
        props = props || {}
        props.init = func
        
        return this.stem.properties.methods.addProperty(name, props)
    },
    
    
    addAttribute: function (name, init, props) {
        props = props || {}
        props.init = init
        
        return this.stem.properties.attributes.addProperty(name, props)
    },
    
    
    removeMethod : function (name) {
        return this.stem.properties.methods.removeProperty(name)
    },

    
    removeAttribute: function (name) {
        return this.stem.properties.attributes.removeProperty(name)
    },
    
    
    hasMethod: function (name) {
        return this.stem.properties.methods.haveProperty(name)
    },
    
    
    hasAttribute: function (name) { 
        return this.stem.properties.attributes.haveProperty(name)
    },
    
    
    hasMethodModifiersFor : function (name) {
        return this.stem.properties.methodsModifiers.haveProperty(name)
    },
    
    
    hasOwnMethod: function (name) {
        return this.stem.properties.methods.haveOwnProperty(name)
    },
    
    
    hasOwnAttribute: function (name) { 
        return this.stem.properties.attributes.haveOwnProperty(name)
    },
    

    getMethod : function (name) {
        return this.stem.properties.methods.getProperty(name)
    },
    
    
    getAttribute : function (name) {
        return this.stem.properties.attributes.getProperty(name)
    },
    
    
    eachRole : function (roles, func, scope) {
        Joose.A.each(roles, function (arg, index) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            func.call(scope || this, arg, role, index)
        }, this)
    },
    
    
    addRole : function () {
        
        this.eachRole(arguments, function (arg, role) {
            
            this.beforeRoleAdd(role)
            
            var desc = arg
            
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference should be stored
            //into 'propertySet' field
            if (role != arg) {
                desc.propertySet = role.meta.stem
                delete desc.role
            } else
                desc = desc.meta.stem
            
            this.stem.addComposeInfo(desc)
            
        }, this)
    },
    
    
    beforeRoleAdd : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            does : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            does : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.traits(this, roleMeta.constructor)
    },
    
    
    beforeRoleRemove : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            doesnt : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            doesnt : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.removeTraits(this, roleMeta.constructor)
    },
    
    
    removeRole : function () {
        this.eachRole(arguments, function (arg, role) {
            this.beforeRoleRemove(role)
            
            this.stem.removeComposeInfo(role.meta.stem)
        }, this)
    },
    
    
    getRoles : function () {
        
        return Joose.A.map(this.stem.composedFrom, function (composeDesc) {
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference is stored
            //into 'propertySet' field
            if (!(composeDesc instanceof Joose.Managed.PropertySet)) return composeDesc.propertySet
            
            return composeDesc.targetMeta.c
        })
    },
    
    
    does : function (role) {
        var myRoles = this.getRoles()
        
        for (var i = 0; i < myRoles.length; i++) if (role == myRoles[i]) return true
        for (var i = 0; i < myRoles.length; i++) if (myRoles[i].meta.does(role)) return true
        
        var superMeta = this.superClass.meta
        
        // considering the case of inheriting from non-Joose classes
        if (this.superClass != Joose.Proto.Empty && superMeta && superMeta.meta && superMeta.meta.hasMethod('does')) return superMeta.does(role)
        
        return false
    },
    
    
    getMethods : function () {
        return this.stem.properties.methods
    },
    
    
    getAttributes : function () {
        return this.stem.properties.attributes
    },
    
    
    afterMutate : function () {
    },
    
    
    getCurrentMethod : function () {
        for (var wrapper = arguments.callee.caller, count = 0; wrapper && count < 5; wrapper = wrapper.caller, count++)
            if (wrapper.__METHOD__) return wrapper.__METHOD__
        
        return null
    }
    
    
}).c;
Joose.Managed.Role = new Joose.Managed.Class('Joose.Managed.Role', {
    
    isa                         : Joose.Managed.Class,
    
    have : {
        defaultSuperClass       : Joose.Proto.Empty,
        
        builderRole             : null,
        stemRole                : null
    },
    
    
    methods : {
        
        defaultConstructor : function () {
            return function () {
                throw new Error("Roles cant be instantiated")
            }
        },
        

        processSuperClass : function () {
            if (this.superClass != this.defaultSuperClass) throw new Error("Roles can't inherit from anything")
        },
        
        
        getBuilderTarget : function () {
            if (!this.builderRole) {
                this.builderRole = new this.constructor().c
                this.builderClassCreated = true
            }
            
            return this.builderRole
        },
        
    
        getStemTarget : function () {
            if (!this.stemRole) {
                this.stemRole = new this.constructor().c
                this.stemClassCreated = true
            }
            
            return this.stemRole
        },
        
    
        addRequirement : function (methodName) {
            this.stem.properties.requirements.addProperty(methodName, {})
        }
        
    },
    

    stem : {
        methods : {
            
            apply : function () {
            },
            
            
            unapply : function () {
            }
        }
    },
    
    
    builder : {
        methods : {
            requires : function (targetClassMeta, info) {
                Joose.A.each(Joose.O.wantArray(info), function (methodName) {
                    targetClassMeta.addRequirement(methodName)
                }, this)
            }
        }
    }
    
}).c;
Joose.Managed.Attribute = new Joose.Managed.Class('Joose.Managed.Attribute', {
    
    isa : Joose.Managed.Property.Attribute,
    
    have : {
        is              : null,
        
        builder         : null,
        
        isPrivate       : false,
        
        role            : null,
        
        publicName      : null,
        setterName      : null,
        getterName      : null,
        
        //indicates the logical readableness/writeableness of the attribute
        readable        : false,
        writeable       : false,
        
        //indicates the physical presense of the accessor (may be absent for "combined" accessors for example)
        hasGetter       : false,
        hasSetter       : false,
        
        required        : false,
        
        canInlineSetRaw : true,
        canInlineGetRaw : true
    },
    
    
    after : {
        initialize : function () {
            var name = this.name
            
            this.publicName = name.replace(/^_+/, '')
            
            this.slot = this.isPrivate ? '$' + name : name
            
            this.setterName = this.setterName || this.getSetterName()
            this.getterName = this.getterName || this.getGetterName()
            
            this.readable  = this.hasGetter = /^r/i.test(this.is)
            this.writeable = this.hasSetter = /^.w/i.test(this.is)
        }
    },
    
    
    override : {
        
        computeValue : function () {
            var init    = this.init
            
            if (Joose.O.isClass(init) || !Joose.O.isFunction(init)) this.SUPER()
        },
        
        
        preApply : function (targetClass) {
            targetClass.meta.extend({
                methods : this.getAccessorsFor(targetClass)
            })
        },
        
        
        postUnApply : function (from) {
            from.meta.extend({
                removeMethods : this.getAccessorsFrom(from)
            })
        }
        
    },
    
    
    methods : {
        
        getAccessorsFor : function (targetClass) {
            var targetMeta = targetClass.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var methods = {}
            
            if (this.hasSetter && !targetMeta.hasMethod(setterName)) {
                methods[setterName] = this.getSetter()
                methods[setterName].ACCESSOR_FROM = this
            }
            
            if (this.hasGetter && !targetMeta.hasMethod(getterName)) {
                methods[getterName] = this.getGetter()
                methods[getterName].ACCESSOR_FROM = this
            }
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var targetMeta = from.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var setter = this.hasSetter && targetMeta.getMethod(setterName)
            var getter = this.hasGetter && targetMeta.getMethod(getterName)
            
            var removeMethods = []
            
            if (setter && setter.value.ACCESSOR_FROM == this) removeMethods.push(setterName)
            if (getter && getter.value.ACCESSOR_FROM == this) removeMethods.push(getterName)
            
            return removeMethods
        },
        
        
        getGetterName : function () {
            return 'get' + Joose.S.uppercaseFirst(this.publicName)
        },


        getSetterName : function () {
            return 'set' + Joose.S.uppercaseFirst(this.publicName)
        },
        
        
        getSetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineSetRaw)
                return function (value) {
                    this[ slot ] = value
                    
                    return this
                }
            else
                return function () {
                    return me.setRawValueTo.apply(this, arguments)
                }
        },
        
        
        getGetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineGetRaw)
                return function (value) {
                    return this[ slot ]
                }
            else
                return function () {
                    return me.getRawValueFrom.apply(this, arguments)
                }
        },
        
        
        getValueFrom : function (instance) {
            var getterName      = this.getterName
            
            if (this.readable && instance.meta.hasMethod(getterName)) return instance[ getterName ]()
            
            return this.getRawValueFrom(instance)
        },
        
        
        setValueTo : function (instance, value) {
            var setterName      = this.setterName
            
            if (this.writeable && instance.meta.hasMethod(setterName)) 
                instance[ setterName ](value)
            else
                this.setRawValueTo(instance, value)
        },
        
        
        initFromConfig : function (instance, config) {
            var name            = this.name
            
            var value, isSet = false
            
            if (config.hasOwnProperty(name)) {
                value = config[name]
                isSet = true
            } else {
                var init    = this.init
                
                // simple function (not class) has been used as "init" value
                if (Joose.O.isFunction(init) && !Joose.O.isClass(init)) {
                    
                    value = init.call(instance, config, name)
                    
                    isSet = true
                    
                } else if (this.builder) {
                    
                    value = instance[ this.builder.replace(/^this\./, '') ](config, name)
                    isSet = true
                }
            }
            
            if (isSet)
                this.setRawValueTo(instance, value)
            else 
                if (this.required) throw new Error("Required attribute [" + name + "] is missed during initialization of " + instance)
        }
    }

}).c
;
Joose.Managed.Attribute.Builder = new Joose.Managed.Role('Joose.Managed.Attribute.Builder', {
    
    
    have : {
        defaultAttributeClass : Joose.Managed.Attribute
    },
    
    builder : {
        
        methods : {
            
            has : function (targetClassMeta, info) {
                Joose.O.eachOwn(info, function (props, name) {
                    if (typeof props != 'object' || props == null || props.constructor == / /.constructor) props = { init : props }
                    
                    props.meta = props.meta || targetClassMeta.defaultAttributeClass
                    
                    if (/^__/.test(name)) {
                        name = name.replace(/^_+/, '')
                        
                        props.isPrivate = true
                    }
                    
                    targetClassMeta.addAttribute(name, props.init, props)
                }, this)
            },
            
            
            hasnot : function (targetClassMeta, info) {
                this.havenot(targetClassMeta, info)
            },
            
            
            hasnt : function (targetClassMeta, info) {
                this.hasnot(targetClassMeta, info)
            }
        }
            
    }
    
}).c
;
Joose.Managed.My = new Joose.Managed.Role('Joose.Managed.My', {
    
    have : {
        myClass                         : null,
        
        needToReAlias                   : false
    },
    
    
    methods : {
        createMy : function (extend) {
            var thisMeta        = this.meta
            var isRole          = this instanceof Joose.Managed.Role
            
            var myExtend        = extend.my || {}
            delete extend.my
            
            // Symbiont will generally have the same meta class as its hoster, excepting the cases, when the superclass also have the symbiont. 
            // In such cases, the meta class for symbiont will be inherited (unless explicitly specified)
            var superClassMy    = this.superClass.meta.myClass
            
            if (!isRole && !myExtend.isa && superClassMy) myExtend.isa = superClassMy
            

            if (!myExtend.meta && !myExtend.isa) myExtend.meta = this.constructor
            
            myExtend.name       = this.name + '.my'
            
            var createdClass    = this.myClass = Class(myExtend)
            
            var c               = this.c
            
            c.prototype.my      = c.my = isRole ? createdClass : new createdClass({ HOST : c })
            
            this.needToReAlias = true
        },
        
        
        aliasStaticMethods : function () {
            this.needToReAlias = false
            
            var c           = this.c
            var myProto     = this.myClass.prototype
            
            Joose.O.eachOwn(c, function (property, name) {
                if (property.IS_ALIAS) delete c[ name ] 
            })
            
            this.myClass.meta.stem.properties.methods.each(function (method, name) {
                
                if (!c[ name ])
                    (c[ name ] = function () {
                        return myProto[ name ].apply(c.my, arguments)
                    }).IS_ALIAS = true
            })
        }
    },
    
    
    override : {
        
        extend : function (props) {
            var myClass = this.myClass
            
            if (!myClass && this.superClass.meta.myClass) this.createMy(props)
            
            if (props.my) {
                if (!myClass) 
                    this.createMy(props)
                else {
                    this.needToReAlias = true
                    
                    myClass.meta.extend(props.my)
                    delete props.my
                }
            }
            
            this.SUPER(props)
            
            if (this.needToReAlias && !(this instanceof Joose.Managed.Role)) this.aliasStaticMethods()
        }  
    },
    
    
    before : {
        
        addRole : function () {
            var myStem
            
            Joose.A.each(arguments, function (arg) {
                
                if (!arg) throw new Error("Attempt to consume an undefined Role into [" + this.name + "]")
                
                //instanceof Class to allow treat classes as roles
                var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
                
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    
                    if (!this.myClass) {
                        this.createMy({
                            my : {
                                does : role.meta.myClass
                            }
                        })
                        return
                    }
                    
                    myStem = this.myClass.meta.stem
                    if (!myStem.opened) myStem.open()
                    
                    myStem.addComposeInfo(role.my.meta.stem)
                }
            }, this)
            
            if (myStem) {
                myStem.close()
                
                this.needToReAlias = true
            }
        },
        
        
        removeRole : function () {
            if (!this.myClass) return
            
            var myStem = this.myClass.meta.stem
            myStem.open()
            
            Joose.A.each(arguments, function (role) {
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    myStem.removeComposeInfo(role.my.meta.stem)
                    
                    this.needToReAlias = true
                }
            }, this)
            
            myStem.close()
        }
        
    }
    
}).c;
Joose.Namespace = Joose.stub()

Joose.Namespace.Able = new Joose.Managed.Role('Joose.Namespace.Able', {

    have : {
        bodyFunc                : null
    },
    
    
    before : {
        extend : function (extend) {
            if (extend.body) {
                this.bodyFunc = extend.body
                delete extend.body
            }
        }
    },
    
    
    after: {
        
        afterMutate : function () {
            var bodyFunc = this.bodyFunc
            delete this.bodyFunc
            
            if (bodyFunc) Joose.Namespace.Manager.my.executeIn(this.c, bodyFunc)
        }
    }
    
}).c;
Joose.Managed.Bootstrap = new Joose.Managed.Role('Joose.Managed.Bootstrap', {
    
    does   : [ Joose.Namespace.Able, Joose.Managed.My, Joose.Managed.Attribute.Builder ]
    
}).c
;
Joose.Meta = Joose.stub()


Joose.Meta.Object = new Joose.Proto.Class('Joose.Meta.Object', {
    
    isa             : Joose.Proto.Object
    
}).c


;
Joose.Meta.Class = new Joose.Managed.Class('Joose.Meta.Class', {
    
    isa                         : Joose.Managed.Class,
    
    does                        : Joose.Managed.Bootstrap,
    
    have : {
        defaultSuperClass       : Joose.Meta.Object
    }
    
}).c

;
Joose.Meta.Role = new Joose.Meta.Class('Joose.Meta.Role', {
    
    isa                         : Joose.Managed.Role,
    
    does                        : Joose.Managed.Bootstrap
    
}).c;
Joose.Namespace.Keeper = new Joose.Meta.Class('Joose.Namespace.Keeper', {
    
    isa         : Joose.Meta.Class,
    
    have        : {
        externalConstructor             : null
    },
    
    
    methods: {
        
        defaultConstructor: function () {
            
            return function () {
                //constructors should assume that meta is attached to 'arguments.callee' (not to 'this') 
                var thisMeta = arguments.callee.meta
                
                if (thisMeta instanceof Joose.Namespace.Keeper) throw new Error("Module [" + thisMeta.c + "] may not be instantiated. Forgot to 'use' the class with the same name?")
                
                var externalConstructor = thisMeta.externalConstructor
                
                if (typeof externalConstructor == 'function') {
                    
                    externalConstructor.meta = thisMeta
                    
                    return externalConstructor.apply(this, arguments)
                }
                
                throw "NamespaceKeeper of [" + thisMeta.name + "] was planted incorrectly."
            }
        },
        
        
        //withClass should be not constructed yet on this stage (see Joose.Proto.Class.construct)
        //it should be on the 'constructorOnly' life stage (should already have constructor)
        plant: function (withClass) {
            var keeper = this.c
            
            keeper.meta = withClass.meta
            
            keeper.meta.c = keeper
            keeper.meta.externalConstructor = withClass
        }
    }
    
}).c


;
Joose.Namespace.Manager = new Joose.Managed.Class('Joose.Namespace.Manager', {
    
    have : {
        current     : null
    },
    
    
    methods : {
        
        initialize : function () {
            this.current    = [ Joose.top ]
        },
        
        
        getCurrent: function () {
            return this.current[0]
        },
        
        
        executeIn : function (ns, func) {
            var current = this.current
            
            current.unshift(ns)
            var res = func.call(ns, ns)
            current.shift()
            
            return res
        },
        
        
        earlyCreate : function (name, metaClass, props) {
            props.constructorOnly = true
            
            return new metaClass(name, props).c
        },
        
        
        //this function establishing the full "namespace chain" (including the last element)
        create : function (nsName, metaClass, extend) {
            
            //if no name provided, then we creating an anonymous class, so just skip all the namespace manipulations
            if (!nsName) return new metaClass(nsName, extend).c
            
            var me = this
            
            if (/^\./.test(nsName)) return this.executeIn(Joose.top, function () {
                return me.create(nsName.replace(/^\./, ''), metaClass, extend)
            })
            
            var props   = extend || {}
            
            var parts   = Joose.S.saneSplit(nsName, '.')
            var object  = this.getCurrent()
            var soFar   = object == Joose.top ? [] : Joose.S.saneSplit(object.meta.name, '.')
            
            for (var i = 0; i < parts.length; i++) {
                var part        = parts[i]
                var isLast      = i == parts.length - 1
                
                if (part == "meta" || part == "my" || !part) throw "Module name [" + nsName + "] may not include a part called 'meta' or 'my' or empty part."
                
                var cur =   object[part]
                
                soFar.push(part)
                
                var soFarName       = soFar.join(".")
                var needFinalize    = false
                var nsKeeper
                
                // if the namespace segment is empty
                if (typeof cur == "undefined") {
                    if (isLast) {
                        // perform "early create" which just fills the namespace segment with right constructor
                        // this allows us to have a right constructor in the namespace segment when the `body` will be called
                        nsKeeper        = this.earlyCreate(soFarName, metaClass, props)
                        needFinalize    = true
                    } else
                        nsKeeper        = new Joose.Namespace.Keeper(soFarName).c
                    
                    object[part] = nsKeeper
                    
                    cur = nsKeeper
                    
                } else if (isLast && cur && cur.meta) {
                    
                    var currentMeta = cur.meta
                    
                    if (metaClass == Joose.Namespace.Keeper)
                        //`Module` over something case - extend the original
                        currentMeta.extend(props)
                    else {
                        
                        if (currentMeta instanceof Joose.Namespace.Keeper) {
                            
                            currentMeta.plant(this.earlyCreate(soFarName, metaClass, props))
                            
                            needFinalize = true
                        } else
                            if (!Joose.C.ignoreRepeatedDeclarations) throw new Error("Double declaration of [" + soFarName + "]")
                    }
                    
                } else 
                    if (isLast && !(cur && cur.meta && cur.meta.meta)) throw "Trying to setup module " + soFarName + " failed. There is already something: " + cur

                // hook to allow embedd resource into meta
                if (isLast) this.prepareMeta(cur.meta)
                    
                if (needFinalize) cur.meta.construct(props)
                    
                object = cur
            }
            
            return object
        },
        
        
        prepareMeta : function () {
        },
        
        
        prepareProperties : function (name, props, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                props   = name
                name    = null
            }
            
            var meta
            
            if (props && props.meta) {
                meta = props.meta
                delete props.meta
            }
            
            if (!meta)
                if (props && typeof props.isa == 'function' && props.isa.meta)
                    meta = props.isa.meta.constructor
                else
                    meta = defaultMeta
            
            return callback.call(this, name, meta, props)
        },
        
        
        getDefaultHelperFor : function (metaClass) {
            var me = this
            
            return function (name, props) {
                return me.prepareProperties(name, props, metaClass, function (name, meta, props) {
                    return me.create(name, meta, props)
                })
            }
        },
        
        
        register : function (helperName, metaClass, func) {
            var me = this
            
            if (this.meta.hasMethod(helperName)) {
                
                var helper = function () {
                    return me[ helperName ].apply(me, arguments)
                }
                
                if (!Joose.top[ helperName ])   Joose.top[ helperName ]         = helper
                if (!Joose[ helperName ])       Joose[ helperName ]             = helper
                
                if (Joose.is_NodeJS && typeof exports != 'undefined')            exports[ helperName ]    = helper
                
            } else {
                var methods = {}
                
                methods[ helperName ] = func || this.getDefaultHelperFor(metaClass)
                
                this.meta.extend({
                    methods : methods
                })
                
                this.register(helperName)
            }
        },
        
        
        Module : function (name, props) {
            return this.prepareProperties(name, props, Joose.Namespace.Keeper, function (name, meta, props) {
                if (typeof props == 'function') props = { body : props }    
                
                return this.create(name, meta, props)
            })
        }
    }
    
}).c

Joose.Namespace.Manager.my = new Joose.Namespace.Manager()

Joose.Namespace.Manager.my.register('Class', Joose.Meta.Class)
Joose.Namespace.Manager.my.register('Role', Joose.Meta.Role)
Joose.Namespace.Manager.my.register('Module')


// for the rest of the package
var Class       = Joose.Class
var Role        = Joose.Role
;
Role('Joose.Attribute.Delegate', {
    
    have : {
        handles : null
    },
    
    
    override : {
        
        eachDelegate : function (handles, func, scope) {
            if (typeof handles == 'string') return func.call(scope, handles, handles)
            
            if (handles instanceof Array)
                return Joose.A.each(handles, function (delegateTo) {
                    
                    func.call(scope, delegateTo, delegateTo)
                })
                
            if (handles === Object(handles))
                Joose.O.eachOwn(handles, function (delegateTo, handleAs) {
                    
                    func.call(scope, handleAs, delegateTo)
                })
        },
        
        
        getAccessorsFor : function (targetClass) {
            var targetMeta  = targetClass.meta
            var methods     = this.SUPER(targetClass)
            
            var me      = this
            
            this.eachDelegate(this.handles, function (handleAs, delegateTo) {
                
                if (!targetMeta.hasMethod(handleAs)) {
                    var handler = methods[ handleAs ] = function () {
                        var attrValue = me.getValueFrom(this)
                        
                        return attrValue[ delegateTo ].apply(attrValue, arguments)
                    }
                    
                    handler.ACCESSOR_FROM = me
                }
            })
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var methods = this.SUPER(from)
            
            var me          = this
            var targetMeta  = from.meta
            
            this.eachDelegate(this.handles, function (handleAs) {
                
                var handler = targetMeta.getMethod(handleAs)
                
                if (handler && handler.value.ACCESSOR_FROM == me) methods.push(handleAs)
            })
            
            return methods
        }
    }
})

;
Role('Joose.Attribute.Trigger', {
    
    have : {
        trigger        : null
    }, 

    
    after : {
        initialize : function() {
            if (this.trigger) {
                if (!this.writeable) throw new Error("Can't use `trigger` for read-only attributes")
                
                this.hasSetter = true
            }
        }
    },
    
    
    override : {
        
        getSetter : function() {
            var original    = this.SUPER()
            var trigger     = this.trigger
            
            if (!trigger) return original
            
            var me      = this
            var init    = Joose.O.isFunction(me.init) ? null : me.init
            
            return function () {
                var oldValue    = me.hasValue(this) ? me.getValueFrom(this) : init
                
                var res         = original.apply(this, arguments)
                
                trigger.call(this, me.getValueFrom(this), oldValue)
                
                return res
            }
        }
    }
})    

;
Role('Joose.Attribute.Lazy', {
    
    
    have : {
        lazy        : null
    }, 
    
    
    before : {
        computeValue : function () {
            if (typeof this.init == 'function' && this.lazy) {
                this.lazy = this.init    
                delete this.init    
            }
        }
    },
    
    
    after : {
        initialize : function () {
            if (this.lazy) this.readable = this.hasGetter = true
        }
    },
    
    
    override : {
        
        getGetter : function () {
            var original    = this.SUPER()
            var lazy        = this.lazy
            
            if (!lazy) return original
            
            var me      = this    
            
            return function () {
                if (!me.hasValue(this)) {
                    var initializer = typeof lazy == 'function' ? lazy : this[ lazy.replace(/^this\./, '') ]
                    
                    me.setValueTo(this, initializer.apply(this, arguments))
                }
                
                return original.call(this)    
            }
        }
    }
})

;
Role('Joose.Attribute.Accessor.Combined', {
    
    
    have : {
        isCombined        : false
    }, 
    
    
    after : {
        initialize : function() {
            this.isCombined = this.isCombined || /..c/i.test(this.is)
            
            if (this.isCombined) {
                this.slot = '$$' + this.name
                
                this.hasGetter = true
                this.hasSetter = false
                
                this.setterName = this.getterName = this.publicName
            }
        }
    },
    
    
    override : {
        
        getGetter : function() {
            var getter    = this.SUPER()
            
            if (!this.isCombined) return getter
            
            var setter    = this.getSetter()
            
            var me = this
            
            return function () {
                
                if (!arguments.length) {
                    if (me.readable) return getter.call(this)
                    throw new Error("Call to getter of unreadable attribute: [" + me.name + "]")
                }
                
                if (me.writeable) return setter.apply(this, arguments)
                
                throw new Error("Call to setter of read-only attribute: [" + me.name + "]")    
            }
        }
    }
    
})

;
Joose.Managed.Attribute.meta.extend({
    does : [ Joose.Attribute.Delegate, Joose.Attribute.Trigger, Joose.Attribute.Lazy, Joose.Attribute.Accessor.Combined ]
})            

;
Role('Joose.Meta.Singleton', {

    has : {
        forceInstance           : Joose.I.Object,
        instance                : null
    },



    override : {

        defaultConstructor : function () {
            var meta        = this
            var previous    = this.SUPER()

            this.adaptConstructor(previous)

            return function (forceInstance, params) {
                if (forceInstance == meta.forceInstance) return previous.apply(this, params) || this

                var instance = meta.instance

                if (!instance) instance = meta.instance = new meta.c(meta.forceInstance, arguments)

                if (meta.hasMethod('configure')) instance.configure.apply(instance, arguments)

                return instance
            }
        }
    }


})


Joose.Namespace.Manager.my.register('Singleton', Class({
    isa     : Joose.Meta.Class,
    meta    : Joose.Meta.Class,

    does    : Joose.Meta.Singleton
}))
;
;
}();;
;
Class('JooseX.Observable.Event', {
    
    has : {
        name        : { required : true },
        args        : { required : true },
        
        source      : { required : true },
        
        splat       : null,
        current     : null,
        
        bubbling    : true
    },
    
        
    methods : {
        
        stopPropagation : function () {
            this.bubbling = false
        }
    }
})


;
Class('JooseX.Observable.Listener', {

    has : {
        channel     : { required : true },
        eventName   : { required : true },
        
        func        : { required : true },
        scope       : null,
        
        single          : false,
        
        buffer          : null,
        bufferMax       : null,
        
        bufferStartedAt : null,
        bufferTimeout   : null,
        
        delayTimeout    : null,
        
        delay           : null
    },
    
        
    methods : {
        
        activate : function (event, args) {
            var me      = this
            
            if (me.buffer != null) {
                
                if (me.bufferMax != null)
                    if (!me.bufferStartedAt) 
                        me.bufferStartedAt = new Date()
                    else
                        if (new Date - me.bufferStartedAt > me.bufferMax) return
                
                        
                if (me.bufferTimeout) clearTimeout(me.bufferTimeout)
                
                me.bufferTimeout = setTimeout(function () {
                    
                    delete me.bufferStartedAt
                    delete me.bufferTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.buffer)
                
                return
            }
            
            if (me.delay != null) {
                
                me.delayTimeout = setTimeout(function () {
                    
                    delete me.delayTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.delay)
                
                return
            }
            
            return me.doActivate(event, args)
        },
        
        
        doActivate : function (event, args) {
            if (this.single) this.remove()
            
            return this.func.apply(this.scope || event.source, [ event ].concat(args) ) !== false
        },
        
        
        cancel  : function () {
            if (this.buffer) {
                clearTimeout(this.bufferTimeout)
                
                delete this.bufferTimeout
                delete this.bufferStartedAt
            }
            
            if (this.delay) clearTimeout(this.delayTimeout)
        },
        
        
        remove : function () {
            this.channel.removeListener(this)
        }
    }
})


;
Class('JooseX.Observable.Channel', {
    
    has : {
        channels    : Joose.I.Object,
        
        listeners   : Joose.I.Object
    },
    
        
    methods : {
        
        destroy : function () {
            Joose.O.each(this.channels, function (channel, name) {
                channel.purgeListeners()
            })
            
            this.channels   = null
            
            // cleanup paranoya
            Joose.O.each(this.listeners, function (value, name) {
                this.listeners[ name ]  = null
            }, this)
            
            this.listeners  = null
        },
        
        
        // (!) segments array will be destroyed in this method
        getListenersFor : function (segments, name, activators) {
            var listeners = this.listeners
            
            if (listeners[ '**' ]) {
                
                var splat       = segments.concat(name)
                
                Joose.A.each(listeners[ '**' ], function (listener) {
                    activators.push({
                        listener    : listener,
                        splat       : splat
                    })
                })
            }
            
            if (segments.length) {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) next.getListenersFor(segments, name, activators)
            } else {
                
                if (listeners[ '*' ])
                    Joose.A.each(listeners[ '*' ], function (listener) {
                        
                        activators.push({
                            listener    : listener,
                            splat       : name
                        })
                    })
                
                if (listeners[ name ])  
                    Joose.A.each(listeners[ name ], function (listener) {
                        
                        activators.push({
                            listener    : listener
                        })
                    })
            }
        },
        
        
        hasListenerFor : function (segments, name) {
            var listeners = this.listeners
            
            if (listeners[ '**' ] && listeners[ '**' ].length) return true
            
            if (segments.length)  {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) return next.hasListenerFor(segments, name)
                
            } else {
                
                if (listeners[ '*' ] && listeners[ '*' ].length) return true
                
                if (listeners[ name ] && listeners[ name ].length) return true  
            }
            
            return false
        },
        
        
        addListener : function (listener) {
            var eventName   = listener.eventName
            var listeners   = this.listeners
            
            listeners[ eventName ] = listeners[ eventName ] || []
            
            listeners[ eventName ].push(listener)
        },
        
        
        removeListener : function (listenerToRemove) {
            // already purged
            if (!this.listeners) return
            
            var eventListeners      = this.listeners[ listenerToRemove.eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener == listenerToRemove) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        removeListenerByHandler : function (eventName, func, scope) {
            var eventListeners      = this.listeners[ eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener.func == func && listener.scope == scope) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        getSingleChannel : function (name, doNotCreate) {
            var channels    = this.channels
            
            if (channels[ name ]) return channels[ name ]
            
            if (doNotCreate) return null
            
            return channels[ name ] = new JooseX.Observable.Channel()
        },
        
        
        // (!) segments array will be destroyed in this method
        getChannel : function (segments, doNotCreate) {
            if (!segments.length) return this
            
            var next    = this.getSingleChannel(segments.shift(), doNotCreate)
            
            if (doNotCreate && !next) return null
            
            return next.getChannel(segments, doNotCreate)
        }
    }
})


;
Role('JooseX.Observable', {
    
    /*PKGVERSION*/VERSION : 0.04,
    
//    use : [ 
//        'JooseX.Observable.Channel',    
//        'JooseX.Observable.Listener', 
//        'JooseX.Observable.Event'    
//    ],
    
    
//    trait   : 'JooseX.Observable.Meta',
    
    
    has : {
        rootChannel             : {
            is          : 'rw',
            init        : function () { return new JooseX.Observable.Channel() }
        },
        
        suspendCounter          : 0
    },
    
        
    methods : {
        
        getBubbleTarget : function () {
        },
        
        
        parseEventPath : function (path) {
            var channels    = path.split('/')
            var eventName   = channels.pop()
            
            if (channels.length && !channels[ 0 ]) channels.shift()
            
            return {
                channels        : channels,
                eventName       : eventName
            }
        },
        
        
        on : function (path, func, scope, options) {
            if (!func) throw "Not valid listener function provided when subsribing on event: " + path
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels)
            
            var listener    = new JooseX.Observable.Listener(Joose.O.extend(options || {}, {
                channel     : channel,
                eventName   : parsed.eventName,
                
                func        : func,
                scope       : scope
            }))
            
            channel.addListener(listener)
            
            return listener
        },
        
        
        un : function (path, func, scope) {
            
            if (path instanceof JooseX.Observable.Listener) {
                
                path.remove()
                
                return
            }
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels, true)
            
            if (channel) channel.removeListenerByHandler(parsed.eventName, func, scope)
        },
        
        
        emit : function () {
            return this.fireEvent.apply(this, arguments)
        },
        
        
        fireEvent : function (path) {
            if (this.suspendCounter) return
            
            var args        = Array.prototype.slice.call(arguments, 1)

            var event       = new JooseX.Observable.Event({
                name        : path,
                args        : args,
                
                source      : this
            }) 
            
            return this.propagateEvent(event, path, args)
        },
        
        
        propagateEvent : function (event, path, args) {
            if (this.suspendCounter) return
            
            var parsed      = this.parseEventPath(path)
            var eventName   = parsed.eventName
            
            if (!eventName == '*' || eventName == '**') throw new Error("Can't fire an empty event or event with `*`, `**` names ")
            
            var activators  = []
            
            this.getRootChannel().getListenersFor(parsed.channels, eventName, activators)
            
            var res             = true
            
            event.current       = this
            
            if (activators.length) Joose.A.each(activators, function (activator) {
                event.splat = activator.splat
                
                res = activator.listener.activate(event, args) !== false && res
            })
            
            if (event.bubbling) {
                
                var further = this.getBubbleTarget()
                
                if (further) res = further.propagateEvent(event, path, args) !== false && res
            } 
                
            return res
        },
        
        
        hasListenerFor : function (path) {
            var parsed      = this.parseEventPath(path)
            
            return this.getRootChannel().hasListenerFor(parsed.channels, parsed.eventName)
        },
        
        
        purgeListeners  : function () {
            this.rootChannel.destroy()
            
            this.rootChannel = new JooseX.Observable.Channel()
        },
        
        
        suspendEvents : function () {
            this.suspendCounter++
        },
        
        
        resumeEvents : function () {
            this.suspendCounter--
            
            if (this.suspendCounter < 0) this.suspendCounter = 0
        }
    }
});
;
Class('JooseX.Namespace.Depended.Manager', {
    
    my : {
    
        have : {
            
            INC                             : [ 'lib', '/jsan' ],
            
            disableCaching                  : true,
            
            resources                       : {},
            
            resourceTypes                   : {},
            
            ANONYMOUS_RESOURCE_COUNTER      : 0
        },
    
        
        
        methods : {
            
            //get own resource of some thing (resource will be also attached to that abstract thing)
            //if the something is requesting own resource its considered loaded
            getMyResource : function (type, token, me) {
                var resource = this.getResource({
                    type : type,
                    token : token
                })
                
                if (resource.attachedTo && resource.attachedTo != me) throw resource + " is already attached to [" + resource.attachedTo + "]"
                
                resource.attachedTo     = me
                resource.loaded         = true
                resource.loading        = false
                
                return resource
            },
            
            
            getResource : function (descriptor) {
                
                if (typeof descriptor == 'object') {
                    var type                = descriptor.type = descriptor.type || 'javascript'
                    var token               = descriptor.token
                    var requiredVersion     = descriptor.version
                    
                    delete descriptor.version
                    
                } else 
                    if (typeof descriptor == 'string') {
                    
                        var match = /^(\w+):\/\/(.+)/.exec(descriptor)
                        
                        if (match) {
                            // type & token are explicitly specified
                            type    = match[1]
                            token   = match[2]
                            
                            if (type == 'http' || type == 'https') {
                                token   = type + '://' + token
                                type    = 'javascript'
                            }
                        } else {
                            // no type specified
                            token = descriptor
                            
                            type = /\//.test(token) || /\.js$/.test(token) ? 'javascript' : 'joose'
                        }
                    }
                    
                if (!token) {
                    token       = '__ANONYMOUS_RESOURCE__' + this.ANONYMOUS_RESOURCE_COUNTER++
                    descriptor  = undefined
                }
                
                var id = type + '://' + token
                
                var resource = this.resources[id]
                
                if (!resource) {
                    var resourceClass = this.resourceTypes[type]
                    if (!resourceClass) throw new Error("Unknown resource type: [" + type + "]")
                    
                    resource = this.resources[id] = new resourceClass(typeof descriptor == 'object' ? descriptor : { 
                        token : token,
                        
                        type : type
                    })
                }
                
                resource.setRequiredVersion(requiredVersion)
                
                return resource
            },
            
            
            registerResourceClass : function (typeName, resourceClass) {
                this.resourceTypes[typeName] = resourceClass
            },
            
            
            use : function (dependenciesInfo, callback, scope) {
                Class({
                    use    : dependenciesInfo,
                    
                    body   : function () {
                        if (callback) Joose.Namespace.Manager.my.executeIn(Joose.top, function (ns) {
                            callback.call(scope || this, ns)
                        })
                    }
                })
            },
            
            
            getINC : function () {
                var INC         = this.INC
                var original    = use.__ORIGINAL__
                var paths       = use.paths
                
                // user have modified the `use.path` with direct assignment - return `use.paths`
                if (INC == original && paths != original) return paths
                
                // user have modified the `JooseX.Namespace.Depended.Manager.my.INC` with direct assignment - return it
                if (INC != original && paths == original) return INC
                
                if (INC != original && paths != original) throw "Both INC sources has been modified"
                
                // user was only using the in-place array mutations - return any
                return INC
            }
        }
    }
})

use = function (dependenciesInfo, callback, scope) {
    JooseX.Namespace.Depended.Manager.my.use(dependenciesInfo, callback, scope) 
}

use.paths = use.__ORIGINAL__ = JooseX.Namespace.Depended.Manager.my.INC


Joose.I.FutureClass = function (className) { 
    return function () { 
        return eval(className) 
    } 
}


/**

Name
====


JooseX.Namespace.Depended.Manager - A global collection of all resources


SYNOPSIS
========

        JooseX.Namespace.Depended.Manager.my.registerResourceClass('custom-type', JooseX.Namespace.Depended.Resource.Custom)
        

DESCRIPTION
===========

`JooseX.Namespace.Depended.Manager` is a global collection of all resources. 

**Note:** Its a pure [static](http://joose.github.com/Joose/doc/html/Joose/Manual/Static.html) class - all its methods and properties are static.


METHODS
=======

### registerResourceClass

> `void registerResourceClass(String type, Class constructor)`

> After you've created your custom resource class, you need to register it with call to this method.

> Then you can refer to new resources with the following descriptors: 

                {
                    type    : 'custom-type',
                    token   : 'some-token'
                }



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) on freenode or the mailing list at <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](Resource.html)

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at [http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues](http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues)



AUTHORS
=======

Nickolay Platonov [nplatonov@cpan.org](mailto:nplatonov@cpan.org)



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Class('JooseX.Namespace.Depended.Resource', {
    
    has : {
        
        attachedTo          : null,
        
        type                : null,
        token               : null,
        
        id                  : null,
        
        loading             : false,
        loaded              : false,
        ready               : false,
        
        presence            : null,
        readyness           : null,
        
        loadedFromURL       : null,
        
        readyListeners      : Joose.I.Array,
        
        dependencies        : Joose.I.Object,
        
        onBeforeReady       : { is : 'rw', init : null },
        readyDelegated      : false,
        
        version             : { is : 'rw', init : null },
        requiredVersion     : { is : 'rw', init : null },
        
        hasReadyCheckScheduled  : false
    },
    
    
    after: {
        
        initialize: function () {
            if (!this.id) this.id = this.type + '://' + this.token
        }
        
    },

    
    
    methods: {
        
        setOnBeforeReady : function (func) {
            if (this.onBeforeReady) throw "Can't redefine 'onBeforeReady' for " + this
            
            this.onBeforeReady = func
        },
        
        
        setVersion : function (version) {
            if (!version) return
            
            if (this.version && this.version != version) throw new Error("Cant redefine version of " + this)
            
            var requiredVersion = this.requiredVersion
            
            if (requiredVersion && version < requiredVersion) throw new Error("Versions conflict on " + this + " required [" + requiredVersion + "], got [" + version + "]")
                
            this.version = version
        },
        
        
        setRequiredVersion : function (version) {
            if (!version) return
            
            var requiredVersion = this.requiredVersion
            
            if (!requiredVersion || version > requiredVersion) 
                if (this.isLoaded() || this.loading)
                    throw "Cant increase required version - " + this + " is already loaded"
                else
                    this.requiredVersion = version
        },
        
        
        toString : function () {
            return "Resource: id=[" + this.id + "], type=[" + this.meta.name + "]"
        },
        
        
        addDescriptor : function (descriptor) {
            var resource = JooseX.Namespace.Depended.Manager.my.getResource(descriptor)
            
            var dependencies    = this.dependencies
            var resourceID      = resource.id
            
            //if there is already such dependency or the resource is ready
            if (dependencies[ resourceID ] || resource.isReady()) return
            
            var me = this
            //pushing listener to the end(!) of the list
            resource.readyListeners.push(function () {
                
                delete dependencies[ resourceID ]
                me.checkReady()
            })
            
            //adding dependency
            dependencies[ resourceID ] = resource
            
            //we are not ready, since there are depedencies to load                
            this.ready = false
        },
        
        
        handleDependencies : function () {
            // || {} required for classes on which this Role was applied after they were created - they have this.dependencies not initialized
            Joose.O.eachOwn(this.dependencies || {}, function (resource) {
                resource.handleLoad()
            })
            
            this.checkReady()
        },
        
        
        checkReady : function () {
            if (!Joose.O.isEmpty(this.dependencies) || this.hasReadyCheckScheduled) return
            
            if (this.onBeforeReady) {
                
                if (!this.readyDelegated) {
                    this.readyDelegated = true
                    
                    var me = this
                    
                    this.onBeforeReady(function(){
                        me.fireReady()
                    }, me)
                }
            } else 
                this.fireReady()
        },
        
        
        fireReady: function () {
            this.ready      = true
            
            var listeners   = this.readyListeners
            
            this.readyListeners = []
            
            Joose.A.each(listeners, function (listener) {
                listener()
            })
        },
        
        
        isReady : function () {
            if (!this.isLoaded()) return false
            
            var isReady = false
            
            try {
                isReady = this.readyness()
            } catch (e) {
            }
            
            return isReady || this.ready
        },
        
        
        isLoaded : function () {
            var isPresent = false
            
            try {
                isPresent = this.presence()
            } catch (e) {
            }
            
            return isPresent || this.loaded
        },
        
        
        handleLoad: function() {
            
            if (this.isLoaded()) {
                this.checkReady()
                return
            }
            
            if (this.loading) return
            this.loading = true
            
            var urls = Joose.O.wantArray(this.getUrls())
            
            var me = this
            
            
            // this delays the 'checkReady' until the resourse will be *fully* materialized
            // *fully* means that even the main class of the resource is already "ready"
            // the possible other classes in the same file could be not
            // see 110_several_classes_in_file.t.js, 120_script_tag_transport.t.js for example
            me.hasReadyCheckScheduled = true
            
            var onsuccess = function (resourceBlob, url) {
                me.loaded = true
                me.loading = false
                
                me.loadedFromURL = url
                
                Joose.Namespace.Manager.my.executeIn(Joose.top, function () {
                    
                    me.materialize(resourceBlob, url)
                })
                
                me.hasReadyCheckScheduled = false
                
                // handle the dependency of the class after its materialization completition
                me.handleDependencies()
            }
            
            var onerror = function (e) {
                //if no more urls
                if (!urls.length) throw new Error(me + " not found") 
                
                me.load(urls.shift(), onsuccess, onerror)
            }
            
            this.load(urls.shift(), onsuccess, onerror)
        },
        

        getUrls: function () {
            throw "Abstract resource method 'getUrls' was called"
        },
        
        
        load : function (url, onsuccess, onerror) {
            throw "Abstract resource method 'load' was called"
        },
        
        
        materialize : function (resourceBlob) {
            throw "Abstract resource method 'materialize' was called"
        }
        
    }
})


/**

Name
====


JooseX.Namespace.Depended.Resource - Abstract resource class 


SYNOPSIS
========
        
        //mostly for subclassing only
        Class("JooseX.Namespace.Depended.Resource.JavaScript", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Resource` is an abstract resource class. Its not supposed to be used directly, instead you should use
one of its subclasses.


ATTRIBUTES
==========

### attachedTo

> `Object attachedTo`

> An arbitrary object to which this resource is attached (its a corresponding class in JooseX.Namespace.Depended)


### type

> `String type`

> A type of resource  - plain string. `JooseX.Namespace.Depended.Manager` maintain a collection of resource types, accessible 


### token

> `String token`

> A token of resource  - plain string with arbitrary semantic. Each subclass should provide this semantic along with `token -> url` conertion method (locator)  


### id

> `String id`

> An id of resource - is computed as `type + '://' + token'


### loading

> `Boolean loading`

> A sign whether this resource is currently loading

  
### loaded

> `Boolean loaded`

> A sign whether this resource is already loaded


### ready

> `Boolean ready`

> A sign whether this resource is considered ready. Resource is ready, when its loaded, and all its dependencies are ready.


### loadedFromURL

> `String loadedFromURL`

> An url, from which the resource was loaded.


### readyListeners

> `Array[Function] readyListeners`

> An array of functions, which will be called after this resource becomes ready. Functions will be called sequentially. 


### dependencies

> `Object dependencies`

> An object containing the dependencies of this resource. Keys are the `id`s of resources and the values - the resource instances itself.

 
### onBeforeReady

> `Function onBeforeReady`

> A function, which will be called, right after the all dependencies of the resource became ready, but before its own `readyListeners` will be called.
It supposed to perform any needed additional actions to post-process the loaded resource.

> Function will receive two arguments - the 1st is the callback, which should be called when `onBeforeReady` will finish its work. 2nd is the resource instance.

  
### version

> `r/w Number version`

> A version of this resource. Currently is handled as Number, this may change in future releases.

  
### requiredVersion

> `r/w Number requiredVersion`

> A *requiredVersion* version of this resource. Required here means the maximum version from all references to this resource. 



METHODS
=======

### addDescriptor

> `void addDescriptor(Object|String descriptor)`

> Add the resource, described with passed descriptor as the dependency for this resource.


### getUrls

> `String|Array[String] getUrls()`

> Abstract method, will throw an exception if not overriden. It should return the array of urls (or a single url) from which this resource can be potentially loaded. 
This method should take into account the `use.paths` setting


### load

> `void load(String url, Function onsuccess, Function onerror)`

> Abstract method, will throw an exception if not overriden. It should load the content of the resource from the passed `url`. If there was an error during loading
(for example file not found) should not throw the exception. Instead, should call the `onerror` continuation with it (exception instance).

> After successfull loading, should call the `onsuccess` continuation with the resource content as 1st argument, and `url` as 2nd: `onsuccess(text, url)`


### materialize

> `void materialize(String resourceBlob, String url)`

> Abstract method, will throw an exception if not overriden. It should "materialize" the resource. The concrete semantic of this action is determined by resource nature.
For example this method can create some tag in the DOM tree, or execute the code or something else.

> Currently this method is supposed to operate synchronously, this may change in future releases. 
 

SEE ALSO
========

Web page of this package: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/>

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Role('JooseX.Namespace.Depended.Materialize.Eval', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            // "indirect eval" call 
            (window.execScript || window.eval)(resourceBlob)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.Eval - materializator, which treat the resource content as JavaScript code, and use `eval` function to evalute it 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Materialize.Eval, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.Eval` is a materializator role. It provide the implementation of `materialize` method. 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Class('JooseX.Namespace.Depended.Resource.JavaScript', {
    
    isa : JooseX.Namespace.Depended.Resource,
    
    has : {
        
        hasDirectUrl    : false
    },
    
    after: {
        
        initialize: function () {
            var me      = this
            
            // backward compat
            if (this.type == 'nonjoose') this.type = 'javascript'
            
            
            var presence = this.presence
            
            if (typeof presence == 'string') this.presence = function () {
                return eval(presence)
            }
            
            if (!presence) this.presence = function () {
                return eval(me.token)
            }
            
            if (!this.readyness) this.readyness = this.presence
        }
        
    },

    
    methods : {
        
        BUILD : function (config) {
            var token = config.token
            
            var match = /^=(.*)/.exec(token)
            
            if (match) {
                this.hasDirectUrl   = true
                
                token               = match[1]
            }
            
            if (/^http/.test(token)) {
                this.hasDirectUrl   = true
                
                config.trait        = JooseX.Namespace.Depended.Transport.ScriptTag
            }
            
            if (/^\//.test(token)) this.hasDirectUrl   = true
                
            return config
        },
        
        
        getUrls : function () {
            var url = this.token
            
            if (this.hasDirectUrl) return [ url ]
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(url).join('/') + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('javascript',    JooseX.Namespace.Depended.Resource.JavaScript)
JooseX.Namespace.Depended.Manager.my.registerResourceClass('nonjoose',      JooseX.Namespace.Depended.Resource.JavaScript)
;
Class('JooseX.Namespace.Depended.Resource.JooseClass', {
    
    isa : JooseX.Namespace.Depended.Resource.JavaScript,
    
    // NOTE : we don't add the default materialization and transport roles here - they'll be added
    // in one of the Bootstrap/*.js files
    
    after: {
        
        initialize: function () {
            var me = this
            
            this.presence = function () {
                var c = Joose.S.strToClass(me.token)
                
                return c && c.meta.resource
            }
            
            this.readyness = function () {
                var c = eval(me.token)
                
                return c && c.meta.resource.ready
            }
        }
        
    },
    
    
    methods : {
        
        addDescriptor : function (descriptor) {
            if (typeof descriptor == 'object' && !descriptor.token) 
                Joose.O.eachOwn(descriptor, function (version, name) {
                    this.addDescriptor({
                        type : 'joose',
                        token : name,
                        version : version
                    })
                }, this)
            else
                this.SUPER(descriptor)
        },
        
        
        getUrls : function () {
            var urls = []
            var className = this.token.split('.')
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(className).join('/') + '.js' + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('joose', JooseX.Namespace.Depended.Resource.JooseClass);
;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests..
                        // but if the response text presents - we treat this as successfull request
                        // see https://www.assembla.com/spaces/bryntum/tickets/590
                        if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                            callback.call(scope || this, true, req.responseText)
                        else 
                            callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                    return req.responseText; 
                else 
                    throw "File not found: " + url
            
            return null
        }
    }
})
;
};
Role('JooseX.Namespace.Depended.Materialize.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            var loaderNode = document.createElement("script")
            
            loaderNode.text = resourceBlob
            
            //adding to body, because Safari do not create HEAD for iframe's documents
            document.body.appendChild(loaderNode)
        }
    }
})
;
Role('JooseX.Namespace.Depended.Transport.XHRAsync', {
    
    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text, url)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.XHRAsync - transport, which use the asynchronous XHR request for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.XHRAsync, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.XHRAsync` is a transport role. It provide the implementation of `load` method, which use the 
asynchronous XHR request for resource loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    
    methods : {
        
        getScriptTag : function () {
            
        }
    },
    
    
    override : {
        
        load: function (url, onsuccess, onerror) {

            var scriptNode       = document.createElement('script')

            scriptNode.type      = 'text/javascript'
            scriptNode.src       = url
            scriptNode.async     = true
            
            
            if (Joose.is_IE) {
                
                var timeout    = setTimeout(function () {
                    
                    onerror(url + " load failed.")
                    
                }, 10000)
                
                scriptNode.onreadystatechange = function() {
                    
                    var readyState = scriptNode.readyState
                    
                    if (readyState == 'complete' || readyState == 'loaded') {
                        
                        clearTimeout(timeout)
                            
                        onsuccess(null, url)
                    }
                }
                
                
            } else {
                
                scriptNode.onload = function() {
                    onsuccess(scriptNode.text, url)
                }
            
                scriptNode.onerror = function () {
                    onerror(url + " load failed.")
                }
            }
                
            var head            = document.getElementsByTagName('head')[0] || document.body
            
            head.appendChild(scriptNode)
        },
        
        
        materialize : function (blob, url) {
        }
    }
})



/**

Name
====


JooseX.Namespace.Depended.Transport.ScriptTag - transport, which use the &lt;script&gt; tag for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.ScriptTag, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.ScriptTag` is a transport role. It provide the implementation of `load` method, which use the 
&lt;script&gt; tag for resource loading. It also overrides the `materialize` method as &lt;script&gt; tag execute the code along with loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.NodeJS', {

    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var fs = require('fs')
            
            try {
                var content = fs.readFileSync(url, 'utf8')
                
            } catch (e) {
                
                onerror(e)
                
                return
            }
            
            onsuccess(content, url)
            
//            fs.readFile(url, function (err, data) {
//                if (err) {
//                    onerror(err)
//                    
//                    return
//                }
//                
//                onsuccess(data, url)
//            })            
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.Node - transport, which use the `fs.readFileSync()` call of NodeJS, to load the content of resource. 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.Node, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.Node` is a transport role. It provide the implementation of `load` method, 
which use the `fs.readFile()` call of NodeJS for resource loading. 

This transport behaves synchronously.



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Materialize.NodeJS', {

    requires : [ 'handleLoad' ],

    methods : {

        materialize : function (resourceBlob, url) {

//             if (global.__PROVIDER__)
// //                require('vm').runInThisContext(resourceBlob + '', url)
//
// //                // running in Test.Run
// //
//                 eval(resourceBlob + '')
//
//             else
//                 // global scope
//                 require('vm').runInThisContext('(function (exports, require, module, __filename, __dirname) {' + resourceBlob + '})', url)(exports, require, module, __filename, __dirname)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.NodeJS - materializator, which execute the code, using the `Script.runInThisContext` call of NodeJS.


SYNOPSIS
========

        //generally for consuming only

        Class("JooseX.Namespace.Depended.Resource.Custom", {

            isa : JooseX.Namespace.Depended.Resource,

            does : [ JooseX.Namespace.Depended.Materialize.NodeJS, ...]

            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.NodeJS` is a materializator role. It provide the implementation of `materialize` method.


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


*/;
Class('JooseX.Namespace.Depended.Resource.Require', {

    isa     : JooseX.Namespace.Depended.Resource,


    methods : {

        getUrls : function () {
            return [ this.token ]
        },


        load: function (url, onsuccess, onerror) {

            // require.async(url, function (err) {
            //     if (err instanceof Error)
            //         onerror(err)
            //     else
            //         onsuccess('', url)
            // })

        },


        materialize : function () {
        }

    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('require', JooseX.Namespace.Depended.Resource.Require)
;
Role('JooseX.Namespace.Depended', {

    /*VERSION,*/

    meta : Joose.Managed.Role,

    requires : [ 'prepareProperties' ],


    have : {
        containResources                    : [ 'use', 'meta', 'isa', 'does', 'trait', 'traits' ]
    },


    override: {

//        GETCURRENT : function () {
//            var currentModule   = this.getCurrent()
//
//            return currentModule == Joose.top ? 'TOP' : currentModule.meta.name
//        },


        prepareProperties : function (name, extend, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                extend = name
                name = null
            }

            extend = extend || {}

            var summaredDeps    = this.collectAllDeps(extend)
            var currentModule   = this.getCurrent()

            // if (currentModule !== Joose.top && !currentModule.meta) {
            //     require('console').log("CURRENT MODULE: %s", require('util').inspect(currentModule))
            //     require('console').log("TOP: %s", require('util').inspect(Joose.top))
            // }

            var resource = JooseX.Namespace.Depended.Manager.my.getResource({
                type    : 'joose',
                token   : currentModule == Joose.top ? name : currentModule.meta.name + '.' + name
            })


            if (extend.VERSION) resource.setVersion(extend.VERSION)

            //BEGIN executes right after the all dependencies are loaded, but before this module becomes ready (before body())
            //this allows to manually control the "ready-ness" of module (custom pre-processing)
            //BEGIN receives the function (callback), which should be called at the end of custom processing
            if (extend.BEGIN) {
                resource.setOnBeforeReady(extend.BEGIN)

                delete extend.BEGIN
            }

            Joose.A.each(summaredDeps, function (descriptor) {
                resource.addDescriptor(descriptor)
            })


            //skip constructing for classes w/o dependencies
            if (Joose.O.isEmpty(resource.dependencies)) {
                this.inlineAllDeps(extend)

                var res = this.SUPER(name, extend, defaultMeta, callback)

                //this will allow to classes which don't have dependencies to be ready synchronously
                resource.checkReady()

                return res
            } else {

                var me      = this
                var SUPER   = this.SUPER

                var current

                //unshift is critical for correct order of readyListerens processing!
                //constructing is delaying until resource will become ready
                resource.readyListeners.unshift(function () {
                    me.inlineAllDeps(extend)

                    Joose.Namespace.Manager.my.executeIn(currentModule, function () {

                        SUPER.call(me, name, extend, defaultMeta, callback)
                    })
                })

                // running as <script> in browser or as main script in node
                if (!resource.hasReadyCheckScheduled)
                    if (Joose.is_NodeJS)
                        resource.handleDependencies()
                    else
                        // defer the dependencies loading, because they actually could be provided later in the same bundle file
                        // this, however, affect performance, so bundles should be created in the dependencies-ordered way
                        setTimeout(function () {
                            resource.handleDependencies()
                        }, 0)


                return this.create(name, Joose.Namespace.Keeper, {})
            }
        },


        prepareMeta : function (meta) {
            meta.resource = meta.resource || JooseX.Namespace.Depended.Manager.my.getMyResource('joose', meta.name, meta.c)
        }
    },
    //eof override


    methods : {

        alsoDependsFrom : function (extend, summaredDeps) {
        },


        collectAllDeps : function (extend) {
            var summaredDeps    = []
            var me              = this

            //gathering all the related resourses from various builders
            this.collectClassDeps(extend, summaredDeps)

            var extendMy = extend.my

            //gathering resourses of 'my'
            this.collectClassDeps(extendMy, summaredDeps)


            //gathering resourses from own attributes
            if (extend.has) Joose.O.each(extend.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return

                me.collectClassDeps(attr, summaredDeps)
            })

            //gathering resourses from attributes of `my`
            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return

                me.collectClassDeps(attr, summaredDeps)
            })

            //and from externally collected additional resources
            this.alsoDependsFrom(extend, summaredDeps)

            return summaredDeps
        },


        collectClassDeps : function (from, to) {

            if (from) Joose.A.each(this.containResources, function (propName) {

                this.collectDependencies(from[propName], to, from, propName)

            }, this)
        },


        collectDependencies : function (from, to, extend, propName) {
            if (from) Joose.A.each(Joose.O.wantArray(from), function (descriptor) {
                if (descriptor && typeof descriptor != 'function') to.push(descriptor)
            })
        },


        inlineAllDeps : function (extend) {
            var me              = this

            this.inlineDeps(extend)

            var extendMy = extend.my

            if (extendMy) this.inlineDeps(extendMy)


            if (extend.has) Joose.O.each(extend.has, function (attr, name) {

                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })

            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {

                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })
        },


        inlineDeps : function (extend) {
            delete extend.use

            Joose.A.each(this.containResources, function (propName) {

                if (extend[propName]) {

                    var descriptors = []

                    Joose.A.each(Joose.O.wantArray(extend[propName]), function (descriptor, index) {

                        var descType = typeof descriptor

                        if (descType == 'function')
                            descriptors.push(descriptor.meta ? descriptor : (propName != 'isa' ? descriptor() : null ))
                        else
                            if (descType == 'object')
                                if (descriptor.token)
                                    descriptors.push(eval(descriptor.token))
                                else
                                    Joose.O.each(descriptor, function (version, name) {
                                        descriptors.push(eval(name))
                                    })
                            else
                                if (descType == 'string')
                                    descriptors.push(eval(descriptor))
                                else
                                    throw new Error("Wrong dependency descriptor format: " + descriptor)

                    })

                    if (propName != 'isa' && propName != 'meta')
                        extend[propName] = descriptors
                    else
                        if (descriptors.length > 1)
                            throw "Cant specify several super- or meta- classes"
                        else
                            if (descriptors[0]) extend[propName] = descriptors[0]

                }
            })
        }
    }
})


Joose.Namespace.Manager.meta.extend({
    does : JooseX.Namespace.Depended
})

;
if (Joose.is_NodeJS) {

    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.NodeJS, JooseX.Namespace.Depended.Materialize.NodeJS ]
    })
    
    
    
    JooseX.Namespace.Depended.Manager.my.disableCaching = false
    
    Joose.Namespace.Manager.my.containResources.unshift('require')
    
    
    
    JooseX.Namespace.Depended.meta.extend({
        
        override : {
            
            collectDependencies : function (from, to, extend, propName) {
                if (propName != 'require') return this.SUPERARG(arguments)
                
                if (!from) return
                
                Joose.A.each(Joose.O.wantArray(from), function (url) {
                    to.push({
                        type    : 'require',
                        token   : url
                    })
                })
                
                delete extend.require
            }
        }
    })
} else
    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.XHRAsync, JooseX.Namespace.Depended.Materialize.Eval ]
    })
;
;
Class('JooseX.CPS.Continuation', {
    
    has : {
        parent          : null,
        previous        : null,
        
        statements      : Joose.I.Array,
        type            : 'Sequential', // or 'Parallel'
        
        maxAndBranches  : 10,
        noExFromAnd     : false,
        
        entered         : false,
        leaved          : false,
        
        defaultScope    : null,
        
        nextFunc        : null,
        // hackish solution to keep the `nextFunc` from deletion, when it has been set on the `CATCH` statement
        keepNextFunc    : false,    
        
        // re-entry func is analog of "nextFunc" for inter-statements control flow tranfers into single continuation (sequential runcore)
        reEntryFunc     : null,
        
        catchFunc       : null,
        catchScope      : null,
        
        finallyFunc     : null,
        finallyScope    : null,
        
        str             : {
            lazy : 'buildStr'
        }
    },
    
    
    methods : {
        
        deriveChild : function (config) {
            config              = config || {}
            
            config.parent       = this
            
            return new this.constructor(config)
        },
        
        
        deriveSibling : function (config) {
            config              = config || {}
            
            config.parent       = this.parent
            config.previous     = this
            
            return new this.constructor(config)
        },
        
        
        getNextFunc : function () {
            var parent = this.parent
            
            return this.reEntryFunc || this.nextFunc || parent && parent.getNextFunc()
        },
        
        
        getScope    : function () {
            var prev    = this.previous || this.parent
            
            return this.defaultScope || prev && prev.getScope() || Joose.top
        },
        
        
        entry : function () {
            if (this.entered) throw new Error("Can't re-enter the continuation + [" + this + "]")
            
            this.entered    = true
            
            this.getStr()
            
            this[ 'runCore' + this.type ].apply(this, arguments)
        },
        
        
        toString : function () {
            return this.getStr()
        },
        
        
        buildStr : function () {
            var str         = [ 'Statements of the continuation' ]
            
            Joose.A.each(this.statements, function (statement, index) {
                var func        = statement.func
                
                if (func.__CONTAIN__) func = func.__CONTAIN__
                
                str.push('    ' + index + ': ' + func.toString())
            })
            
            return str.join('\n')
        },

        
        runCoreSequential : function () {
            var me          = this
            var statements  = this.statements
            
            if (statements.length) {
                var statement = statements.shift()
                
                var reEntryFunc = function () {
                    me.runCoreSequential.apply(me, arguments)
                }
                
                if (statements.length) 
                    this.reEntryFunc = reEntryFunc
                else
                    delete this.reEntryFunc
                
                var child = this.deriveChild({
                    defaultScope    : statement.scope,
                    
                    nextFunc        : reEntryFunc
                })
                
                this.launch(statement.func, statement.scope, statement.args || arguments, child)
                
            } else {
                delete this.reEntryFunc
                
                this.leave.apply(this, arguments)
            }
        },
        
        
        runCoreParallel : function () {
            var args        = arguments
            
            var statements  = this.statements
            var length      = statements.length
            var noExFromAnd = this.noExFromAnd
            var me          = this
            
            var exceptions  = []
            var results     = []
            var counter     = 0
            
            var cont        = function () {
                
                if (++counter == length) 
                    if (exceptions.length && !noExFromAnd)
                        me.THROW.apply(me, exceptions)
                    else
                        me.leave.apply(me, results)
                else
                    if (statements.length) {
                        // also increase the `i` in case the actions are actually synchronous
                        // to prevent extra launches from the `for` loop below
                        i++
                        launchStatement(statements.shift(), length - statements.length - 1)
                    }
                        
            }
            
            var launchStatement = function (statement, index) {
                
                TRY(statement.func, statement.scope, statement.args || args).THEN(function () {
                    
                    results[ index ] = arguments
                    
                    // "manually" mark the current continuation "leaved" to prevent it from capturing the exception which propagates
                    this.CONT.leaved = true
                    
                    cont()
                    
                }).CATCH(function (e) {
                    
                    (noExFromAnd ? results : exceptions)[ index ] = e
                    
                    this.CONT.leaved = true
                    
                    cont()
                    
                }).NOW()
            }
            
            for (var i = 0; i < this.maxAndBranches && i < length; i++) launchStatement(statements.shift(), i)
        },
        
        
        
        launch : function (func, scope, args, statement) {
            var glob                = Joose.top
            var prevScopeStatement  = scope.CONT
            var prevGlobStatement   = glob.__GLOBAL_CNT__

            glob.__GLOBAL_CNT__ = scope.CONT = statement
            
            if (Joose.C.debug) {
                
                if (func.apply(scope, args) !== undefined) throw new Error("ERROR: Value returned from continued function (use `CONTINUE(value)` instead)")
                
                scope.CONT              = prevScopeStatement
                glob.__GLOBAL_CNT__     = prevGlobStatement
                
            } else 
                try {
                    if (func.apply(scope, args) !== undefined) throw new Error("ERROR: Value returned from continued function (use `CONTINUE(value)` instead)") 
                } catch (e) {
                    
                    // if statement is already leaved, then we are just propagating the exception from the further statements
                    if (statement.leaved) throw e
                    
                    statement.THROW(e)
                } finally {
                    scope.CONT              = prevScopeStatement
                    glob.__GLOBAL_CNT__     = prevGlobStatement
                }
        },
        

        
        leave : function () {
            var args            = arguments
            
            var finallyFunc     = this.finallyFunc
            
            
            if (finallyFunc) {
                delete this.finallyFunc
                
                var finallyScope     = this.finallyScope
                var me               = this
                
                var finallyStatement = this.deriveChild({
                    defaultScope    : finallyScope,
                    
                    nextFunc        : function () {
                        me.leave.apply(me, args)
                    }
                })
                
                this.launch(finallyFunc, finallyScope, [], finallyStatement)
                
                return
            }
            
            
            if (this.leaved)   throw new Error("Can't re-leave the continuation + [" + this + "]")

            this.leaved         = true
            
            
            var nextFunc        = this.getNextFunc()
            if (nextFunc) nextFunc.apply(Joose.top, args)
        },
        
        
        THROW : function (exception) {
            var args        = arguments

            // remove the `reEntryFunc` (if any) as we aren't supposed to return the sequential flow after THROW 
            delete this.reEntryFunc
            
            var catchFunc   = this.catchFunc
            
            if (catchFunc) {
                delete this.catchFunc
                
                var me              = this
                var catchScope      = this.catchScope
                
                var catchStatement  = this.deriveChild({
                    defaultScope    : catchScope,
                    
                    nextFunc        : function () {
                        me.leave.apply(me, arguments)
                    },
                    keepNextFunc    : true
                })
                
                this.launch(catchFunc, catchScope, args, catchStatement)

                return
            } 
            
            var parent      = this.parent
            
            if (parent) {
                this.nextFunc = function () {
                    parent.THROW.apply(parent, args)
                }
                
                this.leave()
                
            } else {
                
                this.nextFunc = function () {
                    throw exception
                }
                
                this.leave()
            }
        },
        
        
        CONTINUE : function () {
            return this.leave.apply(this, arguments)
        },
        
        
        onReturn : function () {
            delete this.nextFunc
            delete this.reEntryFunc
        },
        
        
        RETURN : function () {
            if (this.parent) this.parent.onReturn()
            
            if (!this.keepNextFunc) delete this.nextFunc
            delete this.reEntryFunc
            
            return this.leave.apply(this, arguments)
        },
        
        
        TRY : function (func, scope, args) {
            if (!func) throw "Invalid parameters for 'TRY' in [" + this + "]"
            
            if (this.leaved) throw new Error("Can't call 'TRY' for [" + this + "] - its already left\n")
            
            if (this.catchFunc || this.finallyFunc) return this.NEXT.apply(this, arguments)
            
            this.statements.push({
                func    : func,
                scope   : scope || this.getScope(),
                args    : args
            })
            
            this.defaultScope = scope || this.defaultScope
                
            return this
        },
        
        
        THEN : function () {
            if (this.type == 'Parallel') return this.NEXT.apply(this, arguments)
            
            return this.TRY.apply(this, arguments)
        },
        
        
        DELAY : function (interval) {
            this.statements.push({
                func    : function () {
                    var args    = arguments
                    var CONT    = this.CONT
                    
                    setTimeout(function () {
                        
                        CONT.CONTINUE.apply(CONT, args)
                        
                    }, interval || 100) 
                },
                scope   : this.getScope()
            })
                
            return this
        },
        
        
        andTHEN : function () {
            return this.THEN.apply(this, arguments).now()
        },
        
        
        CATCH : function (func, scope) {
            if (this.leaved)            throw "Can't call 'CATCH' for [" + this + "] - its already leaved"
            if (!func)                  throw "Invalid parameters for 'CATCH' in [" + this + "]"
            if (this.catchFunc)         throw "Can't redefine 'CATCH' for [" + this + "]"
            
            this.catchFunc      = func
            this.catchScope     = scope || this.getScope()
            
            return this 
        },
        
        
        FINALLY : function (func, scope) {
            if (this.leaved)            throw "Can't call 'FINALLY' for [" + this + "] - its already leaved"
            if (!func)                  throw "Invalid parameters for 'FINALLY' in [" + this + "]"
            if (this.finallyFunc)       throw "Can't redefine 'FINALLY' for [" + this + "]"
            
            this.finallyFunc      = func
            this.finallyScope     = scope || this.getScope()
            
            return this
        },
        
        
        
        NEXT : function (func, scope, args) {
            if (this.leaved)            throw "Can't call 'NEXT' for [" + this + "] - its already leaved"
            
            var next = this.deriveSibling()
            
            this.nextFunc = function () {
                next.entry.apply(next, arguments)
            }
            
            return next.TRY(func, scope, args)
        },
        
        
        AND : function () {
            this.type = 'Parallel'
            
            return this.TRY.apply(this, arguments)
        },
        
        
        ANDMAX : function (num) {
            this.maxAndBranches = num
            
            return this
        },
        
        
        AND_NOEX : function () {
            this.noExFromAnd = true
            
            return this
        },
        
        
        NOW : function () {
            var root = this.getNearestNotEntered()
            
            if (!root)                  throw "Can't launch  [" + this + "]"
            
            root.entry.apply(root, arguments)
        },
        
        
        RUN : function () {
            return this.NOW.apply(this, arguments)
        },
        
        
        getNearestNotEntered : function () {
            if (this.entered) return null
            
            var prev = this.previous || this.parent 
            
            if (prev) {
                var root = prev.getNearestNotEntered()
                
                if (root) return root
            }
            
            return this
        },
        
        
        // Delegates
        getCONTINUE : function () {
            var me = this
            
            return function () {
                me.CONTINUE.apply(me, arguments)
            }
        },
        
        
        getRETURN : function () {
            var me = this
            
            return function () {
                me.RETURN.apply(me, arguments)
            }
        },
        
        
        getTHROW : function () {
            var me = this
            
            return function () {
                me.THROW.apply(me, arguments)
            }
        },
        
        
        // Synonyms
        and : function () {
            return this.AND.apply(this, arguments)
        },
        
        
        andMax : function (num) {
            this.maxAndBranches = num
            
            return this
        },
        
        
        andNoEx : function () {
            this.noExFromAnd = true
            
            return this
        },
        
        
        then : function () {
            return this.THEN.apply(this, arguments)
        },
        
        
        delay : function () {
            return this.DELAY.apply(this, arguments)
        },
        
        
        andThen : function () {
            return this.THEN.apply(this, arguments).now()
        },
        
        
        thenRun : function () {
            return this.THEN.apply(this, arguments).now()
        },
        
        
        next : function () {
            return this.NEXT.apply(this, arguments)
        },
        
        
        now : function () {
            return this.NOW.apply(this, arguments)
        },
        
        
        run : function () {
            return this.NOW.apply(this, arguments)
        },

        
        except : function () {
            return this.CATCH.apply(this, arguments)
        },
        
        
        ensure : function () {
            return this.FINALLY.apply(this, arguments)
        }
        
    }
    //eof methods
})


TRY = function (obj) {
    if (Joose.O.isInstance(obj)) {
        
        obj.__CNT__ = new JooseX.CPS.Continuation()
        
        return obj
    }
    
    var continuation = new JooseX.CPS.Continuation()
    
    return continuation.TRY.apply(continuation, arguments)
}


/**

Name
====


JooseX.CPS.Continuation - A continuation class


SYNOPSIS
========

        TRY = function () {
            var continuation = new JooseX.CPS.Continuation()
            
            return continuation.TRY.apply(continuation, arguments)
        }


DESCRIPTION
===========

`JooseX.CPS.Continuation` implements a continuation - an underlaying basis for `JooseX.CPS` trait.


ISA
===

None.


DOES
====

None.


TRAITS
======

None.


ATTRIBUTES
==========

### parent

> `JooseX.CPS.Continuation parent`

> A parent for this continuation. Can be asked for default scope or for the [nextFunc]


### previous

> `JooseX.CPS.Continuation previous`

> A previous continuation for this continuation. Can be asked for default scope or for the [nextFunc]


### statements

> `Array statements`

> An array of statements. Each statement is an object like : 
    
            {
                func    : ... , // function to execute
                scope   : ... , // scope into which execute the function
                args    : ...   // arguments for function 
            }


### type

> `String type`

> The type of this continuation. Can be 'Sequential' or 'Parallel's


### entered

> `Boolean entered`

> The sign whether this continuation was already entered - i.e. activated.


### leaved

> `Boolean leaved`

> The sign whether this continuation was already leaved - i.e. the `CONTINUE` or `THROW` method were called.


### defaultScope

> `Object defaultScope`

> The default scope which will be supplied to the statements if not provided explicitly. Once passed to `TRY`, propagates to the further statements. 


### nextFunc

> `Function nextFunc`

> If present, this function will be called, when leaving this continuation. Will be called in the global scope, with the arguments from the method, initated the leave. 


### catchFunc/finallyFunc

> `Function catchFunc/finallyFunc`

> The functions for `CATCH/FINALLY` statements accordingly. 


### catchScope/finallyScope

> `Object catchScope/finallyScope`

> The scopes for `CATCH/FINALLY` statements accordingly.



METHODS
=======

### TRY

> `JooseX.CPS.Continuation TRY(Function func, Object scope?, Array args?)`

> Add a statement to the current continuation. If continuation already contains `CATCH` or `FINALLY` statements - then delegate to `NEXT` and return a next continuation instance.
otherwise return current continuation.


### THEN

> `JooseX.CPS.Continuation THEN(Function func, Object scope?, Array args?)`

> Alias for `TRY` with a single exception. If the type of the continuation is `Parallel` then delegate to `NEXT` and return a next continuation instance.

> Has a lower-case synonym : 'then'


### CATCH

> `JooseX.CPS.Continuation CATCH(Function func, Object scope?)`

> Add a `CATCH` statement to the current continuation. 

> Has a lower-case synonym : 'except'


### FINALLY

> `JooseX.CPS.Continuation FINALLY(Function func, Object scope?)`

> Add a `FINALLY` statement to the current continuation. 

> Has a lower-case synonym : 'ensure'


### NEXT

> `JooseX.CPS.Continuation NEXT(Function func, Object scope?, Array args?)`

> Derive a sibling continuation, chaining it after itself. Return newly created continuation.

> Has a lower-case synonym : 'next'


### AND

> `JooseX.CPS.Continuation AND(Function func, Object scope?, Array args?)`

> Alias for `TRY` that also switch a type of the continuation to `Parallel`.

> Has a lower-case synonym : 'and'


### NOW

> `JooseX.CPS.Continuation NOW()`

> Activates current continuation graph by looking the 1st not yet entered continuation. After finding it, delegate to its `entry` method with the passed arguments.

> Has a lower-case synonym : 'now'


### getCONTINUE

> `Function getCONTINUE()`

> Return a function, binded to the `CONTINUE` method of itself.


### getRETURN

> `Function getRETURN()`

> Return a function, binded to the `RETURN` method of itself.


### getTHROW

> `Function getTHROW()`

> Return a function, binded to the `THROW` method of itself.


GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/JooseX-CPS/issues>

For general Joose questions you can also visit the [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) on irc.freenode.org, or the forum at <http://joose.it/forum>



SEE ALSO
========

[Main documentation page](../CPS.html)

General documentation for Joose: <http://joose.github.com/Joose/>



AUTHORS
=======

Nickolay Platonov [nplatonov@cpan.org](mailto:nplatonov@cpan.org)



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
;
Class('JooseX.CPS.MethodModifier.Override', {
    
    meta : Joose.Meta.Class,
    
    isa : Joose.Managed.Property.MethodModifier.Override,
    
    use : 'JooseX.CPS.Continuation',
    
    
    methods : {
    
        prepareWrapper : function (params) {
            
            var overriden = this.SUPER(params)
            
            var continued = function () {
                
                var cont = this.__CNT__
                
                if (cont)
                    delete this.__CNT__
                else
                    cont = Joose.top.__GLOBAL_CNT__ || new JooseX.CPS.Continuation()
                
                return cont.TRY(overriden, this, arguments)
            }
            
            continued.IS_CONTINUED = true
            
            return continued
        }
    }
})
;
Class('JooseX.CPS.MethodModifier.After', {
    
    meta : Joose.Meta.Class,
    
    isa : Joose.Managed.Property.MethodModifier,
    
    use : 'JooseX.CPS.Continuation',
    
    
    methods : {
        
        prepareWrapper : function (params) {
            
            var name            = params.name
            var modifier        = params.modifier
            var isOwn           = params.isOwn
            var original        = params.target.prototype[name]
            var superProto      = params.superProto
            var originalCall    = params.originalCall
            
            
            var continuedOriginal = function () {
                var isContinued     = isOwn ? original.IS_CONTINUED : superProto[name].IS_CONTINUED
                
                if (isContinued) 
                    originalCall.apply(this, arguments).NOW()
                else
                    this.CONTINUE(originalCall.apply(this, arguments))
            }
            
            
            var continued = function () {
                
                var cont = this.__CNT__
                
                if (cont)
                    delete this.__CNT__
                else
                    cont = Joose.top.__GLOBAL_CNT__ || new JooseX.CPS.Continuation()
                
                var args = arguments
                
                return cont.TRY(continuedOriginal, this, arguments).THEN(function () {
                    
                    var res = arguments
                    
                    this.CONT.TRY(modifier, this, args).THEN(function () {
                        
                        this.CONTINUE.apply(this, res)
                    }).NOW()
                    
                }, this)
            }
            
            continued.IS_CONTINUED = true
            
            return continued
        }
    }
});
Class('JooseX.CPS.MethodModifier.Before', {
    
    meta : Joose.Meta.Class,
    
    isa : Joose.Managed.Property.MethodModifier,
    
    use : 'JooseX.CPS.Continuation',
    
    
    methods : {
        
        prepareWrapper : function (params) {
            
            var name            = params.name
            var modifier        = params.modifier
            var isOwn           = params.isOwn
            var original        = params.target.prototype[name]
            var superProto      = params.superProto
            var originalCall    = params.originalCall
            
            
            var then = function () {
                var isContinued     = isOwn ? original.IS_CONTINUED : superProto[name].IS_CONTINUED
                
                if (isContinued) 
                    originalCall.apply(this, arguments).NOW()
                else
                    this.CONTINUE(originalCall.apply(this, arguments))
            }
            
            
            var continued = function () {
                
                var cont = this.__CNT__
                
                if (cont)
                    delete this.__CNT__
                else
                    cont = Joose.top.__GLOBAL_CNT__ || new JooseX.CPS.Continuation()
                
                return cont.TRY(function () {
                    
                    this.CONT.TRY(modifier, this, arguments).NOW()
                    
                }, this, arguments).THEN(then, this, arguments)
            }
            
            continued.IS_CONTINUED = true
            
            return continued
        }
    }
});
Class('JooseX.CPS.MethodModifier.Put', {
    
    isa : 'JooseX.CPS.MethodModifier.Override',
    
    
    methods : {
        
        prepareWrapper : function (params) {
            
            if (params.isOwn) throw "Method [" + params.name + "] is applying over something [" + params.originalCall + "] in class [" + params.target + "]"
            
            return this.SUPER(params)
        }
    }
});
Class('JooseX.CPS.Builder', {
    
    meta : Joose.Meta.Class,
    
    use : [
        'JooseX.CPS.MethodModifier.Put',
        'JooseX.CPS.MethodModifier.After',
        'JooseX.CPS.MethodModifier.Before',
        'JooseX.CPS.MethodModifier.Override'
    ],
    
    isa : Joose.Managed.Builder,
    
    
    methods : {
        
        methods : function (meta, info) {
            var methods = meta.stem.properties.methods
            
            Joose.O.eachOwn(info, function (value, name) {
                methods.addProperty(name, {
                    meta : JooseX.CPS.MethodModifier.Put,
                    init : value
                })
            })
        },
        
    
        after : function (meta, info) {
            Joose.O.each(info, function (value, name) {
                
                meta.addMethodModifier(name, value, JooseX.CPS.MethodModifier.After)
            })
        },
        
        
        before : function (meta, info) {
            Joose.O.each(info, function (value, name) {
                
                meta.addMethodModifier(name, value, JooseX.CPS.MethodModifier.Before)
            })
        },
        
        
        override : function (meta, info) {
            Joose.O.each(info, function (value, name) {
                
                meta.addMethodModifier(name, value, JooseX.CPS.MethodModifier.Override)
            })
        }
    }
})

;
Role('JooseX.CPS.ControlFlow', {
    
    use : [ 'JooseX.CPS.Continuation' ],
    
    methods : {
        
        __getCONT__ : function () {
            var CNT = this.__CNT__
            
            if (CNT) {
                delete this.__CNT__
                
                return CNT
            }
            
            return this.CONT
        },
        
        
        TRY : function (func, scope, args) {
            return this.__getCONT__().TRY(func, scope || this, args)
        },
        
        
        AND : function (func, scope, args) {
            return this.__getCONT__().AND(func, scope || this, args)
        },
        
        
        ANDMAX : function (num) {
            return this.__getCONT__().ANDMAX(num)
        },
        
        
        AND_NOEX : function () {
            return this.__getCONT__().AND_NOEX()
        },
        
        
        THEN : function (func, scope, args) {
            return this.__getCONT__().THEN(func, scope || this, args)
        },
        
        
        andTHEN : function (func, scope, args) {
            return this.__getCONT__().andTHEN(func, scope || this, args)
        },

        
        thenRUN : function (func, scope, args) {
            return this.__getCONT__().andTHEN(func, scope || this, args)
        },
        
        
        NEXT : function (func, scope, args) {
            return this.__getCONT__().NEXT(func, scope || this, args)
        },
        
        
        NOW : function () {
            var cont = this.CONT
            
            return cont.NOW.apply(cont, arguments)
        },
        
        
        RUN : function () {
            var cont = this.CONT
            
            return cont.NOW.apply(cont, arguments)
        },
        
        
        CONTINUE : function () {
            var cont = this.CONT
            
            cont.CONTINUE.apply(cont, arguments)
        },
        
        
        RETURN : function () {
            var cont = this.CONT
            
            cont.RETURN.apply(cont, arguments)
        },
        
        
        THROW : function () {
            var cont = this.CONT
            
            cont.THROW.apply(cont, arguments)
        },
        
        
        getCONTINUE : function () {
            return this.CONT.getCONTINUE()
        },
        
        
        getRETURN : function () {
            return this.CONT.getRETURN()
        },
        
        
        getTHROW : function () {
            return this.CONT.getTHROW()
        }
        
    }
    //eof methods

});
Role('JooseX.CPS', {
    
    /*PKGVERSION*/VERSION : 0.18,
    
    use : [ 'JooseX.CPS.Builder', 'JooseX.CPS.ControlFlow' ], 

    
    has : {
        continuedBuilder : null
    },
    
    
    after : {
        
        processStem : function () {
            if (!this.continuedBuilder) {
            
                this.continuedBuilder = new JooseX.CPS.Builder({ targetMeta : this })
                
                this.addRole(JooseX.CPS.ControlFlow)
            }
        }
    },
    
    
    builder : {
        
        methods : {
            
            continued : function (meta, info) {
                meta.continuedBuilder._extend(info)
            },
            
            async : function (meta, info) {
                meta.continuedBuilder._extend(info)
            }
        }
    }
});
;
;
!function () {
    
    var REF      = 1    

    Class('Data.Visitor2', {
        
        has : {
            seenPlaceholder : {
                init        : {}
            },
            
            outOfDepthPlaceholder : {
                init        : {}
            },
            
            seen            : Joose.I.Object,
            
            maxDepth        : null
        },
            
        methods : {
            
            getClassNameFor : function (object) {
                if (Joose.O.isInstance(object))      return object.meta.name
                
                return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
            },
            
            
            getRefAdr : function () {
                return REF++
            },
            
            
            assignRefAdrTo : function (object) {
                if (!object.__REFADR__) 
                    if (Object.defineProperty)
                        Object.defineProperty(object, '__REFADR__', { value : REF++ })
                    else
                        object.__REFADR__ = REF++
                
                return object.__REFADR__
            },
                
                
            isSeen : function (object) {
                return object.__REFADR__ && this.seen.hasOwnProperty(object.__REFADR__)
            },
            
            
            markSeenAs : function (object, result) {
                return this.seen[ object.__REFADR__ ] = result
            },
            
            
            hasSeenResultFor : function (object) {
                var ref = object.__REFADR__
                
                return this.seen.hasOwnProperty(ref) && this.seen[ ref ] != this.seenPlaceholder
            },
            
            
            visit : function (value, depth) {
                // will be false for NaN values
                if (depth > this.maxDepth)
                    return this.visitOutOfDepthValue(value, depth + 1)
                else
                    if (Object(value) === value)
                        if (this.isSeen(value)) 
                            return this.visitSeen(value, depth + 1)
                        else                        
                            return this.visitNotSeen(value, depth + 1)
                    else
                        return this.visitValue(value, depth + 1)
            },
            
            
            visitOutOfDepthValue : function (value, depth) {
                return this.outOfDepthPlaceholder
            },
            
            
            visitValue : function (value, depth) {
                return value
            },
            
            
            visitSeen : function (value, depth) {
                return this.seen[ value.__REFADR__ ]
            },
            
            
            getInitialSeenMarker : function (object, depth) {
                return this.seenPlaceholder
            },
            
            
            visitNotSeen : function (object, depth) {
                this.assignRefAdrTo(object)
                
                this.markSeenAs(object, this.getInitialSeenMarker(object, depth))
    
                
                if (Joose.O.isInstance(object)) return this.markSeenAs(object, this.visitJooseInstance(object, depth))
                
                
                var methodName = 'visit' + this.getClassNameFor(object)
                
                if (!this.meta.hasMethod(methodName)) methodName = 'visitObject' 
                
                return this.markSeenAs(object, this[ methodName ](object, depth))
            },
            
            
            visitArray  : function (array, depth) {
                Joose.A.each(array, function (value, index) {
                    
                    this.visitArrayEntry(value, index, array, depth)
                    
                }, this)
                
                return array
            },
            
            
            visitArrayEntry  : function (entry, index, array, depth) {
                return this.visit(entry, depth)
            },
            
            
            visitObject : function (object, depth) {
                
                Joose.O.eachOwn(object, function (value, key) {
                    
                    if (key != '__REFADR__') {
                        this.visitObjectKey(key, value, object, depth)
                        this.visitObjectValue(value, key, object, depth)
                    }
                    
                }, this)
                
                return object
            },
            
            
            visitJooseInstance : function (value, depth) {
                return this.visitObject(value, depth)
            },
            
            
            visitObjectKey : function (key, value, object, depth) {
                return this.visitValue(key, depth)
            },
            
            
            visitObjectValue : function (value, key, object, depth) {
                return this.visit(value, depth)
            }
        },
        
        
        my : {
            
            has : {
                HOST        : null
            },
            
            
            methods : {
                
                visit : function (value, maxDepth) {
                    var visitor     = new this.HOST({
                        maxDepth        : maxDepth || Infinity
                    })
                    
                    return visitor.visit(value, 0)
                }
            }
        }
    })    
    
}()


;
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Util.XMLNode', {
    
    has     : {
        children        : Joose.I.Array,
        
        tag             : { required : true },
        attributes      : Joose.I.Object,
        
        textContent     : null,
        
        escapeTable     : {
            
            init    : {
                '&'     : '&amp;', 
                '<'     : '&lt;', 
                '>'     : '&gt;', 
                '"'     : '&quot;'
            }
        }
        
    },
    
    
    methods : {
        
        escapeXml : function (s) {
            var me = this
            
            return typeof s != 'string' ? s : s.replace(/[&<>"]/g, function (match) {
                return me.escapeTable[ match ]
            })
        },
        
        
        toString : function () {
            var me                  = this
            var childrenContent     = []
            
            Joose.A.each(this.children, function (child) {
                childrenContent.push(child.toString())
            })
            
            var attributesContent       = []
            
            Joose.O.each(this.attributes, function (value, name) {
                attributesContent.push(name + '="' + me.escapeXml(value) + '"')
            })
            
            // to have predictable order of attributes in tests
            attributesContent.sort()
            
            attributesContent.unshift(this.tag)
            
            
            return '<' + attributesContent.join(' ') + '>' + (this.textContent != null ? this.escapeXml(this.textContent) : '') + childrenContent.join('') + '</' + this.tag + '>' 
        },
        
        
        appendChild : function (child) {
            if (child instanceof Siesta.Util.XMLNode)
                child.parent    = this
            else
                child           = new Siesta.Util.XMLNode(Joose.O.extend(child, { parent : this }))
                
            this.children.push(child)
            
            return child
        },
        
        
        setAttribute : function (name, value) {
            this.attributes[ name ] = value
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Util.Serializer', {

    isa : Data.Visitor2,

    has     : {
        result                  : Joose.I.Array,
        manualEnum              : function () {
            for (var i in { toString : 1 }) return false

            return true
        }
    },


    methods : {

        assignRefAdrTo : function (object) {
            try {
                return this.SUPER(object)
            } catch (e) {
                if (!object.__REFADR__) object.__REFADR__ = this.getRefAdr()
            }

            return object.__REFADR__
        },


        write : function (str) {
            this.result.push(str)
        },


        visitOutOfDepthValue : function (value, depth) {
            this.write('...')
        },


        visitSymbol: function (value) {
            this.write(value.toString())
        },


        visitValue : function (value) {
            if (value == null)
                // `null` and `undefined`
                this.write(value + '')
            else {
                if (typeof value === 'symbol')
                    this.write(value.toString())
                else
                    this.write(typeof value == 'string' ? '"' + value.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"' : value + '')
            }
        },


        visitObjectKey : function (key, value, object) {
            this.write('"' + key + '": ')
        },


        getClassNameFor : function (object) {
            if (object.nodeType != null && object.nodeName != null && object.tagName) return 'DOMElement'

            // trying to detect and not dive into global window
            if (object.document != null && object.location != null && object.location.href != null) return 'Window'

            return this.SUPER(object)
        },


        visitSeen : function (value, depth) {
            this.write('[Circular]')
        },


        visitRegExp : function (value, depth) {
            this.write(value + '')
        },


        visitFunction : function (value, depth) {
            this.write('function ' + (value.name || '') + '() { ... }')
        },


        visitDate : function (value, depth) {
            this.write('"' + value + '"')
        },


        // safer alternative to parent's implementation of `visitObject` - some host objects has no "hasOwnProperty" method
        visitObject : function (object, depth) {
            for (var key in object) {
                if (key != '__REFADR__' && (!object.hasOwnProperty || object.hasOwnProperty(key))) {
                    var value   = object[ key ]

                    this.visitObjectKey(key, value, object, depth)
                    this.visitObjectValue(value, key, object, depth)
                }
            }

            var me  = this

            if (this.manualEnum)
                Joose.A.each([ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ], function (key) {
                    if (object.hasOwnProperty && object.hasOwnProperty(key)) {
                        var value   = object[ key ]

                        me.visitObjectKey(key, value, object, depth)
                        me.visitObjectValue(value, key, object, depth)
                    }
                })

            return object
        },


        visitJooseInstance : function (value, depth) {
            if (value.meta.hasMethod('toString')) {
                this.write(value.toString())

                return value
            }

            return this.SUPERARG(arguments)
        },


        visitDOMElement : function (object, depth) {
            var output  = '&lt;' + object.tagName

            if (object.id) output += ' id="' + object.id + '"'
            if (object.className) output += ' class="' + object.className + '"'

            this.write(output + '&gt;')
        },


        visitDOMStringMap : function () {
            this.write('[DOMStringMap]')
        },


        // the Object.prototype.toString.call(window) for FF
        visitWindow : function () {
            this.write('[window]')
        },


        // window.location type in FF
        visitLocation : function () {
            this.write('[window.location]')
        },


        visitMap : function (map) {
            this.write('Map(' + map.size + '){')

            // we use iterator here instead of simple "for .. of" loop, because IE does not support it
            var iterator        = map.entries()

            for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                this.visit(entry.value[ 0 ])
                this.write('=>')
                this.visit(entry.value[ 1 ])
                this.write(', ')
            }

            if (map.size > 0) this.result.pop()

            this.write('}')
        }
    },


    before : {
        visitObject : function () {
            this.write('{')
        },


        visitArray : function () {
            this.write('[')
        }
    },


    after : {
        visitObject : function () {
            var result = this.result

            if (result[ result.length - 1 ] == ', ') result.pop()

            this.write('}')
        },


        visitArray : function () {
            var result = this.result

            if (result[ result.length - 1 ] == ', ') result.pop()

            this.write(']')
        },


        visitObjectValue : function () {
            this.write(', ')
        },


        visitArrayEntry : function () {
            this.write(', ')
        }
    },


    my : {

        has : {
            HOST        : null
        },


        methods : {

            stringify : function (value, maxDepth) {
                try {
                    if (value != null && value.foobar) visitor = null
                } catch (e) {
                    if (value) return 'Value from cross-domain context'
                }

                var visitor     = new this.HOST({
                    maxDepth        : maxDepth || 4
                })

                visitor.visit(value, 0)

                return visitor.result.join('')
            }
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Util.Role.CanFormatStrings', {

    has     : {
        serializeFormatingPlaceholders      : true
    },

    methods : {

        formatString: function (string, data) {
            if (!data) return string

            var match
            var variables           = []
            var isRaw               = []
            var regexp              = /\{(\!)?((?:\w|-|_)+?)\}/g

            while (match = regexp.exec(string)) {
                isRaw.push(match[ 1 ])
                variables.push(match[ 2 ])
            }

            var result              = string

            Joose.A.each(variables, function (variable, index) {
                var varIsRaw        = isRaw[ index ]

                result              = result.replace(
                    new RegExp('\\{' + (varIsRaw ? '!' : '') + variable + '\\}', 'g'),
                    data.hasOwnProperty(variable) ?
                        varIsRaw || !this.serializeFormatingPlaceholders ? data[ variable ] + '' : Siesta.Util.Serializer.stringify(data[ variable ])
                    :
                        ''
                )
            }, this)

            return result
        },


        // Extract normal chars, or special keys in brackets such as [TAB], [RIGHT] or [ENTER]
        extractKeysAndSpecialKeys : function (string) {
            var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys
            var me              = this

            var res             = []
            // either: [[SPECIAL]] (meaning plain text), [SPECIAL] (meaning special char), or any character
            var tokens          = string.match(/(\[\[(?:\w|-){1,11}\]\])|(\[(?:\w|-){1,11}\])|([\s\S])/g) || [];

            Joose.A.each(tokens, function (token, index) {
                if (token.length > 1) {
                    var isDouble        = /\[\[/.test(token)

                    var specialKey      = token.substring(isDouble ? 2 : 1, token.length - (isDouble ? 2 : 1))
                    var normalText      = KeyCodes[ specialKey.toUpperCase() ] === undefined

                    if (normalText || isDouble) {
                        res.push('[')
                        if (normalText && isDouble) res.push('[')
                        res.push.apply(res, me.extractKeysAndSpecialKeys(specialKey))
                        res.push(']')
                        if (normalText && isDouble) res.push(']')
                    } else {
                        res.push(token)
                    }
                } else
                    res.push(token)
            })

            return res
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Util.Role.CanGetType', {
    
    methods : {
        
        /**
         * This method returns a result of `Object.prototype.toString` applied to the passed argument. The `[object` and trailing `]` are trimmed.
         *
         * @param {Mixed} object
         * @return {String} The name of the "type" for this object.
         */
        typeOf : function (object) {
            return Object.prototype.toString.call(object).slice(8, -1)
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Util.Role.CanParseOs', {

    methods : {

        parseOS : function (platform) {
            if (/Win/i.test(platform)) return "Windows"

            if (/Mac/.test(platform) || /darwin/i.test(platform)) return "MacOS"

            if (/Linux/i.test(platform)) return "Linux"

            return "unknown"
        }
    }
});
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Util.Role.CanParseBrowser', {

    methods : {

        parseBrowser : function (uaString) {
            var browser = 'unknown'
            var version = ''

            var match

            if (match = /Firefox\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Firefox"
                version     = match[ 1 ]
            }

            if (match = /Chrome\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Chrome"
                version     = match[ 1 ]
            }

            if (match = /MSIE\s*((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "IE"
                version     = match[ 1 ]
            }

            if (uaString.match(/trident/i) && (match = /rv.(\d\d\.?\d?)/.exec(uaString))) {
                browser     = "IE"
                version     = match[ 1 ]
            }

            if (match = /chrome.+? edge\/(\d+(\.\d+)?)/i.exec(uaString)) {
                browser     = "Edge"
                version     = match[ 1 ]
            }

            if (match = /Apple.*Version\/((?:\d+\.?)+)\s*(?=Safari\/((?:\d+\.?)+))/.exec(uaString)) {
                browser     = "Safari"
                version     = match[ 1 ] + ' (' + match[ 2 ] + ')'
            }

            if (match = /PhantomJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "PhantomJS"
                version     = match[ 1 ]
            }

            if (match = /SlimerJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "SlimerJS"
                version     = match[ 1 ]
            }

            if (match = /NodeJS\/(.+)/.exec(uaString)) {
                browser     = "NodeJS"
                version     = match[ 1 ]
            }

            return {
                name        : browser,
                version     : version
            }
        }
    }
});
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {
/* header */
    
var id      = 1

Role('Siesta.Util.Role.HasUniqueGeneratedId', {
    
    has : {
        id                      : {
            is      : 'ro',
            init    : function () { return id++ }
        }
    }
})

/* footer */
}();
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
;(function () {
    
var ID = 0

Class('Siesta.Result', {
    
    has : {
        description     : null,
        
        children        : Joose.I.Array,
        
        length          : 0,
        
        id              : function () {
            return ++ID
        },
        
        parent          : null
    },
    
    
    methods : {
        
        itemAt : function (i) {
            return this.children[ i ]
        },
        
        
        push        : function (result) {
            this.children.push(result)
            
            result.parent   = this
            
            this.length     = this.children.length
        },
        
        
        each : function (func, scope) {
            var children        = this.children
            
            if (func.call(scope || this, this) === false) return false
            
            for (var i = 0; i < children.length; i++)
                if (children[ i ].each(func, scope) === false) return false
        },
        
        
        eachChild : function (func, scope) {
            var children        = this.children
            
            for (var i = 0; i < children.length; i++)
                if (func.call(scope, children[ i ]) === false) return false
        },
        
        
        toString : function () {
            return this.description
        },
        
        
        toJSON : function () {
            return {
                type        : this.meta.name,
                description : this.description
            }
        },
        
        
        findChildById : function (id) {
            var child
            
            this.each(function (node) {
                if (node.id == id) { child = node; return false } 
            })
            
            return child
        }
    },
    
    // used for self-testing when we need different ids for outer context and context being tested
    my : {
        methods     : {
            seedID : function (value) {
                ID          = value
            }
        }
    }
        
})


})();
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Result.Diagnostic', {
    
    isa : Siesta.Result,
    
    has : {
        isWarning           : false
    },

    methods : {
        
        toString : function () {
            return '# ' + this.description
        },
        
        
        toJSON : function () {
            var info        = {
                parentId        : this.parent.id,
                
                type            : this.meta.name,
                description     : this.description
            }
            
            if (this.isWarning) info.isWarning = true
            
            return info
        }
    }    
});

;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Result.Assertion', {
    
    isa : Siesta.Result,

    has : {
        name            : null,
        
        passed          : null,
        
        annotation      : null,
        
        index           : null,
        // stored as string
        sourceLine      : null,
        
        isTodo          : false,
        
        isException     : false,
        exceptionType   : null,

        isWaitFor       : false,
        completed       : false      // for waitFor assertions
    },
    
    
    methods : {

        isPassed : function (raw) {
            if (raw) return this.passed
            
            if (this.isTodo) return true
            
            if (this.isWaitFor && !this.completed) return true
            
            return this.passed
        },
        
        
        toString : function () {
            var R       = Siesta.Resource('Siesta.Result.Assertion');
            
            var text    = (this.isTodo ? R.get('todoText') : '') + 
                (this.passed ? R.get('passText') : R.get('failText')) + ' ' + this.index + ' - ' + this.description
            
            if (this.annotation) text += '\n' + this.annotation
            
            return text
        },
        
        
        toJSON : function () {
            var me      = this
            
            var info    = {
                parentId        : this.parent.id,
                
                type            : this.meta.name,
                passed          : this.passed,
                index           : this.index,
                description     : String(this.description) || 'No description'
            }
            
            if (this.annotation) info.annotation = String(this.annotation)
            
            // copy if true
            Joose.A.each([ 'isTodo', 'isWaitFor', 'isException', 'sourceLine', 'name' ], function (name) {
                if (me[ name ]) info[ name ] = me[ name ]
            })
            
            if (this.isException)   {
                info.exceptionType  = this.exceptionType
            }
            
            return info
        }
    }
})

;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Siesta.CurrentLocale = Siesta.CurrentLocale || {

    "Siesta.Project" : {
        preloadHasFailed            : 'Preload of {url} has failed',
        preloadHasFailedForTest     : 'Preload of {url} has failed for test {test}',
        staticDeprecationWarning    : 'You are calling static method `{methodName}` of the project class {projectClass}. Such usage is deprecated now, please switch to creation of the project class instance: `var project = new {projectClass}()`',
        resourceFailedToLoad        : 'Loading of a {nodeName} resource failed',
        crossOriginFailed           : 'Failed to access cross-origin page: {url}. \nIn general tests should reside on the same domain as the app itself,\nbut you can try to disable web security:\nhttps://www.bryntum.com/blog/testing-x-domain-websites-with-siesta-in-chrome/'
    },

    "Siesta.Project.Browser.UI.AboutWindow" : {

        upgradeText : 'Upgrade to Siesta Standard',
        closeText   : 'Close',
        titleText   : 'ABOUT SIESTA (v{VERSION})',

        bodyText    : '<img height="35" src="https://www.bryntum.com/bryntum-logo.png"/>' +
             '<p>Siesta is a JavaScript unit and functional test tool made by <a target="_blank" href="https://www.bryntum.com">Bryntum</a>. You can test any web page or JavaScript code, including Ext JS, jQuery or NodeJS. ' +
             'Siesta comes in two versions: <strong>Lite</strong> and <strong>Standard</strong>. With Lite, you can launch your tests in the browser UI. ' +
             'With the Standard version, you can also automate your tests and use the automation scripts together with tools like Puppeteer or Selenium WebDriver. </p>' +
             'Siesta would not be possible without these awesome products & libraries: <br>' +
                     '<ul style="padding:0 0 0 30px">' +
                       '<li><a href="http://sencha.com/extjs">Ext JS</a></li>' +
                       '<li><a href="http://jquery.com">jQuery</a></li>' +
                       '<li><a href="http://http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></li>' +
                       '<li><a href="http://joose.it/">Joose</a></li>' +
                       '<li><a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li>' +
                    '</ul>'
    },

    "Siesta.Project.Browser.UI.AssertionGrid" : {
        initializingText    : 'Initializing test...'
    },

    "Siesta.Project.Browser.UI.CoverageReport" : {
        closeText               : 'Close',
        showText                : 'Show: ',
        lowText                 : 'Low',
        mediumText              : 'Med',
        highText                : 'High',
        statementsText          : 'Statements',
        branchesText            : 'Branches',
        functionsText           : 'Functions',
        linesText               : 'Lines',
        loadingText             : "Loading coverage data...",
        loadingErrorText        : 'Loading error',
        loadingErrorMessageText : 'Could not load the report data from this url: ',
        globalNamespaceText     : '[Global namespace]'
    },

    "Siesta.Project.Browser.UI.DomContainer" : {
        title                   : 'DOM Panel',
        viewDocsText            : 'View documentation for ',
        docsUrlText             : 'http://docs.sencha.com/{0}/apidocs/#!/api/{1}'
    },

    "Siesta.Project.Browser.UI.ResultPanel" : {
        rerunText               : 'Run test',
        toggleDomVisibleText    : 'Toggle DOM visible',
        viewSourceText          : 'View source',
        showFailedOnlyText      : 'Show failed only',
        componentInspectorText  : 'Toggle Ext Component Inspector',
        eventRecorderText       : 'Event Recorder',
        closeText               : 'Close'
    },

    "Siesta.Project.Browser.UI.TestGrid" : {
        mouseSimulation         : 'Mouse simulation',
        title                   : 'Test list',
        nameText                : 'Name',
        filterTestsText         : 'Filter tests',
        expandCollapseAllText   : 'Expand / Collapse all',
        runCheckedText          : 'Run checked',
        runFailedText           : 'Run failed',
        runAllText              : 'Run all',
        observerModeText        : 'Observer mode',
        observerModeTooltip     : 'Sets the `forceDOMVisible` and `runCore=sequential` globally',
        passText                : 'Pass',
        failText                : 'Fail',
        optionsText             : 'Options...',
        todoPassedText          : 'todo assertion(s) passed',
        todoFailedText          : 'todo assertion(s) failed',
        viewDomText             : 'View DOM',
        transparentExText       : 'Transparent exceptions',
        transparentExTooltip    : 'Disable internal try/catch for any exceptions from tests. Useful for debugging.',
        cachePreloadsText       : 'Cache preloads',
        autoLaunchText          : 'Auto launch',
        autoLaunchTooltip       : 'Launch the test suite immediately after project page load.',
        speedRunText            : 'Fast (still accurate)',
        speedRunTooltip         : 'Reduce mouse cursor visualization quality to run tests faster',
        turboMode           : 'Very fast, but inaccurate',
        turboModeTooltip    : 'Sets the `mouseMovePrecision` option to `Infinity`. Read the docs before using.',
        breakOnFailText         : 'Break on fail',
        breakOnFailTooltip      : 'Stop the test suite on first failed assertion',
        debuggerOnFailText      : 'Debugger on fail',
        debuggerOnFailTooltip   : 'Issue a `debugger` statement on any failed assertion. Useful for debugging',
        aboutText               : 'About Siesta',
        documentationText       : 'Siesta Documentation',
        siestaDocsUrl           : 'https://bryntum.com/docs/siesta',
        filterFieldTooltip      : [
            'Supported patterns for tests filtering:\n',
            'WORD - any word, will match with the test file name (no directory part)\n',
            'WORD | WORD - any of the alternative patterns\n',
            'GROUP > TEST - first match GROUP with the group name, then TEST with tests inside that group\n',
            'GROUP1 | GROUP2 > TEST1 | TEST2 - alternation support for groups too\n'
        ].join(''),
        landscape               : 'Landscape'
    },

    "Siesta.Project.Browser.UI.VersionUpdateButton" : {

        newUpdateText           : 'New Update Available...',
        updateWindowTitleText   : 'New version available for download! Current version: ',
        cancelText              : 'Cancel',
        changelogLoadFailedText : 'Bummer! Failed to fetch changelog.',
        downloadText            : 'Download ',
        liteText                : ' (Lite)',
        standardText            : ' (Standard)',
        loadingChangelogText    : 'Loading changelog...'
    },

    "Siesta.Project.Browser.UI.Viewport" : {
        apiLinkText       : 'API Documentation',
        apiLinkUrl        : 'https://bryntum.com/docs/siesta',
        uncheckOthersText : 'Uncheck others (and check this)',
        uncheckAllText    : 'Uncheck all',
        checkAllText      : 'Check all',
        runThisText       : 'Run this',
        expandAll           : 'Expand all',
        collapseAll         : 'Collapse all',
        filterToCurrentGroup    : 'Filter to current group',
        filterToFailed          : 'Filter to failed',
        httpWarningTitle  : 'You must use a web server',
        httpWarningDesc   : 'You must run Siesta in a web server context, and not using the file:/// protocol',
        viewSource        : 'View source'
    },


    "Siesta.Project.Browser" : {
        codeCoverageWarningText : "Can not enable code coverage - did you forget to include the `siesta-coverage-all.js` on the project page?",
        noJasmine               : "No `jasmine` object found on spec runner page",
        noJasmineSiestaReporter : "Can't find SiestaReporter in Jasmine. \nDid you add the `siesta/bin/jasmine-siesta-reporter.js` file to your spec runner page?"
    },

    "Siesta.Result.Assertion" : {
        todoText        : 'TODO: ',
        passText        : 'ok',
        failText        : 'fail'
    },

    "Siesta.Role.ConsoleReporter" : {
        passText            : 'PASS',
        failText            : 'FAIL',
        warnText            : 'WARN',
        errorText           : 'ERROR',
        missingFileText     : 'Test file [{URL}] not found.',
        allTestsPassedText  : 'All tests passed',
        failuresFoundText   : 'There are failures'
    },

    "Siesta.Test.Action.Drag" : {
        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    "Siesta.Test.Action.Eval" : {
        invalidMethodNameText : "Invalid method name: ",
        wrongFormatText       : "Wrong format of the action string: ",
        parseErrorText        : "Can't parse arguments: "
    },

    "Siesta.Test.Action.Wait" : {
        missingMethodText     : 'Could not find a waitFor method named '
    },

    "Siesta.Test.BDD.Expectation" : {
        expectText                  : 'Expect',
        needNotText                 : 'Need not',
        needText                    : 'Need',
        needMatchingText            : 'Need matching',
        needNotMatchingText         : 'Need not matching',
        needStringNotContainingText : 'Need string not containing',
        needStringContainingText    : 'Need string containing',
        needArrayNotContainingText  : 'Need array not containing',
        needArrayContainingText     : 'Need array containing',
        needGreaterEqualThanText    : 'Need value greater or equal than',
        needGreaterThanText         : 'Need value greater than',
        needLessThanText            : 'Need value less than',
        needLessEqualThanText       : 'Need value less or equal than',
        needValueNotCloseToText     : 'Need value not close to',
        needValueCloseToText        : 'Need value close to',
        toBeText                    : 'to be',
        toBeDefinedText             : 'to be defined',
        toBeUndefinedText           : 'to be undefined',
        toBeEqualToText             : 'to be equal to',
        toBeTruthyText              : 'to be truthy',
        toBeFalsyText               : 'to be falsy',
        toMatchText                 : 'to match',
        toContainText               : 'to contain',
        toBeLessThanText            : 'to be less than',
        toBeGreaterThanText         : 'to be greater than',
        toBeCloseToText             : 'to be close to',
        toThrowText                 : 'to throw exception',
        thresholdIsText             : 'Threshold is ',
        exactMatchText              : 'Exact match text',
        thrownExceptionText         : 'Thrown exception',
        noExceptionThrownText       : 'No exception thrown',
        wrongSpy                    : 'Incorrect spy instance',
        toHaveBeenCalledDescTpl     : 'Expect method {methodName} to have been called {!need} times',
        actualNbrOfCalls            : 'Actual number of calls',
        expectedNbrOfCalls          : 'Expected number of calls',
        toHaveBeenCalledWithDescTpl : 'Expect method {methodName} to have been called at least once with the specified arguments'
    },

    "Siesta.Test.ExtJS.Ajax"        : {
        ajaxIsLoading               : 'An Ajax call is currently loading',
        allAjaxRequestsToComplete   : 'all ajax requests to complete',
        ajaxRequest                 : 'ajax request',
        toComplete                  : 'to complete'
    },

    "Siesta.Test.ExtJS.Component"   : {
        badInputText                : 'Expected an Ext.Component, got',
        toBeVisible                 : 'to be visible',
        toNotBeVisible              : 'to not be visible',
        component                   : 'component',
        Component                   : 'Component',
        componentQuery              : 'componentQuery',
        compositeQuery              : 'composite query',
        toReturnEmptyArray          : 'to return an empty array',
        toReturnEmpty               : 'to return empty',
        toReturnAVisibleComponent   : 'to return a visible component',
        toReturnHiddenCmp           : 'to return a hidden/missing component',
        invalidDestroysOkInput      : 'No components provided, or component query returned empty result',
        exception                   : 'Exception',
        exceptionAnnotation         : 'Exception thrown while calling "destroy" method of',
        destroyFailed               : 'was not destroyed (probably destroy was canceled in the `beforedestroy` listener)',
        destroyPassed               : 'All passed components were destroyed ok'
    },

    "Siesta.Test.ExtJS.DataView"    : {
        view                        : 'view',
        toRender                    : 'to render'
    },

    "Siesta.Test.ExtJS.Element"     : {
        top                         : 'top',
        left                        : 'left',
        bottom                      : 'bottom',
        right                       : 'right'
    },

    "Siesta.Test.ExtJS.Grid"     : {
        waitForRowsVisible          : 'rows to show for panel with id',
        waitForCellEmpty            : 'cell to be empty'
    },

    "Siesta.Test.ExtJS.Observable" : {
        hasListenerInvalid           : '1st argument for `t.hasListener` should be an observable instance',
        hasListenerPass              : 'Observable has listener for {eventName}',
        hasListenerFail              : 'Provided observable has no listeners for event',

        isFiredWithSignatureNotFired : 'event was not fired during the test',
        observableFired              : 'Observable fired',
        correctSignature             : 'with correct signature',
        incorrectSignature           : 'with incorrect signature'
    },

    "Siesta.Test.ExtJS.Store"        : {
        storesToLoad                 : 'stores to load',
        failedToLoadStore            : 'Failed to load the store',
        URL                          : 'URL'
    },

    "Siesta.Test.Action"             : {
        missingTestAction            : 'Action [{0}] requires `{1}` method in your test class'
    },

    "Siesta.Test.BDD"                : {
        codeBodyMissing              : 'Code body is not provided for',
        codeBodyOf                   : 'Code body of',
        missingFirstArg              : 'does not declare a test instance as 1st argument',
        iitFound                     : 't.iit should only be used during debugging',
        noObject                     : 'No object to spy on'
    },

    "Siesta.Test.BDD.Spy"                : {
        spyingNotOnFunction          : 'Trying to create a spy over a non-function property'
    },

    "Siesta.Test.Browser"            : {
        popupsDisabled                  : 'Failed to open the popup for url: {url}. Enable the popups in the browser settings.',
        noDomElementFound            : 'No DOM element found for CSS selector',
        noActionTargetFound          : 'No action target found for',
        waitForEvent                 : 'observable to fire its',
        event                        : 'event',
        wrongFormat                  : 'Wrong format for expected number of events',
        unrecognizedSignature        : 'Unrecognized signature for `firesOk`',
        observableFired              : 'Observable fired',
        observableFiredOk            : 'Observable fired expected number of',
        actualNbrEvents              : 'Actual number of events',
        expectedNbrEvents            : 'Expected number of events',
        events                       : 'events',
        noElementFound               : 'Could not find any element at',
        targetElementOfAction        : 'Target element of action',
        targetElementOfSomeAction    : 'Target element of some action',
        isNotVisible                 : 'is not visible or not reachable',
        text                         : 'text',
        toBePresent                  : 'to be present',
        toNotBePresent               : 'to not be present',
        target                       : 'target',
        toAppear                     : 'to appear',
        targetMoved                  : 'Moving target detected, retargeting initiated',
        alertMethodNotCalled         : 'Expected a call to alert()',
        focusLostWarning             : 'Focus has left the test window {url}',
        focusLostWarningLauncher     : 'Focus has left the test window {url}, it will be restarted. This behavior is controled with the --restart-on-blur option.'
    },

    "Siesta.Test.Date"               :  {
        isEqualTo                    : 'is equal to',
        Got                          : 'Got'
    },

    "Siesta.Test.Element"            : {
        elementContent               : 'element content',
        toAppear                     : 'to appear',
        toDisappear                  : 'to disappear',
        toAppearAt                   : 'to appear at',
        monkeyException              : 'Monkey testing action did not complete properly - probably an exception was thrown',
        monkeyNoExceptions           : 'No exceptions thrown during monkey test',
        monkeyActionLog              : 'Monkey action log',
        elementHasClass              : 'Element has the CSS class',
        elementHasNoClass            : 'Element has no CSS class',
        elementClasses               : 'Classes of element',
        needClass                    : 'Need CSS class',

        hasStyleDescTpl              : 'Element has correct {value} for CSS style {property}',
        elementStyles                : 'Styles of element',
        needStyle                    : 'Need style',

        hasNotStyleDescTpl           : 'Element does not have: {value} for CSS style {property}',
        hasTheStyle                  : 'Element has the style',

        element                      : 'element',
        toBeTopEl                    : 'to be the top element at its position',
        toNotBeTopEl                 : 'to not be the top element at its position',

        selector                     : 'selector',
        selectors                    : 'selectors',
        noCssSelector                : 'A CSS selector must be supplied',

        waitForSelectorsBadInput     : 'An array of CSS selectors must be supplied',

        Position                     : 'Position',
        noElementAtPosition          : 'No element found at the specified position',
        elementIsAtDescTpl           : 'DOM element or its child is at [ {x}, {y} ] coordinates',
        topElement                   : 'Top element',
        elementIsAtPassTpl           : 'DOM element is at [ {x}, {y} ] coordinates',
        allowChildrenDesc            : 'Need exactly this or its child',
        allowChildrenAnnotation      : 'Passed element is not the top-most one and not the child of one',
        shouldBe                     : 'Should be',
        noChildrenFailAnnotation     : 'Passed element is not the top-most one',

        topLeft                      : '(t-l)',
        bottomLeft                   : '(b-l)',
        topRight                     : '(t-r)',
        bottomRight                  : '(b-r)',

        elementIsNotTopElementPassTpl: 'Element is not the top element on the screen',
        selectorIsAtPassTpl          : 'Found element matching CSS selector {selector} at [ {xy} ]',
        elementMatching              : 'Element matching',
        selectorIsAtFailAnnotation   : 'Passed selector does not match any selector at',
        selectorExistsFailTpl        : 'No element matching the passed selector found',
        selectorExistsPassTpl        : 'Found DOM element(s) matching CSS selector {selector}',

        selectorNotExistsFailTpl     : 'Elements found matching the passed selector',
        selectorNotExistsPassTpl     : 'Did not find any DOM element(s) matching CSS selector {selector}',

        toChangeForElement           : 'to change for element',

        selectorCountIsPassTpl       : 'Found exactly {count} elements matching {selector}',
        selectorCountIsFailTpl       : 'Found {got} elements matching the selector {selector}, expected {need}',
        isInViewPassTpl              : 'Passed element is within the visible viewport',

        toAppearInTheViewport        : 'to appear in the viewport',

        elementIsEmptyPassTpl        : 'Passed element is empty',
        elementIsNotEmptyPassTpl     : 'Passed element is not empty',
        elementToBeEmpty             : 'element to be empty',
        elementToNotBeEmpty          : 'element to not be empty'
    },

    "Siesta.Test.ExtJS"              : {
        bundleUrlNotFound                   : 'Cannot find Ext JS bundle url',
        assertNoGlobalExtOverridesInvalid   : 'Was not able to find the Ext JS bundle URL in the `assertNoGlobalExtOverrides` assertion',
        assertNoGlobalExtOverridesPassTpl   : 'No global Ext overrides found',
        assertNoGlobalExtOverridesGotDesc   : 'Number of overrides found',
        foundOverridesFor                   : 'Found overrides for',
        animationsToFinalize                : 'animations to finalize',
        extOverridesInvalid                 : 'Was not able to find the ExtJS bundle URL in the `assertMaxNumberOfGlobalExtOverrides` assertion)',
        foundLessOrEqualThan                : 'Found less or equal than',
        nbrOverridesFound                   : 'Number of overrides found',
        globalOverrides                     : 'Ext JS global overrides'
    },

    "Siesta.Test.ExtJSCore"          : {
        waitedForRequires           : 'Waiting for required classes took too long - \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForExt                 : 'Waiting for Ext.onReady took too long - probably some dependency could not be loaded. \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForApp                 : 'Waiting for MVC application launch took too long - no MVC application on test page? \nYou may need to disable the `waitForAppReady` config option',
        noComponentMatch             : 'Your component query: "{component}" returned no components',
        multipleComponentMatch       : 'Your component query: "{component}" returned more than 1 component',
        noComponentFound             : 'No component found for CQ',
        knownBugIn                   : 'Known bug in',
        Class                        : 'Class',
        wasLoaded                    : 'was loaded',
        wasNotLoaded                 : 'was not loaded',
        invalidCompositeQuery        : 'Invalid composite query selector',
        ComponentQuery               : 'ComponentQuery',
        CompositeQuery               : 'CompositeQuery',
        matchedNoCmp                 : 'matched no Ext.Component',
        messageBoxVisible            : 'Message box is visible',
        messageBoxHidden             : 'Message box is hidden',
        waitedForComponentQuery      : 'Waiting too long for Ext.ComponentQuery'
    },

    "Siesta.Test.Function"           : {
        Need                         : 'need',
        atLeast                      : 'at least',
        exactly                      : 'exactly',
        methodCalledExactly          : 'method was called exactly {n} times',
        exceptionEvalutingClass      : 'Exception [{e}] caught while evaluating the class name'
    },

    "Siesta.Test.More"               : {
        isGreaterPassTpl             : '`{value1}` is greater than `{value2}`',
        isLessPassTpl                : '`{value1}` is less than `{value2}`',
        isGreaterEqualPassTpl        : '`{value1}` is greater or equal to`{value2}`',
        isLessEqualPassTpl           : '`{value1}` is less or equal to`{value2}`',
        isApproxToPassTpl            : '`{value1}` is approximately equal to `{value2}`',

        needGreaterThan              : 'Need greater than',
        needGreaterEqualTo           : 'Need greater or equal to',
        needLessThan                 : 'Need less than',
        needLessEqualTo              : 'Need less or equal to',

        exactMatch                   : 'Exact match',
        withinThreshold              : 'Match within treshhold',
        needApprox                   : 'Need approx',
        thresholdIs                  : 'Threshold is',

        stringMatchesRe              : '`{string}` matches regexp {regex}',
        stringNotMatchesRe           : '`{string}` does not match regexp {regex}',
        needStringMatching           : 'Need string matching',
        needStringNotMatching        : 'Need string not matching',
        needStringContaining         : 'Need string containing',
        needStringNotContaining      : 'Need string not containing',
        stringHasSubstring           : '`{string}` has a substring: `{regex}`',
        stringHasNoSubstring         : '`{string}` does not have a substring: `{regex}`',

        throwsOkInvalid              : 'throws_ok accepts a function as 1st argument',
        didntThrow                   : 'Function did not throw an exception',
        exMatchesRe                  : 'Function throws exception matching to {expected}',
        exceptionStringifiesTo       : 'Exception stringifies to',
        exContainsSubstring          : 'Function throws exception containing a substring: {expected}',

        fnDoesntThrow                : 'Function does not throw any exceptions',
        fnThrew                      : 'Function threw an exception',

        isInstanceOfPass             : 'Object is an instance of the specified class',
        needInstanceOf               : 'Need instance of',
        isAString                    : '{value} is a string',
        aStringValue                 : 'AStringValue',
        isAnObject                   : '{value} is an object',
        anObject                     : 'An object value',
        isAnArray                    : '{value} is an array',
        anArrayValue                 : 'An array value',
        isANumber                    : '{value} is a number',
        aNumberValue                 : 'a number value',
        isABoolean                   : '{value} is a boolean',
        aBooleanValue                : 'a number value',
        isADate                      : '{value} is a date',
        aDateValue                   : 'a date value',
        isARe                        : '{value} is a regular expression',
        aReValue                     : 'a regular expression',
        isAFunction                  : '{value} is a function',
        aFunctionValue               : 'a function',
        isDeeplyPassTpl              : '{obj1} is deeply equal to {obj2}',
        isDeeplyStrictPassTpl        : '{obj1} is strictly deeply equal to {obj2}',
        globalCheckNotSupported      : 'Testing leakage of global variables is not supported on this platform',
        globalVariables              : 'Global Variables',
        noGlobalsFound               : 'No unexpected global variables found',
        globalFound                  : 'Unexpected global found',
        globalName                   : 'Global name',
        value                        : 'value',

        conditionToBeFulfilled       : 'condition to be fulfilled',
        pageToLoad                   : 'page to load',
        ms                           : 'ms',
        waitingFor                   : 'Waiting for',
        waitedTooLong                : 'Waited too long for',
        conditionNotFulfilled        : 'Condition was not fullfilled during',
        waitingAborted               : 'Waiting aborted',
        Waited                       : 'Waited',
        checkerException             : 'checker threw an exception',
        Exception                    : 'Exception',
        msFor                        : 'ms for',
        forcedWaitFinalization       : 'Forced finalization of waiting for',
        chainStepNotCompleted        : 'The step in `t.chain()` call did not complete within required timeframe, chain can not proceed',
        stepNumber                   : 'Step number',
        oneBased                     : '(1-based)',
        atLine                       : 'At line',
        chainStepEx                  : 'Chain step threw an exception',
        stepFn                       : 'Step function',
        notUsingNext                 : 'does not use the provided "next" function anywhere',
        calledMoreThanOnce           : 'The `next` callback of {num} step (1-based) of `t.chain()` call at line {line} is called more than once.',
        tooManyDifferences           : 'Showing {num} of {total} differences'
    },


    "Siesta.Test.SenchaTouch"               : {
        STSetupFailed                       : 'Waiting for Ext.setup took too long - some dependency could not be loaded? Check the `Net` tab in Firebug',
        invalidSwipeDir                     : 'Invalid swipe direction',
        moveFingerByInvalidInput            : 'Trying to call moveFingerBy without relative distances',
        scrollUntilFailed                   : 'scrollUntil failed to achieve its mission',
        scrollUntilElementVisibleInvalid    : 'scrollUntilElementVisible: target or scrollable not provided',
        scrollerReachPos                    : 'scroller to reach position'
    },

    "Siesta.Test"                           : {
        noCodeProvidedToTest                : 'No code provided to test',
        addingAssertionsAfterDone           : 'Adding assertions after the test has finished',
        testFailedAndAborted                : 'Assertion failed, test execution aborted',
        atLine                              : 'at line',
        of                                  : 'of',
        character                           : 'character',
        isTruthy                            : '`{value}` is a "truthy" value',
        needTruthy                          : 'Need "truthy" value',
        isFalsy                             : '`{value}` is a "falsy" value',
        needFalsy                           : 'Need "falsy" value',
        isEqualTo                           : '`{got}` is equal to `{expected}`',
        isNotEqualTo                        : '`{got}` is not equal to `{expected}`',
        needNot                             : 'Need not',
        isStrictlyEqual                     : '`{got}` is strictly equal to `{expected}`',
        needStrictly                        : 'Need strictly',
        isStrictlyNotEqual                  : '`{got}` is strictly not equal to `{expected}`',
        needStrictlyNot                     : 'Need strictly not',
        alreadyWaiting                      : 'Already waiting with title',
        noOngoingWait                       : 'There is no ongoing `wait` action with title',
        noMatchingEndAsync                  : 'No matching `endAsync` call within {time}ms',
        endAsyncMisuse                      : 'Calls to endAsync without argument should only be performed if you have single beginAsync statement',
        codeBodyMissingForSubTest           : 'Code body is not provided for sub test [{name}]',
        codeBodyMissingTestArg              : 'Code body of sub test [{name}] does not declare a test instance as 1st argument',
        Subtest                             : 'Subtest',
        Test                                : 'Test',
        failedToFinishWithin                : 'Subtest {name} failed to finish within {timeout}ms',
        threwException                      : 'threw an exception',
        testAlreadyStarted                  : 'Test has already been started',
        setupTookTooLong                    : '`setup` method took too long to complete',
        errorBeforeTestStarted              : 'Error happened before the test started',
        testStillRunning                    : 'Your test is still considered to be running, if this is unexpected please see console for more information',
        testNotFinalized                    : 'Your test [{url}] has not finalized, most likely since a timer (setTimeout) is still active. ' +
                                              'If this is the expected behavior, try setting "overrideSetTimeout : false" on your Harness configuration.',
        missingDoneCall                     : 'Test has completed, but there was no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code',
        allTestsPassed                      : 'All tests passed',

        'Snoozed until'                     : 'Snoozed until',
        testTearDownTimeout                 : "Test's tear down process has timeout out"
    },

    "Siesta.Recorder.UI.Editor.Code"           : {
        invalidSyntax                       : 'Invalid syntax'
    },

    "Siesta.Recorder.UI.Editor.DragTarget"     : {
        targetLabel                         : 'Target',
        toLabel                             : 'To',
        byLabel                             : 'By',
        cancelButtonText                    : 'Cancel',
        saveButtonText                      : 'Save',

        dragVariantTitle                    : 'Edit `drag` action',
        moveCursorVariantTitle              : 'Edit `moveCursor` action'
    },

    "Siesta.Recorder.UI.RecorderPanel"      : {
        actionColumnHeader                  : 'Action',
        offsetColumnHeader                  : 'Offset',
        queryMatchesNothing                 : 'Query matches no DOM elements or components',
        queryMatchesMultiple                : 'Query matches multiple components',
        noVisibleElsFound                   : 'No visible elements found for target',
        noTestDetected                      : 'No test detected',
        noTestStarted                       : 'You need to run a test first, or provide a Page URL',
        recordTooltip                       : 'Record',
        stopTooltip                         : 'Stop',
        playTooltip                         : 'Play',
        clearTooltip                        : 'Clear all',
        codeWindowTitle                     : 'Code',
        addNewTooltip                       : 'Add a new step',
        removeAllPromptTitle                : 'Remove all?',
        removeAllPromptMessage              : 'Do you want to clear the recorded events?',
        Error                               : 'Error',
        showSource                          : 'Show source',
        showSourceInNewWindow               : 'Show source in new window',
        newRecording                        : 'New recording...',
        pageUrl                             : 'Page URL'
    },

    "Siesta.Recorder.UI.TargetColumn"       : {
        headerText                          : 'Target / Value',
        by                                  : 'by',
        to                                  : 'to',
        coordinateTargetWarning             : 'Siesta was unable to find a stable selector for this target. Using coordinates as locator is not recommended.'
    }
};

;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
// Localization helper
Siesta.Resource = (function () {
    
    var cacheByNamespace    = {}
    
    var Resource    = Class({
        does    : Siesta.Util.Role.CanFormatStrings,
        
        has     : {
            dict        : null
        },
        
        methods : {
            'get' : function (key, data) {
                var text = this.dict[ key ];
        
                if (text) return this.formatString(text, data);
        
                if (window.console && console.error) {
                    window.top.console.error('TEXT_NOT_DEFINED: ' + key);
                }
        
                return 'TEXT_NOT_DEFINED: ' + key;
            }
        }
    
    })
    

    return function (namespace, key, data) {
        var dictionary  = Siesta.CurrentLocale[ namespace ];

        if (!dictionary) {
            throw 'Missing dictionary for namespace: ' + namespace;
        }
        
        var resource    = cacheByNamespace[ namespace ]
        
        if (!resource) {
            resource    = cacheByNamespace[ namespace ] = new Resource({ dict : dictionary, serializeFormatingPlaceholders : false })
        }

        if (key) return resource.get(key, data)

        return resource
    }
})();
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
/**
@class Siesta.Util.Role.CanStyleOutput
@private

A role, providing output coloring functionality

*/
Role('Siesta.Util.Role.CanStyleOutput', {

    has         : {
        /**
         * @cfg {Boolean} disableColoring When set to `true` will disable the colors in the console output in automation launchers / NodeJS launcher
         */
        disableColoring : false,

        style               : {
            is          : 'rwc',
            lazy        : 'this.buildStyle'
        },

        styles              : {
            init    : {
                'bold'      : [1, 22],
                'italic'    : [3, 23],
                'underline' : [4, 24],

                'black '    : [30, 39],
                'yellow'    : [33, 39],
                'cyan'      : [36, 39],
                'white'     : [37, 39],
                'green'     : [32, 39],
                'red'       : [31, 39],
                'grey'      : [90, 39],
                'blue'      : [34, 39],
                'magenta'   : [35, 39],

                'bgblack '  : [40, 49],
                'bgyellow'  : [43, 49],
                'bgcyan'    : [46, 49],
                'bgwhite'   : [47, 49],
                'bggreen'   : [42, 49],
                'bgred'     : [41, 49],
                'bggrey'    : [100, 49],
                'bgblue'    : [44, 49],
                'bgmagenta' : [45, 49],

                'inverse'   : [7, 27]
            }
        }
    },


    methods : {

        buildStyle : function () {
            var me          = this
            var style       = {}

            Joose.O.each(this.styles, function (value, name) {

                style[ name ] = function (text) { return me.styled(text, name) }
            })

            return style
        },


        styled : function (text, style) {
            if (this.disableColoring) return text

            var styles = this.styles

            return '\x1B[' + styles[ style ][ 0 ] + 'm' + text + '\x1B[' + styles[ style ][ 1 ] + 'm'
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {

const Nyc           = require('nyc')

const libReport     = require('nyc/node_modules/istanbul-lib-report')
const reports       = require('nyc/node_modules/istanbul-reports')

const path          = require('path')
const fs            = require('fs')

Role('Siesta.Launcher.Role.CanWorkWithNyc', {

    methods : {

        buildNycArgv : function (rawNycArgs) {
            const configUtil    = require('nyc/lib/config-util')
            const yargs         = configUtil.buildYargs()

            return yargs.parse(rawNycArgs)
        },


        buildNyc : function (argv) {
            if (!argv.instrument)
                argv.instrumenter = './lib/instrumenters/noop'
            else
                argv.instrumenter = './lib/instrumenters/istanbul'

            // otherwise caching of the instrumentation results will be disabled
            argv.isChildProcess = true

            let nyc             = new Nyc(argv)

            if (argv.clean) {
                nyc.reset()
            } else {
                nyc.createTempDirectory()
            }

            return nyc
        },


        // tweaked version of nyc's `nycWriteCoverageFile` method, does not use hard-coded `coverageFinder`
        nycWriteCoverageFile : function (nyc, coverage) {
            // Remove any files that should be excluded but snuck into the coverage
            Object.keys(coverage).forEach(function (absFile) {
                if (!nyc.exclude.shouldInstrument(absFile)) {
                    delete coverage[absFile]
                }
            }, nyc)

            if (nyc.cache) {
                Object.keys(coverage).forEach(function (absFile) {
                    if (nyc.hashCache[absFile] && coverage[absFile]) {
                        coverage[absFile].contentHash = nyc.hashCache[absFile]
                    }
                }, nyc)
            } else {
                coverage = nyc.sourceMaps.remapCoverage(coverage)
            }

            var id = nyc.generateUniqueID()
            var coverageFilename = path.resolve(nyc.tempDirectory(), id + '.json')

            fs.writeFileSync(
                coverageFilename,
                JSON.stringify(coverage),
                'utf-8'
            )
        },


        // tweaked version of nyc's `report` method, uses custom source finder
        nycReport : function (nyc, sourceFinder) {
            var tree
            var map = nyc.getCoverageMapFromAllCoverageFiles()
            var context = libReport.createContext({
                dir : nyc.reportDirectory(),
                watermarks : nyc.config.watermarks,
                sourceFinder : sourceFinder
            })

            tree = libReport.summarizers.pkg(map)

            nyc.reporter.forEach((_reporter) => {
                tree.visit(reports.create(_reporter, {
                    skipEmpty : nyc.config.skipEmpty,
                    skipFull : nyc.config.skipFull
                }), context)
            })
        }

    }
})

}();
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Role.CanPrintWithLauncher', {

    does    : [
        Siesta.Util.Role.CanStyleOutput
    ],

    has : {
        launcher                : { required : true }
    },

    methods : {

        print : function (text, level) {
            return this.launcher.print(text, level)
        },


        printErr : function (text, level) {
            return this.launcher.printErr(text, level)
        },


        printError : function (text, level) {
            return this.launcher.printError(text, level)
        },


        info : function (text, level) {
            return this.launcher.info(text, level)
        },


        warn : function (text, level) {
            return this.launcher.warn(text, level)
        },


        debug : function (text) {
            return this.launcher.debug(text)
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Role.CanLaunchSimulatorServer', {

    requires : [
        'debug',
        'getOptions'
    ],

    has : {
        simulatorServerClass    : null,

        wsServer                : null
    },


    methods : {

        setupNativeEventsSimulator : function (simServerClass) {
            var options     = this.getOptions()

            var ConnectionServer    = require("../src/nodejs/channel/websocket/ConnectionServer").ConnectionServer
            var LogLevel            = require("../src/generic/util/role/CanLog").LogLevel

            var simulatorServerClass = simServerClass || this.simulatorServerClass || require("../src/nodejs/simulator/robotjs/Server").SimulatorServerRobotJs

            var server      = this.wsServer = new ConnectionServer({
                serverClass     : simulatorServerClass,
                logLevel        : options[ 'log-level' ] ? LogLevel[ options[ 'log-level' ] ] : (options.debug ? LogLevel.debug : LogLevel.log)
            })

            var me          = this

            me.debug("Starting native events server")

            return server.start().then(function () {
                me.debug("Native events server has started on port " + server.port + ", awaiting for connections")
            })
        },


        // promised method
        setupNativeEventsSimulatorInSeparateProcess : function (displayNum) {
            var me              = this

            return new Promise(function (resolve, reject) {
                var child_process   = require('child_process');

                me.debug("Starting native events server")

                // setup a DISPLAY env variable for simulator, since we don't initialize robotjs simulator
                // if its not set
                var options = displayNum ? { env : { DISPLAY : ':' + displayNum + '.0' } } : {}

                var childProcess    = child_process.spawn(
                    process.execPath,
                    [ me.launcher.binDir.replace(/\/$/, '') + '/simulator.js', 'auto', JSON.stringify({ displayNumber : displayNum }) ],
                    options
                )

                var readLineInterface   = require('readline').createInterface({ input : childProcess.stdout })

                readLineInterface.on('line', function (data) {
                    var match   = /port (\d+)/.exec(data)

                    if (match) {
                        me.debug("Native events server has started on port: " + match[ 1 ])

                        me.wsServer.port = Number(match[ 1 ])

                        readLineInterface.close()

                        resolve()
                    }
                });

                childProcess.on('error', reject)
                childProcess.on('exit', reject)

                me.wsServer = {
                    stop : function () {
                        var handle  = setTimeout(function () {
                            childProcess.kill('SIGKILL')
                        }, 3000)

                        childProcess.on('exit', function () {
                            clearTimeout(handle)
                        })

                        childProcess.kill()

                        return Promise.resolve()
                    }
                }
            })
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {

const zlib          = require('zlib')

const URL           = require('url')
const http          = require('http')
const https         = require('https')
const tls           = require('tls')

const HttpProxy     = require('http-proxy')

const stream        = require('stream')
const net           = require('net')
const constants     = require('constants')

const NYC           = require('nyc')
const TestExclude   = require('test-exclude')

const EasyCert      = require('node-easy-cert')


const certManager   = new EasyCert({
    defaultCertAttrs    : [
        { name : 'countryName', value : 'SE' },
        { name : 'organizationName', value : 'Bryntum' },
        { shortName : 'ST', value : 'Stockholm' },
        { shortName : 'OU', value : 'Siesta' }
    ]
})

// enable the debug output from the `nyc` - this will output the instrumentation failures
process.env.NODE_DEBUG  = 'nyc' + (process.env.NODE_DEBUG ? '' + process.env.NODE_DEBUG : '')

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'

// PATCH
/*
    the original `extractAndRegister` method is written like this:

        var sourceMap = convertSourceMap.fromSource(code) || convertSourceMap.fromMapFileSource(code, path.dirname(filename))

    so, if `convertSourceMap.fromSource(code)` fails, it retries with loading from file, which we strictly don't want,
    as there's no filesystem in the browser case.
    so we just silence exceptions from this method
*/
const SourceMaps    = require('nyc/lib/source-maps')

const originalExtractAndRegister    = SourceMaps.prototype.extractAndRegister

SourceMaps.prototype.extractAndRegister = function () {
    try {
        return originalExtractAndRegister.apply(this, arguments)
    } catch (e) {
        return null
    }
}
// EOF PATCH



Role('Siesta.Launcher.Role.CanLaunchInstrumentationProxy', {

    does        : [
        'Siesta.Launcher.Role.CanWorkWithNyc'
    ],

    requires    : [
        'debug'
    ],

    has : {
        // pick random free port by default
        instrumentationProxyPort        : 0,
        instrumentationHttpsServerPort  : 0,

        shouldInstrumentChecker         : null,

        nyc                             : { is : 'ro' },

        // cache of the original sources - will be used during reports generation
        instrumentedSources             : Joose.I.Object,

        httpServer                      : null,
        httpsServer                     : null
    },


    methods : {

        urlToCoverageFilename : function (url) {
            // we just strip the protocol and query string, and then treat the remaining string `/domain.com/path` as the filename
            return (url || '').replace(/^(\w+):\/\//, '/$1/').replace(/\?.*/, '')
        },


        shouldInstrumentResponse : function (url, response) {
            const contentType   = response.headers[ 'content-type' ]

            return Boolean(
                (contentType && (contentType.match(/application\/(x-)?javascript/) || contentType.match(/text\/javascript/)))
                && response.statusCode == 200
                && this.shouldInstrumentChecker.shouldInstrument(this.urlToCoverageFilename(url))
            )
        },


        instrumentJavaScriptCode : function (code, filename, relFile) {
            const nyc       = this.getNyc()

            let ext, transform

            for (ext in nyc.transforms) {
                if (filename.toLowerCase().substr(-ext.length) === ext) {
                    transform   = nyc.transforms[ ext ]
                    break
                }
            }

            // the `transform` function is equiped with results caching
            return transform ? transform(code, { filename : filename, relFile : relFile }) : null
        },


        fetchFullResponse : function (res) {
            let parts       = []

            res.on('data', (data) => {
                parts.push(data)
            })

            return new Promise((resolve, reject) => {
                res.on('end', () => resolve(Buffer.concat(parts)))

                res.on('error', (e) => reject(e))
            })
        },


        decompressResponseBuffer : function (buffer, contentEncoding) {
            const gzipped           = /gzip/i.test(contentEncoding)
            const deflated          = /deflate/i.test(contentEncoding)
            const brotlied          = /br/i.test(contentEncoding)

            if (gzipped) {
                return zlib.gunzipSync(buffer).toString()
            } else if (deflated) {
                return zlib.inflateRawSync(buffer).toString()
            } else if (brotlied) {
                // 'brotli' module, once "required", behaves __really weird__
                // its code somehow randomly pops up in the error messages, and in debugger
                // so require it lazily, only if needed
                return Buffer.from(require('brotli').decompress(buffer).buffer).toString()
            } else
                return buffer.toString()
        },


        compressResponseBuffer : function (string, contentEncoding) {
            const gzipped           = /gzip/i.test(contentEncoding)
            const deflated          = /deflate/i.test(contentEncoding)
            const brotlied          = /br/i.test(contentEncoding)

            if (gzipped) {
                return zlib.gzipSync(string)
            } else if (deflated) {
                return zlib.deflateRawSync(string)
            } else if (brotlied) {
                // 'brotli' module, once "required", behaves __really weird__
                // its code somehow randomly pops up in the error messages, and in debugger
                // so require it lazily, only if needed
                return Buffer.from(require('brotli').compress(Buffer.from(string)).buffer)
            } else
                return Buffer.from(string)
        },


        // `upstreamHttpProxy` should be an object like : { host : 'somehost', port : 1111 }
        // `nycArgs` should be a result of `buildNycArgv` call
        setupInstrumentationProxy : function (upstreamProxy, nycArgs) {
            nycArgs     = nycArgs || this.buildNycArgv([])

            nycArgs.exclude.push(
                '**/siesta-all.js',
                '**/siesta-no-ui-all.js',
                '**/*.t.js'
            )

            this.nyc            = this.buildNyc(nycArgs)

            const shouldInstrumentChecker = this.shouldInstrumentChecker = TestExclude({
                relativePath        : false,
                include             : nycArgs.include,
                exclude             : nycArgs.exclude
            })

            // override the `TestExclude` instance in Nyc to be the same as we use in other places
            this.nyc.exclude    = shouldInstrumentChecker

            const httpProxy     = HttpProxy.createProxyServer({
                secure              : false,
                selfHandleResponse  : true
            })

            httpProxy.on('proxyReq', (proxyReq, req, res, options) => {
                const port      = this.instrumentationProxyPort + ''

                // console.log(`PROXYING request for ${req.url}, headers: ${proxyReq.headers}`, req.headers)

                if (/do_not_proxy/i.test(req.url) || req.headers.host.slice(-port.length) == port) {
                    res.end('Test request completed successfully')

                    return
                }
            })

            httpProxy.on('proxyRes', (proxyRes, req, res) => {
                const url                   = this.getRequestFullUrl(req)

                const shouldInstrument      = this.shouldInstrumentResponse(url, proxyRes)

                this.debug(`PROXYING request for ${url} will instrument: ${shouldInstrument}`)

                if (shouldInstrument) {
                    this.fetchFullResponse(proxyRes).then(
                        (buffer) => {
                            const responseBuff      = this.processResponseFromProxy(buffer, proxyRes, req, res)

                            // fix the `content-length` header value
                            const headers           = Object.assign({}, proxyRes.headers, {
                                'content-length'    : Buffer.byteLength(responseBuff)
                            })

                            res.writeHead(proxyRes.statusCode, proxyRes.statusMessage, headers)

                            res.end(responseBuff)
                        },
                        (e) => {
                            res.end(`Exception while fetching proxied response: ${e}`)
                        }
                    )
                } else {
                    res.writeHead(proxyRes.statusCode, proxyRes.statusMessage, proxyRes.headers)

                    proxyRes.pipe(res)
                }
            })

            // this is just to silence the built-in exception throwing from http-proxy
            httpProxy.on('error', (e) => {
                // console.log("Error from http-node-proxy, should be handled somewhere else: ", e, e.stack)
            })

            this.debug("Starting instrumentation proxy")

            return Promise.all([
                new Promise((resolve, reject) => {
                    const server        = this.httpServer = this.createHttpServer(upstreamProxy, httpProxy)

                    server.listen(this.instrumentationProxyPort, () => {
                        const port      = server.address().port

                        this.instrumentationProxyPort   = port

                        this.debug(`HTTP Instrumentation proxy has started on ${server.address().address}:${port}`)

                        resolve()
                    })
                }),
                this.ensureRootCertificateGenerated().then(() => {

                    return new Promise((resolve, reject) => {
                        const server        = this.httpsServer = this.createHttpsServer(upstreamProxy, httpProxy)

                        server.listen(this.instrumentationHttpsServerPort, () => {
                            const port      = server.address().port

                            this.instrumentationHttpsServerPort = port

                            this.debug(`HTTPS Instrumentation proxy has started on ${server.address().address}:${port}`)

                            resolve()
                        })
                    })
                })
            ])
        },


        ensureRootCertificateGenerated : function () {
            if (certManager.isRootCAFileExists())
                return Promise.resolve()
            else
                return new Promise((resolve, reject) => {
                    certManager.generateRootCA(
                        { commonName : 'SiestaInstrumentationProxy' },
                        (e) => e ? reject(e) : resolve()
                    )
                })
        },


        createHttpsServer : function (upstreamProxy, httpProxy) {
            const server = https.createServer(
                {
                    secureOptions   : constants.SSL_OP_NO_SSLv3 || constants.SSL_OP_NO_TLSv1,

                    SNICallback     : (serverName, callback) => {
                        certManager.getCertificate(serverName, (e, key, crt) => {
                            if (e) {
                                this.debug(`Error while retrieving certificate for ${serverName}`)
                                callback(e)
                                return
                            }

                            let ctx

                            try {
                                ctx = tls.createSecureContext({ key : key, cert : crt })
                            } catch (e) {
                                this.debug(`Error while creating HTTPS secure context for ${serverName}`)
                                callback(e)
                                return
                            }

                            this.debug(`HTTPS secure context initialized for ${serverName} created`)

                            callback(null, ctx)
                        })
                    }
                },
                this.getHttpRequestHandler(upstreamProxy, httpProxy)
            )

            server.on('upgrade', this.getUpgradeRequestHandler(upstreamProxy, httpProxy))

            return server
        },


        createHttpServer : function (upstreamProxy, httpProxy) {
            const server    = http.createServer(this.getHttpRequestHandler(upstreamProxy, httpProxy))

            server.on('connect', (req, socket, head) => this.onHttpServerConnectEvent(req, socket, head, upstreamProxy, httpProxy))

            server.on('upgrade', this.getUpgradeRequestHandler(upstreamProxy, httpProxy))

            return server
        },


        // in http and https servers, the `req.url` property is different
        // in http it contains full url with protocol and host
        // in https it contains only the "path" part
        // normalizing this
        getRequestFullUrl : function (req) {
            if (/^\w+:\//.test(req.url)) return req.url

            return (req.connection.encrypted ? 'https://' : 'http://') + req.headers.host + req.url
        },


        createSocketOverHttpProxy : function (upstreamProxy, targetHost) {
            // this.debug(`Establishing CONNECT tunnel for ${targetHost} via ${upstreamProxy.host}:${upstreamProxy.port}`)

            const request   = http.request({
                method      : 'CONNECT',

                hostname    : upstreamProxy.host,
                port        : upstreamProxy.port,

                path        : targetHost
            })

            return new Promise((resolve, reject) => {
                request.on('connect', (response, socket, head) => {
                    if (response.statusCode == 200) {
                        socket.setTimeout(0)
                        socket.setNoDelay(true)
                        socket.setKeepAlive(true, 0)

                        resolve(socket)
                    } else {
                        reject({ response : response })
                    }
                })

                request.on('error', (e) => {
                    reject({ error : e })
                })

                request.end()
            })
        },


        createSocketFor : function (port, host, upstreamProxy) {
            if (upstreamProxy) {
                return this.createSocketOverHttpProxy(upstreamProxy, host + ':' + port)
            } else {
                return new Promise((resolve, reject) => {
                    const proxySocket = net.connect(port, host, () => {
                        resolve(proxySocket)
                    })

                    proxySocket.on('error', reject)
                })
            }
        },


        getRegularProxyOptions : function (req) {
            const url       = URL.parse(req.url)

            return {
                target      : {
                    protocol        : url.protocol || (req.connection.encrypted ? 'https:' : 'http:'),
                    host            : url.hostname || req.headers.host.split(':')[ 0 ],
                    port            : url.port || req.headers.host.split(':')[ 1 ],
                },
                changeOrigin        : true
            }
        },


        getUpgradeRequestHandler : function (upstreamProxy, httpProxy) {
            return (req, socket, head) => {
                this.debug(`Upgrading connection for request: ${req.url}`)

                if (upstreamProxy) {
                    this.createSocketOverHttpProxy(upstreamProxy, req.headers.host).then((tunnelSocket) => {
                        socket.unshift(head)

                        const options               = this.getRegularProxyOptions(req)

                        options.createConnection    = (options, cb) => cb(null, tunnelSocket)

                        httpProxy.ws(req, socket, head, options)
                    }, (e) => {
                        this.debug(`Could not establish CONNECT tunnel with upstream proxy: ${upstreamProxy.host}:${upstreamProxy.port}\n`)
                    })
                } else {
                    httpProxy.ws(req, socket, head, this.getRegularProxyOptions(req))
                }
            }
        },


        getTargetHostOfRequest : function (req) {
            const host      = req.headers.host

            if (host.match(/:\d+$/)) return host

            return req.connection.encrypted ? host + ':443' : host + ':80'
        },


        getHttpRequestHandler : function (upstreamProxy, httpProxy) {
            return (req, res) => {
                if (upstreamProxy) {
                    // req.headers.host may not contain port sometimes
                    this.createSocketOverHttpProxy(upstreamProxy, this.getTargetHostOfRequest(req)).then((socket) => {
                        const options               = this.getRegularProxyOptions(req)

                        options.createConnection    = (options, cb) => cb(null, socket)

                        httpProxy.web(req, res, options)
                    }, (e) => {
                        this.debug(`Could not establish CONNECT tunnel with upstream proxy: ${upstreamProxy.host}`)

                        const response  = e.response

                        if (response) {
                            this.debug(`statusCode=${response.statusCode}, message=${response.statusMessage}`)

                            res.writeHead(response.statusCode, response.statusMessage, response.headers)
                            response.pipe(res)
                        } else {
                            this.debug(JSON.stringify(e.error))

                            res.writeHead(500, `Could not establish CONNECT tunnel with upstream proxy ${upstreamProxy.host}-${upstreamProxy.port}`)
                            res.end(JSON.stringify(e.error))
                        }
                    })
                } else {
                    httpProxy.web(req, res, this.getRegularProxyOptions(req))
                }
            }
        },


        onHttpServerConnectEvent : function (req, socket, head, upstreamHttpProxy, httpProxy) {
            this.debug(`Received CONNECT request for: ${req.url}`)

            const targetHost            = req.url.split(':')[ 0 ]
            const targetPort            = req.url.split(':')[ 1 ]

            return new Promise((resolve, reject) => {
                socket.write('HTTP/' + req.httpVersion + ' 200 OK\r\n\r\n', 'utf8', resolve);
            }).then(() => {
                socket.unshift(head)

                // pass-through the CONNECT to saucelabs and browserstack, to avoid certificate errors
                if (targetHost.match(/saucelabs\.com$/i) || targetHost.match(/browserstack\.com$/i)) {
                    return this.createSocketFor(targetPort, targetHost, upstreamHttpProxy).then((proxySocket) => {
                        socket.pipe(proxySocket)
                        proxySocket.pipe(socket)
                    })
                } else {
                    if (targetPort === '80') {
                        this.httpServer.emit('connection', socket)
                    } else {
                        this.httpsServer.emit('connection', socket)
                    }
                }

            }).catch((error) => {
                this.debug(`Error during request proxying: ${error.stack}`)

                try {
                    socket.write([
                        'HTTP/1.1 502',
                        'Content-Type: text/html',
                        '',
                        '',
                        error,
                        error.stack
                    ].join('\r\n'))

                } catch (e) {
                }
            })
        },


        processResponseFromProxy : function (buffer, proxyRes, req, res) {
            const contentEncoding   = proxyRes.headers[ 'content-encoding' ]

            const code              = this.decompressResponseBuffer(buffer, contentEncoding)

            const fileName          = this.urlToCoverageFilename(this.getRequestFullUrl(req))
            const instrumented      = this.instrumentJavaScriptCode(code, fileName)

            if (instrumented) {
                this.instrumentedSources[ fileName ] = code
            }

            const response          = instrumented || code

            return this.compressResponseBuffer(response, contentEncoding)
        }
    }
})

}();
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Role.CanProcessArguments', {

    methods : {

        processArguments : function (args) {
            var options             = {}
            var argv                = []
            var positionalGroups    = {}

            var currentOption

            var addOption   = function (name, value, optionsBag) {
                if (optionsBag.hasOwnProperty(name)) {
                    var prevValue   = optionsBag[ name ]

                    if (!(prevValue instanceof Array)) optionsBag[ name ] = [ prevValue ]

                    optionsBag[ name ].push(value)

                } else
                    optionsBag[ name ] = value

                currentOption = null
            }

            for (var i = 0; i < args.length; i++) {
                var arg     = args[ i ]

                var match   = /^\s*--([\w_\-\.]+)(?=\=(.*)|$)/.exec(arg)

                // we get a switch like, --option or --option=value
                if (match) {
                    var optionName      = match[ 1 ]
                    var optionValue     = match[ 2 ]
                    var groupMatch

                    if (groupMatch = /([\w_-]+)\.([\w_-]+)/.exec(optionName)) {
                        var groupName       = groupMatch[ 1 ]

                        if (!positionalGroups[ groupName ]) positionalGroups[ groupName ] = []

                        positionalGroups[ groupName ].push('--' + groupMatch[ 2 ] + (optionValue != null ? '=' + optionValue : ''))
                    }

                    // dealing with current state first
                    // option w/o values get `new Boolean(true)` as value
                    if (currentOption) addOption(currentOption, new Boolean(true), options)

                    // now processing a new match
                    if (optionValue != undefined)
                        addOption(optionName, optionValue, options)
                    else
                        currentOption = optionName

                } else
                    if (currentOption)
                        addOption(currentOption, arg, options)
                    else
                        argv.push(arg)
            }

            // option w/o values get `new Boolean(true)` as value
            if (currentOption) addOption(currentOption, new Boolean(true), options)

            var groups          = {}
            var regularOptions  = {}

            var match

            for (var name in options) {
                if (match = /([\w_-]+)\.([\w_-]+)/.exec(name)) {
                    var groupName   = match[ 1 ]
                    var optionName  = match[ 2 ]

                    var group       = groups[ groupName ] = groups[ groupName ] || {}

                    addOption(optionName, options[ name ], group)
                } else {
                    regularOptions[ name ] = options[ name ]
                }
            }

            return {
                options             : regularOptions,
                argv                : argv,
                groups              : groups,
                positionalGroups    : positionalGroups
            }
        }
    }
    // eof methods
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Dispatcher.Element', {

    does    : [
        Siesta.Util.Role.HasUniqueGeneratedId
    ],

    has : {
        descId              : null,

        inProgress          : false,

        processed           : false,
        processedCount      : 0,
        maxProcessedCount   : 2,

        result              : null,

        belongsTo           : { required : true },

        resultPrinted       : false
    },


    methods : {

        startProgress : function () {
            if (this.processed) throw new Error("Element already processed" + this.descId)
            if (this.inProgress) throw new Error("Element already in progress" + this.descId)

            this.inProgress     = true
        },


        canRunAgain : function (withThisTime) {
            return this.processedCount + (withThisTime ? 1 : 0) < this.maxProcessedCount
        },


        // thereWasNoError means the element was not even attempted to launch, for example, it is at the end of the
        // tests list, and chunk has been terminated in the middle, this does not count as an attempt to run the
        // element
        reset : function (thereWasNoError) {
            if (!this.inProgress) throw new Error("Element is not in progress" + this.descId)
            if (this.processed) throw new Error("Element already processed" + this.descId)

            if (thereWasNoError) {
                this.inProgress     = false
            } else {
                if (!this.canRunAgain(true)) {
                    this.endProgress({
                        url     : this.descId,
                        ERROR   : "Failed to run the test: " + this.descId
                    })

                    return true
                } else {
                    this.processedCount++
                    this.inProgress     = false
                }
            }
        },


        setProcessed : function (value) {
            if (this.processed != value) {
                this.processed  = value

                value ? this.belongsTo.done++ : this.belongsTo.done--
            }
        },


        endProgress : function (result) {
            if (this.processed) throw new Error("Element already processed" + this.descId)
            if (!this.inProgress) throw new Error("Element is not in progress: " + this.descId)

            this.processedCount++

            this.inProgress     = false
            this.result         = result

            this.setProcessed(true)
        },


        asJSON : function () {
            return {
                automationElementId : this.id,
                descId              : this.descId
            }
        },


        canPrintResultImmediately : function () {
            var result      = this.result

            return Boolean(result.ERROR || result.passed || result.isTodo)
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Dispatcher.Group', {
    
    has : {
        elementsById        : Joose.I.Object,
        elements            : Joose.I.Array,
        
        elementsByDescId    : Joose.I.Object,
        
        done                : 0,
        
        maxProcessedCount   : 2
    },
    
    
    methods : {
        
        initialize: function () {
            var elementsByDescId    = this.elementsByDescId
            var elementsById        = this.elementsById
            var elements            = this.elements
            
            var me                  = this
            
            Joose.A.each(elements, function (element, index) {
                if (!(element instanceof Siesta.Launcher.Dispatcher.Element))
                    elements[ index ] = element = new Siesta.Launcher.Dispatcher.Element({
                        descId              : element,
                        belongsTo           : me,
                        maxProcessedCount   : me.maxProcessedCount
                    })
                    
                elementsById[ element.id ] = element
                elementsByDescId[ element.descId ] = element
            })
        },
        
        
        fetchNSpareElements : function (n, asJSON) {
            if (this.allDone()) return null
            
            var els     = []
            
            Joose.A.each(this.elements, function (element, index) {
                if (!element.inProgress && !element.processed) {
                    els.push(asJSON ? element.asJSON() : element)
                    
                    element.startProgress()
                }
                    
                if (els.length == n) return false
            })
            
            return els.length ? els : null
        },
        
        
        getElementById : function (id) {
            return this.elementsById[ id ] || null
        },
        
        
        getElementByDescId : function (id) {
            return this.elementsByDescId[ id ] || null
        },
        
        
        forEachElement : function (func, scope) {
            return Joose.A.each(this.elements, func, scope)
        },
        
        
        allDone : function () {
            return this.done == this.elements.length
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Script.CanSplitTextIntoChunks', {
    
    methods : {
        
        splitIntoChunks: function (text, maxChunkSize) {
            var length          = text.length
            
            var pos             = 0
            var chunks          = []
            
            while (pos < length) {
                var chunk       = null
                var chunkSize   = maxChunkSize * 0.8
                
                while (!chunk) {
                    // while stringifying, the size of the chunk can increase, we don't know how much upfront
                    chunk       = JSON.stringify(text.substr(pos, chunkSize))
                    
                    if (chunk.length > maxChunkSize) {
                        chunk           = null
                        chunkSize       = Math.floor(chunkSize * 0.8)
                        
                        if (!chunkSize) throw "Chunk size zero"
                    }
                }
                
                chunks.push(chunk)
                
                pos             += chunkSize
            }
            
            return chunks
        }
    }
    // eof methods
})

;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {
/* header */

var scriptIdGen         = 1

Role('Siesta.Launcher.Script.CanExecute', {

    requires    : [ 'executeSmallScriptPromised', 'print' ],

    does        : [
        Siesta.Launcher.Script.CanSplitTextIntoChunks
    ],

    has : {
        maxMessageSize                  : 700000
    },


    methods : {

        shouldStopScriptExecution : function () {
            return false
        },


        executeScript : function (text, ignoreException) {
            var me              = this
            var scriptId        = scriptIdGen++

            var chunks          = this.splitIntoChunks(text, this.maxMessageSize)
            var promise         = Promise.resolve()

            Joose.A.each(chunks, function (chunk, index) {
                var isLastChunk = index == chunks.length - 1

                promise         = promise.then(function () {
                    if (me.shouldStopScriptExecution()) return null

                    return me.executeSmallScriptPromised(
                        "return Siesta.Project.Browser.Automation.ScriptExecutor().acceptScriptChunk(" +
                            scriptId + ", " +
                            me.maxMessageSize + ", " +
                            chunk + ", " +
                            index + ", " +
                            isLastChunk +
                        ")",
                        ignoreException
                    )
                })
            })

            return promise.then(function (result) {
                if (me.shouldStopScriptExecution()) return null

                if (!result) throw "Wrong `executeScript` flow"

                result                  = JSON.parse(result)

                if (result.exception) {
                    if (!ignoreException) {
                        me.print("<Exception from launcher>")
                        me.print("    While running big script: " + text.substring(0, 150))
                        me.print("    Exception: " + result.exception)
                        me.print("</Exception from launcher>")

                        throw result.exception
                    }

                    return null
                }

                return me.combineScriptResults(scriptId, result)
            })
        },

        combineScriptResults : function (scriptId, result, resultChunks) {
            var me          = this
            resultChunks    = resultChunks || []

            resultChunks.push(result.chunk)

            if (result.isLastChunk || me.shouldStopScriptExecution()) {
                return JSON.parse(resultChunks.join(''))
            } else {
                if (me.shouldStopScriptExecution()) return Promise.resolve(null)

                return me.executeSmallScriptPromised(
                    "return Siesta.Project.Browser.Automation.ScriptExecutor().retrieveScriptResult(" +
                        scriptId + ", " +
                        resultChunks.length +
                    ")"
                ).then(function (result) {
                    result      = JSON.parse(result)

                    return me.combineScriptResults(scriptId, result, resultChunks)
                })
            }
        }
    }
})


/* footer */
}();
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Page.BasePage', {

    does        : [
        JooseX.Observable,

        Siesta.Util.Role.CanParseBrowser,
        Siesta.Util.Role.HasUniqueGeneratedId,

        Siesta.Launcher.Role.CanPrintWithLauncher,

        Siesta.Launcher.Script.CanExecute
    ],


    has : {
        runner                  : { required : true },
        launcher                : { required : true },
        dispatcher              : { required : true },

        pollInterval            : 1000,
        pollTimeout             : null,

        width                   : 1280,
        height                  : 1024,

        getStateExceptionCounter    : 0,

        activityTimeout         : null,
        // the timestamp of the last change of the "lastActivityToken" property
        lastActivity            : null,
        // the timestamp of the last activity inside of test, the timestamp does not neccessary match the clock
        // inside Rhino, so we track its updates
        lastActivityToken       : null,

        isClosed                : false,

        sessionId               : { is : 'rw', init : null },

        chunkTask               : null
    },


    methods : {

        getOptions : function () {
            return this.dispatcher.options
        },


        open : function (url, callback) {
            throw new Error("Abstract method call: `open`")
        },


        close : function () {
            this.debug("Page close started: " + this.id)

            clearTimeout(this.pollTimeout)

            this.isClosed       = true

            this.fireEvent('close')

            if (this.wsServer)
                return this.wsServer.stop()
            else
                return Promise.resolve()
        },


        // this method should wait until the `Harness.start` method is called
        // (which assigns the Siesta.my.activeHarness value)
        // this can happen with delay if project starts with the `startFromUrl`
        getConfigInfo : function (inc, exc, filter, callback, i) {
            i           = i || 0

            var me      = this

            if (i > 10)
                callback('Timeout while waiting for `project.start()` method')
            else
                this.executeHarnessMethod('getConfigInfo', [ inc, exc, filter, this.dispatcher.projectConfig ]).then(function (result) {
                    if (result == 'not_started')
                        // repeat after 1.5s
                        setTimeout(function () {
                            me.getConfigInfo(inc, exc, filter, callback, i++)
                        }, 1500)
                    else
                        callback(null, result)
                }, function (e) {
                    callback(e)
                })
        },


        executeHarnessMethod : function (methodName, args) {
            var func    = function (args) {
                var me  = Siesta.my.activeHarness

                return me ? me[ METHOD_NAME ].apply(me, args) : 'not_started'
            }

            args            = JSON.stringify(args || [])

            var start       = new Date()
            var options     = this.dispatcher.options
            var me          = this

            this.debug('PageId: ' + this.id + ', method : ' + methodName + ' starting, args size: ' + args.length)

            return this.executeScript(
                'return (' + func.toString().replace(/METHOD_NAME/, "'" + methodName + "'") + ')(' + args + ')'
            ).then(function (result) {
                var message = 'PageId: ' + me.id + ', method : ' + methodName + ', took ' + (new Date() - start) / 1000 + 's'

                if (Number(options.debug) > 1)
                    message  += ', result : ' + JSON.stringify(result)
                else
                    if (options.debug)
                        message  += ', result size : ' + JSON.stringify(result).length

                me.debug(message)

                return result
            })
        },


        pageShouldNotBeUsedAfterException : function (e) {
            return false
        },


        doPoll : function (callback) {
            var me      = this

            this.executeHarnessMethod('getAutomationState', []).then(function (state) {
                if (me.shouldStopScriptExecution()) return

                me.getStateExceptionCounter     = 0

                // `state.activityTimeout` will be `null` until the start of the 1st test
                // allow 3 min for that
                me.activityTimeout      = state.activityTimeout || 180000

                var newActivityToken    = state.lastActivity

                // state has not changed
                if (me.lastActivityToken && newActivityToken == me.lastActivityToken) {
                    if (new Date() - me.lastActivity > me.activityTimeout) {
                        me.dispatcher.onPageInactivityTimeout(state.activeTestAutomationId, me.activityTimeout)

                        callback('inactivity_timeout', state.notLaunched)
                        return
                    }
                } else {
                    // state has changed (or no previous state)
                    me.lastActivityToken    = newActivityToken
                    me.lastActivity         = new Date()
                }

                me.dispatcher.consumeTestStateUpdate(state, me).then(function (res) {
                    if (res == 'all_done' || res == 'force_exit') {
                        callback(null)
                    } else if (res == 'focus_lost') {
                        callback(null, state.notLaunched)
                    } else {
                        me.pollTimeout  = setTimeout(function () { me.doPoll(callback) }, me.pollInterval)
                    }
                })
            }, function (e) {
                if (me.shouldStopScriptExecution()) return

                me.getStateExceptionCounter++

                me.debug("Exception #" + me.getStateExceptionCounter + " during `doPoll`, pageId=" + me.id + ": " + e)

                // allow up to 2 exceptions from the `getAutomationState` method before really fail
                // (weirdly happens sometimes, guess in which browser)
                if (me.getStateExceptionCounter >= 2 || me.pageShouldNotBeUsedAfterException(e))
                    callback(e)
                else
                    me.pollTimeout  = setTimeout(function () { me.doPoll(callback) }, me.pollInterval)
            })
        },


        runChunk : function (chunkTask, callback) {
            var me                  = this

            this.chunkTask          = chunkTask

            var dispatcher          = this.dispatcher
            var options             = this.getOptions()
            var coverage            = options.coverage

            var params              = {
                pause               : options.pause,
                streamAssertions    : dispatcher.streamAssertions,
                showCursor          : Boolean(options[ 'show-cursor' ]),
                restartOnBlur       : Boolean(options[ 'restart-on-blur' ]),
                projectConfig       : Joose.O.copy(dispatcher.projectConfig)
            }

            var wsServer            = this.wsServer || dispatcher.wsServer

            if (wsServer) {
                params.projectConfig.simulatorPort                  = wsServer.port
            }

            // SauceLabs testing
            // if (wsServer) {
            //     // params.projectConfig.simulatorPort                  = wsServer.port
            //     params.projectConfig.simulatorConnectionTimeout     = 1500000
            // }

            if (coverage) {

                Joose.O.extend(params, {
                    enableCodeCoverage              : true,
                    manuallyProcessCoverageResults  : this.launcher.manuallyProcessCoverageResults
                })
            }

            var onChunkProcessed = function (e, notLaunchedById) {
                me.runner.onPageCompleted(me, e, notLaunchedById).then(function () {
                    callback(e, notLaunchedById)
                })
            }

            this.executeHarnessMethod('launchAutomatedTests', [ chunkTask, params ]).then(function (result) {
                me.debug("Page polling has started")

                me.pollTimeout  = setTimeout(function () { me.doPoll(onChunkProcessed) }, me.pollInterval)
            }, function (e) {
                me.debug("Page polling failed to start")

                onChunkProcessed(e)
            })
        },


        openHarness : function (projectUrl, callback) {
            var me          = this

            this.open(projectUrl, function (e) {
                if (e) { callback(e); return }

                var errorCodes      = {
                    'no-siesta'     : "Can't find Siesta on the project page - page loading failed?",
                    'no-automation' : "The project page you are targeting contains Siesta Lite distribution. To use automation facilities, \nmake sure project page uses `siesta-all.js` from Standard or Trial packages"
                }

                var sanityChecker   = function () {
                    if (typeof Siesta == 'undefined') return 'no-siesta'

                    try {
                        if (typeof Siesta.Project.Browser.Automation == 'undefined') return 'no-automation'
                    } catch (e) {
                        return 'no-automation'
                    }

                    return 'success'
                }

                me.executeSmallScriptPromised(
                    'return (' + sanityChecker.toString() + ')()',
                    true
                ).then(function (result) {
                    // IE can just throw exception when trying execute script on 404 page, result will be null/undefined in this case
                    if (result != 'success') {
                        var error   = errorCodes[ result ]

                        if (error) me.printError(error)

                        callback(5)

                        return
                    }

                    callback()
                })
            })
        },


        // promised method
        executeSmallScriptPromised : function (text, ignoreException) {
            throw new Error("Abstract method call: `executeSmallScriptPromised`")
        }
    }
    // eof methods
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Runner.BaseRunner', {

    does : [
        JooseX.Observable,
        Siesta.Launcher.Role.CanPrintWithLauncher
    ],


    has : {
        launcher                    : { required : true },
        dispatcher                  : null,

        // indicates the max number of pages (but not guarantees that number of pages can be created)
        // runner always should be able to create at least one page!
        maxWorkers                  : 1,

        pageCount                   : 0,
        reservedPageCount           : 0,
        pages                       : Joose.I.Object,

        pagesPerChunk               : 20,

        pageCreationFailuresCount   : 0,

        isPageCreationPaused        : false,
        pauseTimeout                : null,

        resolveBeforeDestroy        : Joose.I.Array
    },


    methods : {

        pausePageCreation : function (timeout, callback) {
            var me                      = this

            this.isPageCreationPaused   = true

            clearTimeout(this.pauseTimeout)

            this.pauseTimeout           = setTimeout(function () {
                me.isPageCreationPaused = false

                callback && callback()
            }, timeout)
        },


        getPageIdList : function () {
            var ids     = []

            Joose.O.each(this.pages, function (page, id) { ids.push(id) })

            return ids
        },


        reserveOnePage : function () {
            if (!this.canCreatePage()) return false

            this.reservedPageCount++

            return true
        },


        releaseReservedPage : function () {
            this.reservedPageCount--
            if (this.reservedPageCount < 0) this.reservedPageCount = 0
        },


        createPage : function (callback) {
            throw new Error("Abstract method call: `createPage`")
        },


        canCreatePage : function () {
            return this.pageCount + this.reservedPageCount < this.maxWorkers
        },


        requestPage : function (callback, arg) {
            if (!this.reserveOnePage()) return false

            var me      = this

            // `createPage` should not throw and instead return null
            this.createPage(function (e, page) {
                if (page) {
                    me.pageCreationFailuresCount    = 0

                    me.pages[ page.id ]   = page
                    me.pageCount++

                    me.releaseReservedPage()

                    page.on('close', me.onPageClosed, me, { single : true })

                    callback(page, arg)
                } else {
                    me.pageCreationFailuresCount++

                    me.releaseReservedPage()

                    callback(null, arg, e)
                }
            })

            return true
        },


        onPageClosed : function (event) {
            var page        = event.source

            delete this.pages[ page.id ]
            this.pageCount--
        },


        // promised method
        destroy : function () {
            clearTimeout(this.pauseTimeout)

            var promises    = this.resolveBeforeDestroy

            Joose.O.each(this.pages, function (page) {
                promises.push(page.close())
            })

            return Promise.all(promises)
        },


        // promised method, should never reject, but instead resolve to the instance of Error
        setup : function () {
            this.debug("Runner setup: " + this)

            return Promise.resolve(this)
        },


        // should never reject
        onPageCompleted : function (page, exception, notLaunchedById) {
            return Promise.resolve()
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.FileSystem.Base', {
    
    methods : {
        
        fileExists : function (fileName) {
            throw new Error("Abstract method call: `fileExists`")
        },
        
        
        readFile : function (fileName) {
            throw new Error("Abstract method call: `readFile`")
        },
        

        saveFile : function (fileName, content) {
            throw new Error("Abstract method call: `saveFile`")
        },
        
        
        copyFile : function (source, dest) {
            throw new Error("Abstract method call: `copyFile`")
        },
        
        
        copyTree : function (source, dest) {
            throw new Error("Abstract method call: `copyTree`")
        },
        
        
        ensurePathExists : function (path) {
            throw new Error("Abstract method call: `ensurePathExists`")
        },
        
        
        normalizePath : function (path) {
            return path
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Dispatcher.Reporter.JSON', {
    
    requires    : [ 
        'allPassed', 'getAllResults' 
    ],
    
    
    methods : {
        
        generateJsonReport : function (options) {
            var report      = {
                testSuiteName       : this.testSuiteName || '',
                
                startDate           : this.startDate,
                endDate             : this.endDate || (new Date() - 0),
                
                passed              : this.allPassed(),
                
                testCases           : this.getAllResults()
            }
            
            if (this.options.build) report.build = this.options.build
            
            return JSON.stringify(report, function (key, value) {
                if (key == 'automationElementId' || key == 'id' || key == 'parentId') return undefined
                
                return value
            })
        },
        
        
        generateJsonsReport : function (options) {
            var report      = {
                testSuiteName       : this.testSuiteName || '',
                
                startDate           : this.startDate,
                endDate             : this.endDate || (new Date() - 0),
                
                passed              : this.allPassed(),
                
                testCases           : this.getAllResultsStructured().items
            }
            
            if (this.options.build) report.build = this.options.build
            
            return JSON.stringify(report, function (key, value) {
                if (key == 'automationElementId' || key == 'groups' || key == 'id' || key == 'parentId') return undefined
                
                return value
            })
        },
        
        
        generateHtmlReport : function (options) {
            return this.generateJsonsReport(options)
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Dispatcher.Reporter.JUnit', {

    requires    : [
        'forEachAssertion', 'getAllResults'
    ],


    methods : {

        convertDateToISO8601 : function (date) {
            var prependZeroIfNeeded = function (number, howMany) {
                if (!howMany || howMany == 1) return number < 10 ? '0' + number : number

                return number < 10 ? '00' + number : number < 100 ? '0' + number : number
            }

            return date.getFullYear() + '-' + prependZeroIfNeeded(date.getMonth() + 1) + '-' + prependZeroIfNeeded(date.getDate()) +
                'T' + prependZeroIfNeeded(date.getHours()) + ':' + prependZeroIfNeeded(date.getMinutes()) + ':' + prependZeroIfNeeded(date.getSeconds()) +
                '.' + prependZeroIfNeeded(date.getMilliseconds(), 2)

        },


        generateJunitReport : function (options) {
            options                 = options || {}
            var me                  = this

            var testSuiteNode       = new Siesta.Util.XMLNode({
                tag         : 'testsuite',

                attributes  : {
                    name        : this.testSuiteName || this.options.build || 'No title',
                    timestamp   : this.convertDateToISO8601(new Date(this.startDate)),
                    time        : ((this.endDate || new Date()) - this.startDate) / 1000,
                    hostname    : this.hostName || ''
                }
            })

            var properties          = options.properties

            if (properties) {
                var propertiesNode  = testSuiteNode.appendChild({
                    tag         : 'properties'
                })

                Joose.O.each(properties, function (value, name) {
                    propertiesNode.appendChild({
                        tag         : 'property',

                        attributes  : {
                            name        : name,
                            value       : value
                        }
                    })
                })
            }

            var totalTests      = 0
            var totalErrors     = 0
            var totalFailures   = 0

            Joose.A.each(this.getAllResults(), function (testInfo) {
                totalTests++

                var testCaseNode    = new Siesta.Util.XMLNode({
                    tag             : 'testcase',

                    attributes      : {
                        name        : testInfo.url,
                        classname   : testInfo.jUnitClass || ''
                    }
                })

                if (testInfo.ERROR) {
                    totalErrors++

                    testCaseNode.appendChild({
                        tag             : 'error',
                        textContent     : testInfo.ERROR
                    })

                } else {
                    if (testInfo.sessionId != null) testCaseNode.setAttribute('sessionId', testInfo.sessionId)

                    testCaseNode.setAttribute('time', (testInfo.endDate - testInfo.startDate) / 1000)

                    var hasException        = false
                    var totalAssertions     = 0
                    var failedAssertions    = 0

                    me.forEachAssertion(testInfo, function (assertion) {
                        totalAssertions++

                        if (!assertion.passed) {
                            failedAssertions++

                            if (assertion.isException) {
                                totalErrors++

                                hasException    = true

                                testCaseNode.appendChild({
                                    tag             : 'error',
                                    attributes      : {
                                        type        : assertion.exceptionType
                                    },
                                    textContent     : assertion.annotation
                                })
                            } else
                                testCaseNode.appendChild({
                                    tag         : 'failure',

                                    attributes  : {
                                        message     : assertion.description || '',
                                        type        : assertion.name || 'FAIL'
                                    },

                                    textContent : assertion.annotation || ''
                                })
                        }
                    }, me, { ignoreTodoAssertions : true })

                    testCaseNode.setAttribute('totalAssertions', totalAssertions)
                    testCaseNode.setAttribute('failedAssertions', failedAssertions)

                    // test has failed, but w/o exception - some other reason
                    if (!hasException && !testInfo.passed) totalFailures++
                }

                testSuiteNode.appendChild(testCaseNode)
            })

            testSuiteNode.setAttribute('tests', totalTests)
            testSuiteNode.setAttribute('errors', totalErrors)
            testSuiteNode.setAttribute('failures', totalFailures)

            return testSuiteNode + ''
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Dispatcher.Reporter.TeamCity', {

    has : {
        tcSuiteName     : null,

        tcEncodeRegExp  : /(['\[\]|])/g,

        testSuiteStartPrinted       : false,
        testSuiteFinishPrinted      : false,

        teamCityPrintState          : Joose.I.Object
    },


    override : {

        initialize : function () {
            var me      = this

            this.launcher.on('destroy', function () {
                if (me.testSuiteStartPrinted && !me.testSuiteFinishPrinted) me.tcPrintTestSuiteFinish()
            })

            this.SUPER()
        },


        warn : function (text) {
            this.tcPrint('message', { text : text, status : 'WARNING' })

            this.SUPERARG(arguments)
        },


        onTestSuiteStart : function (userAgent, platform) {
            var browserInfo     = this.parseBrowser(userAgent)

            this.tcSuiteName    = this.options[ 'tc-suite' ] || (
                (this.testSuiteName ? this.testSuiteName + ': ' : '') + browserInfo.name + ' ' + browserInfo.version
            )

            this.tcPrint('testSuiteStarted', { name : this.tcSuiteName })

            this.SUPERARG(arguments)

            this.testSuiteStartPrinted  = true
        },


        onTestSuiteEnd : function () {
            this.SUPER()

            this.tcPrintTestSuiteFinish()
        },


        printTestBody : function (testResult) {
            if (testResult.ERROR)
                this.tcPrint('testFailed', { name : this.getTcTestName(testResult), details : testResult.ERROR })

            this.SUPERARG(arguments)
        },


        printTestHeader : function (testResult) {
            this.tcPrint('testStarted', { name : this.getTcTestName(testResult) })

            this.SUPERARG(arguments)
        },


        printTestFooter : function (testResult) {
            this.SUPERARG(arguments)

            var duration        = testResult.endDate - testResult.startDate

            this.tcPrint('testFinished', { name : this.getTcTestName(testResult), duration : duration })
        },


        printAssertionInfo : function (assertion, parentTests, printState) {
            this.SUPERARG(arguments)

            switch (assertion.type) {
                case 'Siesta.Result.Assertion' :
                    if (!assertion.isTodo && (assertion.isException || !assertion.passed)) {
                        var text        = this.getAssertionText(assertion)

                        text            = this.getFormattedAssertionText(text, assertion, parentTests, this.teamCityPrintState, true)

                        if (parentTests[ 0 ]) {
                            this.tcPrint('testFailed', { name : this.getTcTestName(parentTests[ 0 ]), details : text })
                        }
                        // TODO: no parentTests case happens (if preloads are missing) ..still show the assertion w/ some made up test identifier
                        else {
                            this.tcPrint('testFailed', { name : '.fail.' + assertion.index + '.' + Date.now(), details : text })
                        }
                    }
                    break;

                case 'Siesta.Result.Diagnostic' :
                    if (assertion.isWarning) {
                        var text        = this.getAssertionText(assertion)
                        text            = this.getFormattedAssertionText(text, assertion, parentTests, {}, true)

                        this.tcPrint('message', { text : text, status : 'WARNING' })
                    }
                    break;
            }
        }
    },


    methods : {

        tcPrintTestSuiteFinish : function () {
            var duration        = this.endDate - this.startDate

            this.tcPrint('testSuiteFinished', { name : this.tcSuiteName, duration : duration })

            this.testSuiteFinishPrinted = true
        },


        tcPrint : function(messageName, attributes) {
            attributes = attributes || {}

            var text = '##teamcity[' + messageName

            for (var name in attributes) {
                text += ' ' + name + "='" + this.tcEncode(attributes[name]) + "'"
            }

            text += ']'

            this.print(text)
        },


        getTcTestName : function (testResult, encode) {
            // the leading dot here is needed to fix a bug in TeamCity, where if a build has a single failed test
            // that has dots in the name, the name of that test will be partly included in the test suite name:
            // http://teamcity.bryntum.com/viewLog.html?buildId=81389&tab=buildResultsDiv&buildTypeId=Siesta_SiestaFirefoxTests
            var testName = '.' + (testResult.name || testResult.url)

            return encode ? this.tcEncode(testName) : testName
        },


        tcEncode : function (text) {
            return String(text).replace(this.tcEncodeRegExp, '|$1').replace(/\r/g, '|r').replace(/\n/g, '|n')
        }
    }

})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Dispatcher.Reporter', {

    requires    : [
        'forEachAssertion'
    ],


    does    : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Util.Role.CanParseOs,
        Siesta.Util.Role.CanParseBrowser,

        Siesta.Launcher.Role.CanPrintWithLauncher,

        Siesta.Launcher.Dispatcher.Reporter.JSON,
        Siesta.Launcher.Dispatcher.Reporter.JUnit
    ],


    has : {
        stringificationCache    : Joose.I.Object
    },


    methods : {

        onTestSuiteStart : function (userAgent, platform) {
            this.printTestSuiteHeader(userAgent, platform)
        },


        onTestSuiteEnd : function () {
            this.printTestSuiteSummaryMessage()
        },


        onPageInactivityTimeout : function (elId, inactivityTimeout) {
            var message     = "Inactivity timeout " + inactivityTimeout + 'ms has been exceeded'

            if (elId) {
                var el      = this.getElementById(elId)

                message     += ' during test: ' + el.descId + ', restarting'
            }

            this.warn(message)
        },


        onCanNotRunElement : function (el) {
            this.warn("Can not reach the end of the test: " + el.descId + ", test is marked as failed")

            this.printTestResult(el)
        },


        printTestSuiteHeader : function (userAgent, platform) {
            var browserInfo     = this.parseBrowser(userAgent)

            var agentString     = typeof process != 'undefined' ? ", agent: " : ", browser: "

            this.print(
                "Launching test suite, OS: " + this.parseOS(platform) + agentString + browserInfo.name + " " + browserInfo.version
            )
        },


        printTestSuiteSummaryMessage : function () {
            this.print(this.getAutomatedSummaryMessage())
        },


        stringifyAssertion : function (info) {
            var type        = info.type
            if (!type) throw new Error("Can't strigify assertion : " + JSON.stringify(info))

            var instance    = this.stringificationCache[ type ]

            if (!instance) {
                instance    = this.stringificationCache[ type ] = new (Joose.S.strToClass(type))({})
            }

            // other properties will always present in the assertion info so no need to cleanup them
            Joose.A.each([ 'isTodo', 'isWaitFor', 'isException', 'sourceLine', 'name', 'annotation', 'exceptionType' ], function (name) {
                instance[ name ] = null
            })

            Joose.O.extend(instance, info)

            return instance.toString()
        },


        getFormattedAssertionText : function (text, assertion, parentTests, printState, noColor) {
            var launcher            = this.launcher

            // 4.0.x compatibility, early exit
            if (this.options[ 'flat-output' ]) return launcher.prepareText(text, false, 0, noColor)

            var output              = ''

            var printedParents      = printState.printedParents || []
            var printing            = false

            for (var indent = 1; indent < parentTests.length; indent++) {
                if (printing || parentTests[ indent ] != printedParents[ indent ]) {
                    printing        = true

                    output          += launcher.prepareText(
                        this.styled(parentTests[ indent ].name, 'bold'),
                        true,
                        indent - 1,
                        noColor
                    )
                }
            }

            printState.printedParents = parentTests

            output                  += launcher.prepareText(text, false, parentTests.length - 1, noColor)

            return output
        },


//        printAssertionText : function (text, assertion, parentTests, printState) {
//            var printMethod     = assertion.type == 'Siesta.Result.Diagnostic' && assertion.isWarning ? 'warn' : 'print'
//
//            if (this.options[ 'flat-output' ])
//                // 4.0.x compatibility
//                this[ printMethod ](text)
//            else {
//                var printedParents          = printState.printedParents || []
//
//                var printing                = false
//
//                for (var indent = 1; indent < parentTests.length; indent++) {
//                    if (printing || parentTests[ indent ] != printedParents[ indent ]) {
//                        printing            = true
//
//                        this.print(this.styled(parentTests[ indent ].name, 'bold'), indent - 1)
//                    }
//                }
//
//                printState.printedParents   = parentTests
//
//                this[ printMethod ](text, parentTests.length - 1)
//            }
//        },


        getAssertionText : function (assertion) {
            var text            = this.stringifyAssertion(assertion)

            if (assertion.type == 'Siesta.Result.Assertion') {
                if (assertion.isException && !assertion.isTodo) {
                    text        = this.style().bold(this.style().red(text))
                } else if (assertion.isTodo) {
                    text        = this.styled(text, assertion.passed ? 'magenta' : 'yellow')
                } else {
                    text        = this.styled(text, assertion.passed ? 'green' : 'red')
                }
            }

            if (assertion.type == 'Siesta.Result.Diagnostic') {
                if (assertion.isWarning)
                    text        = this.styled('[WARN] ', 'red') + text
                else
                    text        = this.styled(text, 'bold')
            }

            return text
        },


        needToShowAssertion : function (assertion) {
            if (this.options.verbose) return true

            var needToShow      = false

            if (assertion.type == 'Siesta.Result.Assertion') {
                if (assertion.isException && !assertion.isTodo) {
                    needToShow  = true
                } else if (assertion.isTodo) {
                    if (assertion.passed && !assertion.isWaitFor) needToShow = true

                } else {
                    if (!assertion.passed) needToShow = true
                }
            }

            if (assertion.type == 'Siesta.Result.Diagnostic') {
                if (assertion.isWarning)
                    needToShow  = true
            }

            return needToShow
        },


        printAssertionInfo : function (assertion, parentTests, printState) {
            printState          = printState || {}

            if (this.needToShowAssertion(assertion)) {
                var text        = this.getAssertionText(assertion)

                this.print(this.getFormattedAssertionText(text, assertion, parentTests, printState, false))
            }
        },


        printTestResult: function (el, isAfterReRun, streamAssertions) {
            var testResult      = el.result

            // in case of "streamAssertions" header has been already printed
            if (!streamAssertions) this.printTestHeader(testResult)

            // in case of "streamAssertions" body has been already printed unless "ERROR" is present
            if (!streamAssertions || testResult.ERROR) this.printTestBody(testResult)

            // footer should be printed always
            this.printTestFooter(testResult, isAfterReRun)

            el.resultPrinted    = true
        },


        printTestHeader : function (testResult) {
        },


        printTestBody : function (testResult) {
            if (!testResult.ERROR) {
                this.printSubTestResult(testResult)
            }
        },


        printSubTestResult : function (testResult, parentTests, printState) {
            parentTests                 = parentTests || []
            printState                  = printState || {}

            parentTests.push(testResult)

            for (var i = 0; i < testResult.assertions.length; i++) {
                var assertion           = testResult.assertions[ i ]

                if (assertion.type == 'Siesta.Result.Assertion' || assertion.type == 'Siesta.Result.Diagnostic')
                    this.printAssertionInfo(assertion, parentTests, printState)

                if (assertion.type == 'Siesta.Result.SubTest') {
                    this.printSubTestResult(assertion, parentTests.slice(), printState)
                }
            }
        },


        printStreamedUpdate : function (update, printState) {
            if (update.type == 'Siesta.Result.Assertion' || update.type == 'Siesta.Result.Diagnostic') {
                var parentTests     = []

                var parent          = this.getParentOfStreamedUpdate(update)

                while (parent) {
                    parentTests.unshift(parent)

                    parent          = this.getParentOfStreamedUpdate(parent)
                }

                this.printAssertionInfo(update, parentTests, printState)
            }
        },


        printTestFooter : function (testResult, isAfterReRun) {
            var isPassed        = testResult.passed

            this.print(
                '['
                + (
                    isPassed
                        ?
                    this.styled(Siesta.Resource('Siesta.Role.ConsoleReporter', 'passText'), isAfterReRun ? 'yellow' : 'green')
                        :
                    this.styled(Siesta.Resource('Siesta.Role.ConsoleReporter', 'failText'), 'red')
                )
                + ']  ' + testResult.url + (isPassed ? '' : '\n')
            )
        },


        getAutomatedSummaryMessage : function () {
            var testCases           = this.getAllResults()

            var testsTotal          = testCases.length
            var testsFailed         = 0

            var assertionsTotal     = 0
            var assertionsFailed    = 0

            var todoPassed          = 0
            var todoFailed          = 0

            var timeTotal           = (this.endDate || new Date) - this.startDate

            var durationStr         = timeTotal + 'ms'

            if (timeTotal >= 1000) {
                timeTotal           = timeTotal / 1000
                durationStr         = timeTotal + 's'

                if (timeTotal >= 60) {
                    durationStr     = Math.floor(timeTotal / 60) + 'm ' + Math.floor(timeTotal % 60) + 's'
                    timeTotal       = timeTotal / 60

                    if (timeTotal >= 60) {
                        durationStr = Math.floor(timeTotal / 60) + 'h ' + Math.floor(timeTotal % 60) + 'm'
                    }
                }
            }

            for (i = 0; i < testCases.length; i++) {
                var testInfo    = testCases[ i ]

                if (testInfo.ERROR) {
                    testsFailed++
                } else {
                    if (!testInfo.passed) testsFailed++

                    this.forEachAssertion(testInfo, function (assertion) {
                        if (assertion.isTodo) {
                            assertion.passed ? todoPassed++ : todoFailed++
                        } else {
                            assertionsTotal++

                            if (!assertion.passed) assertionsFailed++
                        }
                    })
                }
            }

            return this.formatString([
                '{assertionsPassed} passed, {assertionsFailed} failed assertions took {!timeTotal} to complete'
            ].join('\n'), {
                testsFailed             : testsFailed,
                testsPassed             : testsTotal - testsFailed,
                testsTotal              : testsTotal,

                timeTotal               : durationStr,

                assertionsTotal         : assertionsTotal,
                assertionsPassed        : assertionsTotal - assertionsFailed,
                assertionsFailed        : assertionsFailed,

                todoPassed              : todoPassed,
                todoFailed              : todoFailed
            })
        },


        generateReport : function (options) {
            // a string?
            if (Object(options) !== options) options = { format : options || 'json' }

            var methodName  = 'generate' + Joose.S.uppercaseFirst(options.format) + 'Report'

            if (!this[ methodName ]) throw "Can't generate report - missing the `" + methodName + "` method"

            return this[ methodName ](options)
        }

    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Dispatcher.TaskQueue', {

    requires        : [
        'onCanNotRunElement'
    ],

    has : {
        structure               : null,
        sharedContextGroups     : null,
        regularTestsGroup       : null,

        streamedUpdatesHash     : Joose.I.Object
    },


    methods : {

        getAllResults : function () {
            var results     = []

            this.forEachTestElement(function (el) {
                // result can be missing in case of early test suite finalization on "breakOnFail"
                if (el.result) results.push(el.result)
            })

            return results
        },


        getAllResultsStructured : function (structurePoint) {
            var isSeedingCall   = !arguments.length
            structurePoint      = isSeedingCall ? this.structure : structurePoint

            if (structurePoint.group) {
                var me      = this
                var items   = []

                Joose.A.each(structurePoint.items, function (point) {
                    var res = me.getAllResultsStructured(point)

                    if (res) items.push(res)
                })

                return items.length || isSeedingCall ? {
                    group   : structurePoint.group,
                    items   : items
                } : null

            } else {
                var el      = this.getElementByDescId(structurePoint)

                if (el) {
                    return el.result
                } else
                    return null
            }
        },


        allPassed : function () {
            var allPassed       = true

            this.forEachTestElement(function (el) {
                // if some element has not been processed yet, or for some element
                // the test result is missing - then it is treated as failure
                if (!el.processed || !el.result || !el.result.passed) { allPassed = false; return false }
            })

            return allPassed
        },


        allDone : function () {
            var allDone     = true

            this.forEachTestElement(function (el) {
                if (!el.processed) { allDone = false; return false }
            })

            return allDone
        },


        forEachTestElement : function (func, scope) {
            scope       = scope || this

            var res     = Joose.A.each(this.sharedContextGroups, function (sharedGroup) {
                return sharedGroup.forEachElement(func, scope)
            })

            if (res === false) return false

            return this.regularTestsGroup.forEachElement(func, scope)
        },


        consumeStreamedUpdate : function (update, page) {
            var pageId              = page.id

            if (update.id)
                update.id           = pageId + update.id

            if (update.parentId)
                update.parentId     = pageId + update.parentId

            if (update.id)
                this.streamedUpdatesHash[ update.id ] = update

            return update
        },


        getStreamedUpdate : function (id) {
            return this.streamedUpdatesHash[ id ]
        },


        getParentOfStreamedUpdate : function (update) {
            return update.parentId ? this.streamedUpdatesHash[ update.parentId ] : null
        },


        consumeTestResult : function (testResult, page) {
            var el          = this.getElementById(testResult.automationElementId)
            var sessionId   = page.getSessionId()

            if (sessionId != null) testResult.sessionId = sessionId

            el.endProgress(testResult)

            return el
        },


        // [ { descId : descId, automationElementId : elId }, ... ]
        releaseChunkTask : function (chunkTask, notLaunchedById) {
            this.forEachTestElementInChunkTask(chunkTask, function (el, group) {
                if (el.inProgress) {
                    // as the 2nd arg, `releaseChunkTask` can receive either null, `true`
                    // or object values
                    var thereWasNoError     = notLaunchedById === true ? true : notLaunchedById && notLaunchedById[ el.id ]

                    // thereWasNoError means the element was not even attempted to launch, for example, it is at the end of the
                    // tests list, and chunk has been terminated in the middle, this does not count as an attempt to run the
                    // element
                    if (el.reset(thereWasNoError)) this.onCanNotRunElement(el, group)
                }
            })
        },


        // returns true if chunk "passes" (all tests in it passed) Some tests may still be failed,
        // because we allow re-run on exceptions (maxProcessedCount) and re-run on failure (reRunFailed)
        // those tests will be executed again, in a different chunk, which will be marked as failed
        chunkPassed : function (chunkTask, notLaunchedById) {
            var passed      = true

            this.forEachTestElementInChunkTask(chunkTask, function (el, group) {
                if (el.inProgress) {
                    // as the 2nd arg, `releaseChunkTask` can receive either null, `true`
                    // or object values
                    var thereWasNoError     = notLaunchedById === true ? true : notLaunchedById && notLaunchedById[ el.id ]

                    // thereWasNoError means the element was not even attempted to launch, for example, it is at the end of the
                    // tests list, and chunk has been terminated in the middle, this does not count as an attempt to run the
                    // element
                    // thereWasNoError == false indicates there were an attempt to launch the element (test), but it is still marked
                    // as `inProgress` which means there were some infrastructure problem during the test
                    // it happens sometimes, we allow (maxProcessedCount) attempts
                    if (!thereWasNoError && !el.canRunAgain(true)) {
                        passed      = false
                        return false
                    }
                } else
                    if (!el.result.passed) {
                        passed      = false
                        return false
                    }
            })

            return passed
        },


        forEachTestElementInChunkTask : function (chunkTask, func, scope) {
            var me          = this

            scope           = scope || this

            Joose.A.each(chunkTask, function (scopeTask) {
                var elGroup = me.getElementById(scopeTask.automationElementId, true)

                if (func.call(scope, elGroup.el, elGroup.group) === false) return false
            })
        },


        // chunk - a set of tests each with own sandbox (iframe), all runs on the same project page
        getChunkTask : function (pagesPerChunk) {
            var chunk       = []

            for (var i = 0; i < pagesPerChunk; i++) {
                var scopeTask       = this.getScopeTask()

                if (scopeTask)
                    chunk.push.apply(chunk, scopeTask)
                else
                    break
            }

            return chunk.length ? chunk : null
        },


        // scope task - a set of tests for 1 sandbox (1 iframe), normally only 1 test, but can be more in case of
        // disabled sandboxing
        getScopeTask : function () {
            var me          = this

            var toProcess

            Joose.A.each(this.sharedContextGroups, function (group) {
                toProcess   = group.fetchNSpareElements(1e10, true)

                if (toProcess) return false
            })

            if (toProcess) return toProcess

            return this.regularTestsGroup.fetchNSpareElements(1, true)
        },


        getElementById : function (id, withGroup) {
            var el
            var group

            Joose.A.each(this.sharedContextGroups, function (sharedGroup) {
                if (el = sharedGroup.getElementById(id)) {
                    group   = sharedGroup

                    return false
                }
            })

            if (el) return withGroup ? { el : el, group : group } : el

            el      = this.regularTestsGroup.getElementById(id)

            return withGroup ? { el : el, group : this.regularTestsGroup } : el
        },


        getElementByDescId : function (id, withGroup) {
            var el
            var group

            Joose.A.each(this.sharedContextGroups, function (sharedGroup) {
                if (el = sharedGroup.getElementByDescId(id)) {
                    group   = sharedGroup

                    return false
                }
            })

            if (el) return withGroup ? { el : el, group : group } : el

            el      = this.regularTestsGroup.getElementByDescId(id)

            return withGroup ? { el : el, group : this.regularTestsGroup } : el
        },


        reviseFailedTests : function () {
            var totalCount      = 0
            var failedCount     = 0

            this.forEachTestElement(function (el, group) {
                totalCount++

                var result  = el.result

                // don't count tests that finalized with ERROR
                if (!result.ERROR && !result.passed) failedCount++
            })

            if (failedCount <= Math.max(totalCount * 0.1, 1))
                this.forEachTestElement(function (el, group) {
                    var result  = el.result

                    if (!result.ERROR && !result.passed && el.canRunAgain()) el.setProcessed(false)
                })
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Dispatcher', {

    does        : [
        Siesta.Launcher.Dispatcher.TaskQueue,
        Siesta.Launcher.Dispatcher.Reporter,

        Siesta.Launcher.Role.CanPrintWithLauncher,
        Siesta.Launcher.Role.CanLaunchSimulatorServer,

        Siesta.Launcher.Role.CanLaunchInstrumentationProxy,

        Siesta.Util.Role.CanGetType
    ],


    has : {
        launcher                : { required : true },
        // an array of runners created by the launcher for this dispatcher
        // idea is that some of them can fail on the "setup" step, so those who successeded
        // will be in the "runners" attribute
        givenRunners            : { required : true },
        // code was originally written for multiple runners, then it turned out, its never used
        // (always only one runner), but we still keep it this way, in case we go crazy and will
        // support several runners, like BS and SL in the same time
        runners                 : Joose.I.Array,

        options                 : { is : 'rw', init : Joose.I.Object },

        projectUrl              : { required : true },

        testSuiteName           : null,
        // is used for JUnit report (only)
        hostName                : null,

        startDate               : null,
        endDate                 : null,

        allDoneCallback         : null,

        screenshotCompareConfig : null,

        reRunFailed             : false,

        projectConfig           : null,

        streamAssertions        : false,
        printState              : Joose.I.Object,

        breakOnFail             : false,
        forceExit               : false,

        wsServer                : null,

        hasNativeSimulation     : false
    },


    methods : {

        addRunner : function (runner) {
            this.runners.push(runner)

            runner.dispatcher       = this
            runner.maxWorkers       = this.options[ 'max-workers' ] || runner.maxWorkers
            // the `page-size` name is deprecated
            runner.pagesPerChunk    = this.options[ 'chunk-size' ] || this.options[ 'page-size' ] || runner.pagesPerChunk
        },


        // promised method
        finalizeCommand : function (command, page, result) {
            var me      = this

            return page.executeSmallScriptPromised(
                "return Siesta.my.activeHarness.onCommandDone(" + command.id + ", " + JSON.stringify(result) + ")"
            ).then(function (e) {
                if (e) me.printError("ERROR DURING COMMAND FINALIZATION: " + e)
            }, function (e) {
                me.printError("ERROR DURING COMMAND FINALIZATION: " + e)
            })
        },


        // promised method
        // all commands supposed to resolve to object with { success : true/false }, { error : String } (if failed)
        // plus some other properties
        executeCommandFromPage : function (command, page) {
            var me      = this

            me.debug("Received command: " + JSON.stringify(command))

            if (!page[ command.name ]) {
                return me.finalizeCommand({ success : false, error : 'unknown command' })
            }

            return page[ command.name ](command).then(function (res) {
                return me.finalizeCommand(command, page, res)
            }, function (e) {
                me.printError(JSON.stringify(e))

                return me.finalizeCommand(command, page, { success : false, error : e + '' })
            })
        },


        canPrintUpdateImmediately : function (update) {
            return !this.reRunFailed || this.options.verbose || update.type == 'Siesta.Result.Diagnostic'
                || update.type == 'Siesta.Result.Assertion' && (update.passed || update.isTodo)
        },


        // promised method
        consumeTestStateUpdate : function (state, page) {
            var me              = this

            if (me.forceExit) return 'force_exit'

            var failed          = false

            if (this.streamAssertions) {
                var eventLog        = state.eventLog

                eventLog && Joose.A.each(eventLog, function (event) {
                    if (event.isLog) {
                        if (me.typeOf(event.data) == 'String')
                            me.print(event.data)
                        else
                            me.warn(event.data.text)
                    } else if (event.isUpdate) {
                        var update      = me.consumeStreamedUpdate(event.data, page)

                        if (update.type == 'Siesta.Result.Assertion' && !update.passed && !update.isTodo) failed = true

                        // top level Siesta.Result.SubTest instance
                        if (update.type == 'Siesta.Result.SubTest' && !update.parentId) me.printTestHeader(update)

                        if (me.canPrintUpdateImmediately(update)) me.printStreamedUpdate(update, me.printState)
                    } else if (event.isResult) {
                        var el          = me.consumeTestResult(event.data, page)

                        if (el.result.ERROR || !el.result.passed && !el.result.isTodo) failed = true

                        if (!me.reRunFailed || el.canPrintResultImmediately()) me.printTestResult(el, false, true)
                    }
                })

            } else {
                var log             = state.log

                log && Joose.A.each(log, function (logElement) {
                    if (me.typeOf(logElement) == 'String')
                        me.print(logElement)
                    else
                        me.warn(logElement.text)
                })

                var testResults     = state.testResults

                testResults && Joose.A.each(testResults, function (testResult) {
                    var el          = me.consumeTestResult(testResult, page)

                    if (el.result.ERROR || !el.result.passed && !el.result.isTodo) failed = true

                    // do not print failed tests in case of "reRunFailed" is enabled
                    if (!me.reRunFailed || el.canPrintResultImmediately()) me.printTestResult(el)
                })
            }

            if (me.options.coverage) {
                var nyc     = this.getNyc()

                state.coverageResult && state.coverageResult.forEach(function (coverage) {
                    me.nycWriteCoverageFile(nyc, coverage)
                })
            }

            var commands        = state.commands
            var promise         = Promise.resolve()

            // a command has been send from the test page
            commands && Joose.A.each(commands, function (command) {
                promise         = promise.then(function () {
                    return me.executeCommandFromPage(command, page)
                })
            })

            return promise.then(function () {
                if (failed && me.breakOnFail) {
                    me.forceExit    = true

                    return 'force_exit'
                }

                // indicates the last state available
                if (state.exitStatus != null) {
                    if (state.exitStatus == 'focus_lost') {
                        return 'focus_lost'
                    }

                    return 'all_done'
                }
            })
        },


        launchPage : function (page, chunkTask, needToOpenHarness, runner) {
            var me      = this

            if (needToOpenHarness)
                page.openHarness(me.projectUrl, function (error) {
                    if (error) {
                        me.releaseChunkTask(chunkTask)

                        page.close().then(function () {
                            me.launchRunner(runner)
                        })
                    } else
                        runChunk()
                })
            else
                runChunk()

            function runChunk() {
                page.runChunk(chunkTask, function (e, notLaunchedById) {
                    if (me.forceExit) {
                        if (me.allDoneCallback) {
                            me.allDoneCallback({ exitCode : 1, lastPage : page })

                            me.allDoneCallback = null
                        }

                        return
                    }

                    me.releaseChunkTask(chunkTask, notLaunchedById)

                    if (me.allDone()) {
                        var reallyAllDone   = me.onAllTestsProcessed(page)

                        // note, that the last page is kept opened for coverage report generation
                        if (reallyAllDone) return
                    }

                    // ideally we need to properly close the page, before starting a new one (to conform to max-workers limitation)
                    // however, in practice "page.close()" can just hang, so in such cases we just call "page.close()"
                    // and continue
                    if (e && page.pageShouldNotBeUsedAfterException(e)) {
                        me.launchRunner(runner)
                        page.close()
                    } else
                        page.close().then(function () {
                            me.launchRunner(runner)
                        })
                })
            }
        },


        onAllTestsProcessed : function (lastPage) {
            var me      = this

            // reset the failed tests statuses
            if (me.reRunFailed) me.reviseFailedTests()

            if (me.allDone()) {
                if (me.reRunFailed) {
                    me.forEachTestElement(function (el) {
                        if (!el.resultPrinted) me.printTestResult(el, true)
                    })
                }

                me.allDoneCallback({ exitCode : me.allPassed() ? 0 : 1, lastPage : lastPage })

                return true
            }

            return false
        },


        launchRunner : function (runner, veryFirstPage) {
            var me      = this

            if (me.launcher.shutDownStarted || runner.isPageCreationPaused) return

            me.debug("Launch runner, pagesCount: " + runner.pageCount + ", max : " + runner.maxWorkers + ", pages left: " + runner.getPageIdList())

            while (veryFirstPage || runner.canCreatePage()) {
                var chunkTask   = this.getChunkTask(runner.pagesPerChunk)

                if (!chunkTask) break

                if (veryFirstPage) {
                    this.launchPage(veryFirstPage, chunkTask, false, runner)

                    veryFirstPage   = null
                } else {
                    var pageRequestAccepted = runner.requestPage(function (page, chunkTask) {
                        if (page)
                            me.launchPage(page, chunkTask, true, runner)
                        else {
                            me.releaseChunkTask(chunkTask, true)

                            if (runner.pageCreationFailuresCount >= 3) {
                                me.printError("Page creation failed after retry, test suite can not continue execution")
                                me.launcher.gracefulShutdown()
                                return
                            } else {
                                me.printError("Page creation has failed, retry in 5s")

                                runner.pausePageCreation(5000, function () {
                                    me.launchRunner(runner)
                                })
                            }
                        }
                    }, chunkTask)

                    if (!pageRequestAccepted) {
                        me.releaseChunkTask(chunkTask, true)
                        break
                    }
                }
            }
        },


        launch : function (firstRunner, veryFirstPage) {
            var me          = this

            Joose.A.each(this.runners, function (runner) {
                if (runner == firstRunner)
                    me.launchRunner(runner, veryFirstPage)
                else
                    me.launchRunner(runner)
            })
        },


        getTotalNumberOfPagesIncludingReserved : function () {
            var count   = 0

            Joose.A.each(this.runners, function (runner) {
                count   += runner.pageCount + runner.reservedPageCount
            })

            return count
        },


        forEachAssertion : function (testInfo, func, scope, options, parentTests) {
            options                     = options || {}
            scope                       = scope || this
            parentTests                 = parentTests || []

            parentTests.push(testInfo)

            var ignoreTodoAssertions    = options.ignoreTodoAssertions
            var includeDiagnostic       = options.includeDiagnostic

            for (var i = 0; i < testInfo.assertions.length; i++) {
                var assertion           = testInfo.assertions[ i ]

                if (assertion.type == 'Siesta.Result.Assertion' && (!assertion.isTodo || !ignoreTodoAssertions))
                    if (func.call(scope, assertion, parentTests) === false) return false

                if (assertion.type == 'Siesta.Result.Diagnostic' && includeDiagnostic)
                    if (func.call(scope, assertion, parentTests) === false) return false

                if (assertion.type == 'Siesta.Result.SubTest')
                    if (this.forEachAssertion(assertion, func, scope, options, parentTests.slice()) === false) return false
            }
        },


        start : function () {
            this.startDate      = new Date()

            var me              = this

            var options         = me.options

            var upstreamProxyConfig = options[ 'proxy-host' ] ? { host : options[ 'proxy-host' ], port : options[ 'proxy-port' ] } : null

            // for BS we don't need to use upstream proxy, as it is already passed to BS tunnel as --proxy-host --proxy-port
            // BS tunnel uses --local-proxy-host, --local-proxy-port for browser traffic
            if (options.coverage && options.bs) upstreamProxyConfig = null

            // setup the instrumentation proxy as the 1st thing, since its port is needed to Puppeteer runner for example
            var cont            = options.coverage ? me.setupInstrumentationProxy(upstreamProxyConfig, options.coverage) : Promise.resolve()

            return cont.then(function () {
                var promises        = []

                Joose.A.each(me.givenRunners, function (runner) {
                    runner.dispatcher   = me

                    promises.push(runner.setup())
                })

                return Promise.all(promises)
            }).then(function (results) {

                Joose.A.each(results, function (result) {
                    if (result instanceof Error)
                        me.warn("Error setting up the runner: " + result)
                    else
                        me.addRunner(result)
                })
            }).then(function () {
                if (me.runners.length == 0) {
                    me.printError("No runners available")

                    return { exitCode : 3 }
                } else {
                    me.debug("Dispatcher setup starting")

                    return me.setup(me.runners[ 0 ]).then(function (setupRes) {
                        me.debug("Dispatcher setup completed, launching the suite")

                        var config          = setupRes.config
                        var firstRunner     = setupRes.firstRunner
                        var firstPage       = setupRes.firstPage

                        return new Promise(function (resolve, reject) {
                            me.allDoneCallback = resolve

                            me.onTestSuiteStart(config.userAgent, config.platform)

                            me.launch(firstRunner, firstPage)
                        })

                    }, function (e) {
                        me.printError("Setup failed: " + e)

                        return { exitCode : e.errCode || 3 }
                    })
                }
            }).then(function (res) {
                var exitCode        = res.exitCode
                var lastPage        = res.lastPage

                me.debug("Recevied results for all tests in the suite, proceeding to finalization")

                me.endDate      = new Date()

                if (exitCode == 0 || exitCode == 1) {
                    me.onTestSuiteEnd()

                    return me.processReports(lastPage).then(function () {
                        me.debug("Reports processed (if any)")

                        if (lastPage)
                            return lastPage.close().then(function () {
                                return exitCode
                            })
                        else
                            return exitCode
                    })
                } else
                    return exitCode
            })
        },


        processReports : function (page) {
            var me          = this

            me.debug("Generating reports (if any)")

            var options     = this.options
            var launcher    = this.launcher

            var reportFile      = options.reportFile
            var reportFormat    = options.reportFormat

            if (reportFile) {
                Joose.A.each(reportFile, function (value, index) {
                    launcher.saveReport(
                        reportFormat[ index ],
                        reportFile[ index ],
                        me.generateReport({ format : reportFormat[ index ] })
                    )
                })
            }

            if (options.coverage && this.launcher.manuallyProcessCoverageResults) {
                this.nycReport(this.getNyc(), (path) => {
                    const fs        = require('fs')

                    if (fs.existsSync(path))
                        // this is for the pre-instrumented codebase
                        return fs.readFileSync(path, 'utf8')
                    else
                        return this.instrumentedSources[ path ] || 'No sources available for ' + path
                })
            }

            return Promise.resolve()
        },


        randomizeArray : function (array) {
            var randomArray     = new Array(array.length)

            array.forEach(function (el, index) {
                randomArray[ index ] = { index : index, random : Math.random() }
            })

            randomArray.sort(function (a, b) { return a.random - b.random })

            var result          = []

            randomArray.forEach(function (el) {
                result.push(array[ el.index ])
            })

            return result
        },


        setup : function (firstRunner) {
            var me              = this
            var mySiestaVersion = me.launcher.getSiestaVersion()

            var options         = me.options

            return new Promise(function (RESOLVE, REJECT) {

                firstRunner.requestPage(function (page, arg, e) {
                    if (page) {
                        page.openHarness(me.projectUrl, function (err) {
                            if (err) {
                                page.close().then(function () {
                                    var e       = new Error("Error while opening project page: " + err)
                                    e.errCode   = 5

                                    REJECT(e)
                                })
                            } else {
                                page.getConfigInfo(options[ 'include' ], options[ 'exclude' ], options[ 'filter' ], function (e, config) {
                                    if (e) {
                                        page.close().then(function () {
                                            REJECT(new Error("Error getting the test suite information: " + e))
                                        })
                                        return
                                    }

                                    if (config.VERSION && mySiestaVersion && config.VERSION != mySiestaVersion) {
                                        me.printError("Siesta version on project page [" + config.VERSION + "] does not match Siesta version of the launcher [" + mySiestaVersion + "]")

                                        page.close().then(function () {
                                            REJECT(new Error("Siesta versions mismatch"))
                                        })

                                        return
                                    }

                                    me.breakOnFail      = config.breakOnFail
                                    if (me.breakOnFail) me.reRunFailed = false

                                    me.hostName         = config.hostName
                                    me.testSuiteName    = config.title
                                    me.screenshotCompareConfig = config.screenshotCompareConfig

                                    me.structure        = config.structure

                                    var desc            = config.descriptors

                                    if (!desc.sharedContextGroups.length && !desc.mustRunSequential.length) {
                                        var style       = me.style()

                                        me.printError(
                                            "Found no tests to run. Check your project file, glob pattern,\n"
                                            + style.bold("--include") + ", " + style.bold("--exclude") + " and " + style.bold("--filter") + " command line options.\n"
                                            + "For help, launch with " + style.bold("--help")
                                        )

                                        page.close().then(function () {
                                            var err     = new Error("No tests to run")
                                            err.errCode = 4

                                            REJECT(err)
                                        })

                                        return
                                    }

                                    var maxAttempts         = Number(options[ 'restart-attempts' ]) + 1
                                    if (isNaN(maxAttempts)) maxAttempts = 2

                                    var randomize           = Boolean(options[ 'randomize-tests-order' ])

                                    me.sharedContextGroups  = Joose.A.map(desc.sharedContextGroups, function (group) {
                                        return new Siesta.Launcher.Dispatcher.Group({
                                            elements            : randomize ? me.randomizeArray(group.items) : group.items,
                                            maxProcessedCount   : maxAttempts
                                        })
                                    })

                                    me.regularTestsGroup    = new Siesta.Launcher.Dispatcher.Group({
                                        elements            : randomize ? me.randomizeArray(desc.mustRunSequential) : desc.mustRunSequential,
                                        maxProcessedCount   : maxAttempts
                                    })

                                    // TODO a global flag, saved on dispatcher instance
                                    // should instead decide per page
                                    me.hasNativeSimulation  = config.hasNativeSimulation

                                    var cont                = config.hasNativeSimulation && me.launcher.sharedNativeSimulator ? me.setupNativeEventsSimulator() : Promise.resolve()

                                    cont.then(
                                        function () {
                                            RESOLVE({ firstRunner : firstRunner, firstPage : page, config : config })
                                        },
                                        function (e) { REJECT('Error while setting up native events simulation websocket server: ' + e) }
                                    )
                                })
                            }
                        })
                        // eof page.openHarness
                    } else
                        REJECT(new Error("Can't create first page, runner: " + firstRunner + ", exception: " + e))
                })
            })
        }
        // eof setup
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Options.Base', {

    does        : [
        Siesta.Launcher.Role.CanPrintWithLauncher,
        Siesta.Launcher.Role.CanWorkWithNyc
    ],


    has         : {
        launcher        : { required : true },
        options         : { required : true, init : Joose.I.Object }
    },


    methods : {

        initialize : function () {
            this.options.WRAPPER    = this
        },


        readFile : function () {
            return this.launcher.readFile.apply(this.launcher, arguments)
        },


        printHelp : function () {
            return this.launcher.printHelp.apply(this.launcher, arguments)
        },


        validate : function () {
            var options     = this.options
            var argv        = this.launcher.argv

            if (argv.length && !options[ 'project-url' ]) options[ 'project-url' ] = argv.shift()

            if (!options[ 'project-url' ]) {
                this.printError("No project url is provided\n")

                this.printHelp()

                return false
            }

            var maxWorkers  = options[ 'max-workers' ]

            if (maxWorkers) {
                maxWorkers  = Number(maxWorkers)

                if (isNaN(maxWorkers) || maxWorkers <= 0) {
                    this.printError("The `--max-workers` should be a valid positive number\n")

                    return false
                }

                options[ 'max-workers' ]    = maxWorkers
            }

            if (options[ 'verbose' ] && maxWorkers == 1) {
                if (options[ 'rerun-failed' ]) this.warn("The --rerun-failed option is disabled because of --verbose and --max-workers=1 combination")

                options[ 'rerun-failed' ] = false
            }

            return this.validateReportOptions(options) && this.validateCoverageOptions(options)
        },


        validateReportOptions : function (options) {
            var reportFormats       = options[ 'report-format' ]
            var reportFiles         = options[ 'report-file' ]

            // nothing to validate - validation passed
            if (!reportFiles && !reportFormats) return true

            var formatsIsArray      = reportFormats instanceof Array
            var filesIsArray        = reportFiles instanceof Array

            if (
                formatsIsArray && !filesIsArray
                || !formatsIsArray && filesIsArray
                || formatsIsArray && filesIsArray && reportFormats.length != reportFiles.length
            ) {
                this.printError([
                    'The number of --report-format and --report-file options does not match'
                ]);

                return false
            }

            // at this stage, either both `reportFormats` and `reportFiles` are array or both are not

            if (!filesIsArray) {
                // here both are not

                // `report-file-prefix` is deprecated
                if (!reportFiles && options[ 'report-file-prefix' ]) {
                    reportFiles         = options[ 'report-file-prefix' ]

                    if (!reportFiles.match(/\{browser\}/)) {
                        var match       = /(.*?)\.([^.]*)$/.exec(reportFiles)

                        if (match)
                            reportFiles = match[ 1 ] + '{browser}.' + match[ 2 ]
                        else
                            reportFiles = reportFiles + '{browser}'
                    }
                }

                if (reportFormats && !reportFiles) {
                    this.printError([
                        '`--report-file` option is required, when `--report-format` option is specified'
                    ]);

                    return false
                }

                reportFiles             = [ reportFiles ]
                reportFormats           = [ reportFormats || 'json' ]
            }

            var me      = this

            var res     = Joose.A.each(reportFormats, function (reportFormat, index) {
                var res     = me.validateSingleReportOptions(reportFormats[ index ], reportFiles[ index ])

                if (res) {
                    reportFormats[ index ]  = res.reportFormat
                    reportFiles[ index ]    = res.reportFile
                } else
                    return false
            })

            // save the expanded variables
            options[ 'report-file' ]    = reportFiles
            // save the lowercased version
            options[ 'report-format' ]  = reportFormats

            return res !== false
        },


        validateSingleReportOptions : function (reportFormat, reportFile) {
            reportFormat            = reportFormat.toLowerCase()

            if (reportFormat != 'html' && reportFormat != 'json' && reportFormat != 'jsons' && reportFormat != 'junit') {
                this.printError([
                    'Unrecognized report format: ' + reportFormat
                ]);

                return false
            }

            return {
                reportFile      : this.prepareReportFileName(reportFile),
                reportFormat    : reportFormat
            }
        },


        nycOptionsHasReporter : function (positionalArgs) {
            return positionalArgs.some((arg) => { return /^--reporter/.test(arg) })
        },


        normalizeCoverageReportFormat : function (coverageReportFormats) {
            if (!(coverageReportFormats instanceof Array)) coverageReportFormats = [ coverageReportFormats ]

            Joose.A.each(coverageReportFormats, function (format, index, arr) {
                var formats     = format.split(/\+|,/)

                if (formats.length > 1) coverageReportFormats[ index ] = formats
            })

            // flatten
            coverageReportFormats       = Array.prototype.concat.apply([], coverageReportFormats)

            // map to lowercase
            coverageReportFormats       = Joose.A.map(coverageReportFormats, function (format) { return format.toLowerCase() })

            // filter out empty entries
            coverageReportFormats       = Joose.A.grep(coverageReportFormats, function (format) { return Boolean(format) })

            var knownCoverageReportFormats = [
                'clover', 'cobertura', 'html', 'json-summary', 'json', 'lcov', 'lcovonly', 'none', 'teamcity', 'text-lcov', 'text-summary', 'text'
            ]

            var me      = this

            Joose.A.each(coverageReportFormats, function (format) {
                if (knownCoverageReportFormats.indexOf(format) == -1) {
                    me.warn([ 'Unrecognized coverage report format: ' + format ]);
                }
            })

            return coverageReportFormats
        },


        validateCoverageOptions : function (options) {
            var rawNycArgv              = this.launcher.positionalGroups.nyc
            var nycArgv                 = this.buildNycArgv(rawNycArgv)

            var coverageReportFormats   = this.normalizeCoverageReportFormat(
                options[ 'coverage-report-format' ] || (this.nycOptionsHasReporter(rawNycArgv || []) ? nycArgv.reporter : [])
            )

            if (coverageReportFormats.length > 0) {
                if (options[ 'coverage-report-dir' ]) nycArgv.reportDir = options[ 'coverage-report-dir' ]

                nycArgv.reporter        = coverageReportFormats

                options.coverage        = nycArgv
            }

            return true
        },


        getReportFileNameTemplateReplacer : function () {
            var options         = this.options

            return function (m, match) {
                return options[ match ]
            }
        },


        prepareReportFileName : function (template) {
            return template.replace(/\{(\w+)\}/, this.getReportFileNameTemplateReplacer())
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Options.Simulation', {

    override : {

        validate : function () {
            var options         = this.options

            // prepare simulation config
            var simulation      = (options.simulation || '').toLowerCase()

            if (simulation && !(simulation == 'synthetic' || simulation == 'native')) {
                this.printError("Unknown value for the `simulation` config: " + options.simulation)

                return false
            }

            if (simulation) options.simulation = this.launcher.projectConfig.simulation = simulation

            return this.SUPERARG(arguments)
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Options.Proxy', {

    override : {

        validate : function () {
            if (this.SUPER() === false) return false

            var options     = this.options
            var proxy       = options.proxy

            proxy && Joose.O.extend(options, this.parseProxyShortcut(proxy))

            return true
        }
    },

    methods : {

        parseProxyShortcut : function (str) {
            var res         = {}
            var match       = /(?:(.+?)(?:\:(.+))?@)?(.*)/.exec(str)

            if (match) {
                res[ 'proxy-user' ]     = match[ 1 ]
                res[ 'proxy-password' ] = match[ 2 ] || null
                str                     = match[ 3 ]
            }

            var match       = /(.+):(\d+)/.exec(str)

            if (match) {
                res[ 'proxy-host' ] = match[ 1 ]
                res[ 'proxy-port' ] = match[ 2 ]
            } else
                res[ 'proxy-host' ] = str

            return res
        },


        getProxyHostPort : function () {
            var options     = this.options
            var host        = options[ 'proxy-host' ]
            var port        = options[ 'proxy-port' ]

            if (host)
                return host + (port ? ':' + port : '')
            else
                return null
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Options.BrowserStack', {

    override : {

        getBrowserName : function () {
            var options         = this.options

            var res             = this.SUPER()

            return res || options.caps.browser
        },


        validate : function () {
            if (this.SUPER() === false) return false

            var options             = this.options

            var bsUserName          = options[ 'browserstack-user' ]
            var bsKey               = options[ 'browserstack-key' ]

            var bsShortCut          = options[ 'browserstack' ] || options[ 'browserstack_' ]

            if (bsShortCut) {
                // options w/o values gets `new Boolean(true)` as value
                var parts           = ((bsShortCut instanceof Boolean) && (bsShortCut == true) ? '' : bsShortCut).split(',')

                bsUserName          = parts.shift() || process.env.BS_USER
                bsKey               = parts.shift() || process.env.BS_KEY

                if (!bsUserName) {
                    this.printError("No BrowserStack user name found for --browserstack shortcut")
                    return false
                }
            }

            if (bsUserName && !bsKey) {
                this.printError("No BrowserStack key provided, for user name: " + bsUserName)
                return false
            }

            if (bsUserName && bsKey) {
                if (options.host) {
                    this.printError("BrowserStack mode is enaled, but host is already set to: " + options.host)
                    return false
                }

                options.host        = "http://" + bsUserName + ":" + bsKey + "@hub.browserstack.com/wd/hub"
                options.port        = 4444

                this.debug("--host set to " + options.host.replace(bsKey, 'BROWSERSTACK_API_KEY'))

                options.bs          = {
                    userName        : bsUserName,
                    key             : bsKey,
                    shortCut        : bsShortCut,
                    noTunnel        : Boolean(options[ 'browserstack_' ])
                }

                if (!options.caps[ 'browserstack.local' ])
                    this.addCapability('browserstack.local', 'true')

                if (options.build)
                    this.addCapability('build', options.build)
            }

            return true
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.Options.SauceLabs', {

    override : {

        validate : function () {
            if (this.SUPER() === false) return false

            var options             = this.options

            var slUserName          = options[ 'saucelabs-user' ]
            var slKey               = options[ 'saucelabs-key' ]
            var slTunneledDomains

            var slShortCut          = options[ 'saucelabs' ] || options[ 'saucelabs_' ]

            if (slShortCut) {
                // options w/o values gets `new Boolean(true)` as value
                var parts           = ((slShortCut instanceof Boolean) && slShortCut == true ? '' : slShortCut).split(',')

                slUserName          = parts.shift() || process.env.SL_USER
                slKey               = parts.shift() || process.env.SL_KEY

                slTunneledDomains   = parts.join(',') || process.env.SL_TUNNEL

                if (!slUserName) {
                    this.printError("No SauceLabs user name found for --saucelabs shortcut")
                    return false
                }
            }

            if (slUserName && !slKey) {
                this.printError("No SauceLabs api key provided, for user name: " + slUserName)
                return false
            }

            if (slUserName && slKey) {
                if (options.host) {
                    this.printError("SauceLabs mode is enaled, but host is already set to: " + options.host)
                    return false
                }

                options.host        = "http://" + slUserName + ":" + slKey + "@ondemand.saucelabs.com:80/wd/hub"
                options.port        = 4444

                this.debug("--host set to " + options.host.replace(slKey, 'SAUCELABS_API_KEY'))

                options.sl          = {
                    userName        : slUserName,
                    key             : slKey,
                    shortCut        : slShortCut,
                    tunneledDomains : slTunneledDomains,
                    noTunnel        : Boolean(options[ 'saucelabs_' ])
                }

                if (options.build) this.addCapability('build', options.build)
            }

            return true
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Options.WebDriver', {

    isa         : Siesta.Launcher.Options.Base,

    does        : [
        Siesta.Launcher.Options.Simulation,
        Siesta.Launcher.Options.Proxy,
        Siesta.Launcher.Options.BrowserStack,
        Siesta.Launcher.Options.SauceLabs
    ],

    has : {
        knownBrowsers   : {
            init    : {
                firefox         : true,
                'internet explorer' : true,
                safari          : true,
                chrome          : true,
                MicrosoftEdge   : true
            }
        }
    },


    methods : {

        addCapability : function (name, value) {
            var options             = this.options

            options.caps[ name ]    = value

            options.cap.push(name + '=' + value)
        },


        getBrowserName : function () {
            var options         = this.options

            return options.caps.browserName || options.browser
        },


        validate : function () {
            var options         = this.options

            // prepare capabilities
            var caps            = options[ 'cap' ] || []
            if (!(caps instanceof Array)) caps = [ caps ]

            options.cap         = caps
            options.caps        = {}

            Joose.A.each(caps, function (value) {
                var split       = String(value).split(/\s*=\s*/)

                options.caps[ split[ 0 ] ] = split[ 1 ]
            })

            // need to have "caps" populated for preparing the report file name
            if (this.SUPER() === false) return false


            // prepare browser args
            var browserArgs     = options[ 'browser-arg' ] || []
            if (!(browserArgs instanceof Array)) browserArgs = [ browserArgs ]

            options[ 'browser-arg' ]    = browserArgs


            // prepare firefox prefs
            var ffPrefs         = options[ 'ff-pref' ] || []
            if (!(ffPrefs instanceof Array)) ffPrefs = [ ffPrefs ]

            options[ 'ff-pref' ]        = ffPrefs


            // prepare browser name, default value should be set outside of the `getBrowserName`
            var browser         = (this.getBrowserName() || 'chrome').toLowerCase()

            if (browser == 'ie') browser = 'internet explorer'
            if (browser == 'edge' || browser == 'microsoftedge') browser = 'MicrosoftEdge'

            if (!this.knownBrowsers[ browser ]) {
                this.printError("Unknown browser: " + browser)

                return false
            }

            options.browser     = browser

            // the value is already normalized by the Simulation role
            if (options.xvfb) {
                this.launcher.sharedNativeSimulator = false
            }

            return true
        },


        getReportFileNameTemplateReplacer : function () {
            var options         = this.options
            var caps            = options.caps

            return function (m, match) {
                if (caps && caps.hasOwnProperty(match))
                    return caps[ match ]
                else
                    return options[ match ]
            }
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Options.Puppeteer', {

    isa         : Siesta.Launcher.Options.Base,

    does        : [
        Siesta.Launcher.Options.Simulation
    ]
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Options.NodeJS', {
    isa         : Siesta.Launcher.Options.Base,


    methods : {

        initialize : function () {
            var options     = this.options

            // !IMPORTANT - for NodeJS we only allow 1 test file per "chunk", as this is the most correct way to run the NodeJS
            // test
            // in the future, we might allow several test files per "test launcher", but user needs to opt-in,
            // as the `require` loader is hard to tweak to work with different context generically
            // what we currently do, is - we load project files (Joose + Siesta + etc) in separate context
            // then the "Scope.Provider.NodeEmbed" just returns/uses the original global context
            options[ 'chunk-size' ]    = 1

            this.SUPERARG()

            if (options[ 'inspect' ] || options[ 'inspect-brk' ]) options[ 'max-workers' ] = 1
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role('Siesta.Launcher.CommandLineTool.BaseTool', {

    requires    : [
        'print', 'printErr',
        'readFile',
        'printVersion',
        'checkIsWindows', 'checkIsMacOS', 'checkIs64Bit',
        'getTerminalWidth',
        'doExit'
    ],

    does        : [
        Siesta.Util.Role.CanStyleOutput,
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Launcher.Role.CanProcessArguments
    ],


    has : {
        // an array of the command line options, 1st one (with 0 index) must be a "binDir" value
        args                    : Joose.I.Array,

        argv                    : Joose.I.Array,
        options                 : null,
        optionGroups            : null,
        positionalGroups        : null,

        // with trailing slash!
        binDir                  : null,

        isWindows               : function () { return this.checkIsWindows() },
        isMacOS                 : function () { return this.checkIsMacOS() },
        isLinux                 : function () { return !this.checkIsWindows() && !this.checkIsMacOS() },
        is64Bit                 : function () { return this.checkIs64Bit() },
        is32Bit                 : function () { return !this.checkIs64Bit() },

        executableName          : null,

        helpIntro               : function () {
            return [
                'Usage: ' + this.executableName + ' [OPTIONS]',
                ''
            ]
        },

        // should not be used directly, instead via `getTerminalWidth`
        terminalWidth           : null,

        indentStr               : '    ',

        sep                     : function () { return this.checkIsWindows() ? '\\' : '/' },

        knownOptionGroups       : {
            init : {
//                '00-sample' : {
//                    name        : 'Sample option group'
//                }
            }
        },

        knownOptions            : {
            init : [
//                {
//                    name    : 'sample-option',
//                    desc    : [
//                        'Description'
//                    ],
//                    group   : '00-sample'
//                }
            ]
        }
    },


    methods : {

        indentText : function (text, level) {
            level           = level || 0

            for (var i = 0, indent = ''; i < level; i++, indent += this.indentStr) ;

            var textArr     = text.split('\n')

            return indent + textArr.join('\n' + indent)
        },


        forEveryOption : function (func, scope) {
            scope           = scope || this

            var processed   = {}

            for (var meta = this.meta; meta.hasAttribute('knownOptions'); meta = meta.superClass.meta) {

                var res = Joose.A.each(meta.getAttribute('knownOptions').init, function (option, i) {
                    // do not process option 2nd time (allow option override from parent class)
                    if (processed[ option.name ]) return

                    processed[ option.name ]    = true

                    return func.call(scope, option, i)
                })

                if (res === false) return false
            }
        },


        forEveryOptionGroup : function (func, scope) {
            scope           = scope || this

            var processed   = {}

            for (var meta = this.meta; meta.hasAttribute('knownOptionGroups'); meta = meta.superClass.meta) {
                var res = Joose.O.each(meta.getAttribute('knownOptionGroups').init, function (group, id) {
                    // do not process option 2nd time (allow option override from parent class)
                    if (processed[ id ]) return

                    processed[ id ]     = true

                    return func.call(scope, group, id)
                })

                if (res === false) return false
            }
        },


        hasOption : function (name) {
            var found   = this.forEveryOption(function (option) {
                if (option.name == name) return false
            })

            // a bit unclear, but `found` will be set to `false` if some option has matching name
            // (early exit from the `forEveryOption` iterator)
            return found === false
        },


        aliasOptions : function () {
            var options     = this.options

            Joose.O.each(options, function (value, name) {
                if (/-/.test(name))
                    options[ name.replace(/-(\w)/g, function (m, match) { return match.toUpperCase() }) ] = value
            })
        },


        parseJson : function (str) {
            function extractLineFeeds(s) {
                return s.replace(/[^\n]+/g, '');
            }

            // input is the HanSON string to convert.
            // if keepLineNumbers is set, toJSON() tried not to modify line numbers, so a JSON parser's
            // line numbers in error messages will still make sense.
            function toJSON(input, keepLineNumbers) {
                var UNESCAPE_MAP = { '\\"': '"', "\\`": "`", "\\'": "'" };
                var ML_ESCAPE_MAP = {'\n': '\\n', "\r": '\\r', "\t": '\\t', '"': '\\"'};
                function unescapeQuotes(r) { return UNESCAPE_MAP[r] || r; }

                return input.replace(/`(?:\\.|[^`])*`|'(?:\\.|[^'])*'|"(?:\\.|[^"])*"|\/\*[^]*?\*\/|\/\/.*\n?/g, // pass 1: remove comments
                                     function(s) {
                    if (s.charAt(0) == '/')
                        return keepLineNumbers ? extractLineFeeds(s) : '';
                    else
                        return s;
                })
                .replace(/(?:true|false|null)(?=[^\w_$]|$)|([a-zA-Z_$][\w_\-$]*)|`((?:\\.|[^`])*)`|'((?:\\.|[^'])*)'|"(?:\\.|[^"])*"|(,)(?=\s*[}\]])/g, // pass 2: requote
                                     function(s, identifier, multilineQuote, singleQuote, lonelyComma) {
                    if (lonelyComma)
                        return '';
                    else if (identifier != null)
                            return '"' + identifier + '"';
                    else if (multilineQuote != null)
                        return '"' + multilineQuote.replace(/\\./g, unescapeQuotes).replace(/[\n\r\t"]/g, function(r) { return ML_ESCAPE_MAP[r]; }) +
                               '"' + (keepLineNumbers ? extractLineFeeds(multilineQuote) : '');
                    else if (singleQuote != null)
                        return '"' + singleQuote.replace(/\\./g, unescapeQuotes).replace(/"/g, '\\"') + '"';
                    else
                        return s;
                });
            }

            return JSON.parse(toJSON(str, false))
        },


        readJsonFile : function (fileName, errIo, errParse) {
            var json, str

            try {
                str     = this.readFile(fileName)
            } catch (e) {
                this.printError([
                    this.formatString(errIo || "Can't read the content of the JSON file: {fileName}", { fileName : fileName })
                ])

                return
            }

            try {
                json    = this.parseJson(str)
            } catch (e) {
                this.printError([
                    this.formatString((errParse || "JSON file {fileName} does not contain valid JSON: ") + e, { fileName : fileName })
                ])

                return
            }

            return json
        },


        readConfigFileOptions : function (fileName) {
            return this.readJsonFile(
                fileName,
                "Can't read the content of the configuration file: {fileName}",
                "Config file {fileName} does not contain valid JSON: "
            )
        },


        prepareOptions : function (callback) {
            var me              = this
            var processed       = this.processArguments(this.args)

            this.argv           = processed.argv
            this.options        = processed.options

            var options         = this.options

            // add trailing slash if missing
            this.binDir         = this.argv.shift().replace(/\/?$/, '/')

            if (options.version) {
                me.printVersion()

                callback(true)

                return
            }

            if (options.help) {
                me.printHelp()

                callback(true)

                return
            }

            if (options[ 'config-file' ]) {
                var config      = this.readConfigFileOptions(options[ 'config-file' ])

                if (!config) { callback(true); return }

                this.options    = options = Joose.O.extend(config, options)
            }

            Joose.O.each(options, function (value, name) {
                if (!me.hasOption(name)) {
                    me.warn("Unknown option provided: " + name)
                }
            })

            callback()
        },


        printHelp : function (callback) {
            this.printVersion()
            this.printCopyright()

            var options         = []
            var groups          = {}

            this.forEveryOptionGroup(function (group, id) {
                if (groups[ id ]) throw "Group already defined: " + group.name

                groups[ id ]    = group
            })

            var maxNameLength   = 0

            this.forEveryOption(function (option) {
                // ignore options with leading `__` (used for indicating instrumented copy of the project for example)
                if (option.name.match(/^__/)) return

                if (!groups[ option.group ]) throw "Option with unknown group: " + option.name + ", " + option.group

                option.index    = options.length

                options.push(option)

                if (option.name.length > maxNameLength) maxNameLength = option.name.length
            })

            var terminalWidth       = Math.max(this.getTerminalWidth() - 5, 80)

            var arr                 = []
            arr.length              = terminalWidth
            var spacesStr           = arr.join(' ')
            var dashesStr           = arr.join('-')

            //Header:
            //    --option-name Description
            // 4 spaces + "--" + 1 space
            var optionSectionWidth  = 4 + 2 + maxNameLength + 4
            var descAvailableWidth  = terminalWidth - optionSectionWidth

            options.sort(function (option1, option2) {
                return option1.group < option2.group ? -1 : option1.group > option2.group ? 1 : option1.index - option2.index
            })

            var helpDesc        = this.fitString(this.helpIntro.join(' '), descAvailableWidth, spacesStr)
            helpDesc.push('')

            var me              = this
            var indentString    = spacesStr.substr(0, optionSectionWidth)

            var currentGroup

            Joose.A.each(options, function (option, index) {
                var optionGroup = groups[ option.group ]

                if (currentGroup != optionGroup) {
                    if (index > 0) helpDesc.push('')

                    helpDesc.push(me.styled(optionGroup.name + ':', 'bold'))
                    helpDesc.push(me.styled(dashesStr.substr(0, optionGroup.name.length + 1), 'bold'))
                }
                currentGroup    = optionGroup

                var optionText  = '    --' + me.styled(option.name, 'bold') + spacesStr.substr(0, maxNameLength - option.name.length) + '    '

                var optionDesc  = (option.desc instanceof Array) ? option.desc.join(' ') : option.desc

                var lines       = me.fitString(optionDesc, descAvailableWidth, spacesStr)

                Joose.A.each(lines, function (line, index) {
                    if (index == 0)
                        lines[ 0 ]      = optionText + lines[ 0 ]
                    else
                        lines[ index ]  = indentString + lines[ index ]
                })

                helpDesc.push.apply(helpDesc, lines)
            })

            this.print(helpDesc.join('\n'))

            callback && callback()
        },


        printCopyright : function () {
            this.print(this.style().bold("Copyright: ") + "Bryntum AB 2009-" + (new Date().getFullYear()) + "\n")
        },


        fitString : function (string, maxLength, spacesStr) {
            var lines       = []
            var parts       = string.split(/ /)

            while (parts.length) {
                var str             = []
                var len             = 0
                var forcedNewLine   = false

                while (
                    parts.length
                        &&
                    (len + parts[ 0 ].length + (str.length ? 1 : 0) <= maxLength || !str.length && parts[ 0 ].length > maxLength)
                ) {
                    var part    = parts.shift()
                    len         += part.length + (str.length ? 1 : 0)

                    if (/\n$/.test(part)) forcedNewLine = true

                    str.push(part.replace(/\n$/, ''))

                    if (forcedNewLine) break
                }

                // can be negative in case of small `maxLength`
                var spaceLeft   = Math.max(parts.length && !forcedNewLine ? maxLength - len : 0, 0)

                var fittedStr   = ''

                for (var i = 0; i < str.length; i++) {
                    if (i == 0)
                        fittedStr   = str[ 0 ]
                    else {
                        var addition    = Math.ceil(spaceLeft / (str.length - i))

                        fittedStr       += spacesStr.substr(0, addition + 1) + str[ i ]

                        spaceLeft       -= addition
                    }
                }

                lines.push(fittedStr)
            }

            return lines
        },


        getPlatformId : function () {
            if (this.isMacOS) return 'macos'
            if (this.isWindows) return 'windows'

            if (this.is64Bit) return 'linux64'

            return 'linux32'
        },


        prepareText : function (text, addLineBreak, indentLevel, noColor) {
            if (text instanceof Array) text = text.join('\n')

            if (this.options[ 'no-color' ] || noColor) text = String(text).replace(/\x1B\[\d+m([\s\S]*?)\x1B\[\d+m/mg, '$1')

            // normalize line endings
            text    = String(text).replace(/\x0d?\x0a/g, '\n')

            if (indentLevel) text = this.indentText(text, indentLevel)

            return text + (addLineBreak ? '\n' : '')
        },


        printError : function (text, indentLevel) {
            if (text instanceof Array) text = text.join('\n')

            this.print(
                this.styled('[' + Siesta.Resource('Siesta.Role.ConsoleReporter', 'errorText') + '] ', 'red') + text,
                indentLevel
            )
        },


        info : function (text, indentLevel) {
            this.print(
                this.styled('[INFO] ', 'yellow') + text,
                indentLevel
            )
        },


        warn : function (text, indentLevel) {
            this.print(
                this.styled('[' + Siesta.Resource('Siesta.Role.ConsoleReporter', 'warnText') + '] ', 'red') + text,
                indentLevel
            )
        },


        debug : function (text) {
            if (this.options.debug) this.print(this.styled('[DEBUG] ', 'yellow') + text)
        },


        exit : function (code) {
            this.doExit(code)
        }
    }
    // eof methods
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.BaseLauncher', {
    /*PKGVERSION*/VERSION : '5.3.2',

    does        : [
        JooseX.Observable,

        Siesta.Util.Role.CanGetType,

        Siesta.Launcher.FileSystem.Base,
        Siesta.Launcher.CommandLineTool.BaseTool
    ],


    has : {
        runners                 : Joose.I.Array,

        // native simulator is shared between all pages for webdriver+robotjs, or per-page for puppeteer
        sharedNativeSimulator   : true,

        optionsWrapper          : null,

        projectConfig           : Joose.I.Object,

        helpIntro               : function () {
            var style   = this.style()

            return [
                style.bold('Usage: ') + this.executableName + ' url [OPTIONS]\n',
                'The ' + style.bold('url') + ' should point to the HTML wrapper of your Siesta project file. All options are optional.',
                ''
            ]
        },

        knownOptionGroups       : {
            init : {
                '00-system' : {
                    name        : 'Base options'
                },
                '10-basic' : {
                    name        : 'Basic options'
                },
                '15-debug' : {
                    name        : 'Debugging'
                },
                '20-misc' : {
                    name        : 'Miscellaneous'
                },
                '30-coverage' : {
                    name        : 'Coverage options'
                },
                '70-ci' : {
                    name        : 'Continous integration options'
                }
            }
        },

        knownOptions            : {
            init : [
                {
                    name    : 'help',
                    desc    : 'Prints this help message and exit',
                    group   : '00-system'
                },
                {
                    name    : 'version',
                    desc    : 'Prints versions of Siesta and automation component and exit',
                    group   : '00-system'
                },
                {
                    name    : 'project-url',
                    desc    : 'The url of the project for this test suite',
                    group   : '00-system'
                },
                {
                    name    : 'config-file',
                    desc    : [
                        'The file with the "relaxed JSON" object, containing any command line or project options.',
                        'Please refer to the "Siesta automation" guide for details.'
                    ],
                    group   : '00-system'
                },
                {
                    name    : 'filter',
                    desc    : [
                        'A filter string to only launch matching tests. Matches the behaviour of the filter',
                        'field in Siesta UI (see the tooltip for more info). This option is processed before the --include and --exclude options'
                    ],
                    group   : '10-basic'
                },
                {
                    name    : 'include',
                    desc    : [
                        'A regular expression to only include tests with matching urls.'
                    ],
                    group   : '10-basic'
                },
                {
                    name    : 'exclude',
                    desc    : 'A regular expression to exclude tests with matching urls, takes precedence over `include`',
                    group   : '10-basic'
                },
                {
                    name    : 'report-file',
                    desc    : [
                        'If this option is provided Siesta will create a report after running all tests.',
                        'The format of the report can be specified with the --report-format option.',
                        'This option specifies the file name template to save the report to. Template can contain',
                        'variables, marked as {entry}.',
                        'The value for variables is first taken from the `--cap` option values and then from regular options.',
                        'For example, if you pass the options "--browser=ie --cap version=9", you can then set the file name template as:\n',
                        '    --report-file=result-{browser}-{version}.json\n',
                        'and resulting file will have the following name: "result-ie-9.json".',
                        'For the HTML report format this option actually specifies the directory, to which save the required files.',
                        'This option can be repeated several times (several reports will be generated), in this case, the --report-format option should be provided',
                        'exactly the same number of times, the files and formats will be matched by their order'
                    ],
                    group   : '10-basic'
                },
                {
                    name    : 'report-file-prefix',
                    desc    : [
                        'Deprecated. This option has the same effect as "report-file", with one addition - ',
                        'variable {browser} is always inserted before the file extension, so the',
                        'following report file name are the same:\n',
                        '    --report-file-prefix=report_.json  and  --report-file=report_{browser}.json\n'
                    ],
                    group   : '10-basic'
                },
                {
                    name    : 'report-format',
                    desc    : [
                        'Specifies the test suite report format. Recognizable formats are: "html, json, jsons, junit", default value is `json`.',
                        'The `html` report includes `jsons` with additional files for visualizing the results.',
                        'When using `html` report, the `--report-file` option actually specifies the _directory_ to save data into, not a single file.',
                        'This option can be repeated several times (several reports will be generated), in this case, the --report-file option should be provided',
                        'exactly the same number of times, the files and formats will be matched by their order'
                    ],
                    group   : '10-basic'
                },
                {
                    name    : 'restart-on-blur',
                    desc    : [
                        'Experimental. Restart the test if it has lost the focus for any reason.'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'randomize-tests-order',
                    desc    : [
                        'Randomize the order of test execution. Helps you ensure your tests do not depend on each other.',
                        'Also if you have some heavy tests, grouped in the certain place of the test suite, this option',
                        'will sort of balance the load across the whole suite.'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'no-color',
                    desc    : 'Disable the coloring of the output',
                    group   : '20-misc'
                },
                {
                    name    : 'verbose',
                    desc    : 'Print all assertions of the test (not only from the failed ones)',
                    group   : '20-misc'
                },
                {
                    name    : 'debug',
                    desc    : 'Enable diagnostic messages',
                    group   : '20-misc'
                },
                {
                    name    : 'flat-output',
                    desc    : [
                        'Print assertions as a flat list (instead of tree structure based on `describe/it` sections).',
                        'Use this only for compatibility with the Siesta versions before 4.1.0'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'width',
                    desc    : [
                        'Width of the test page, in pixels. Note, that this option sets the width of the test project page,',
                        'not the width of the individual test`s iframe. Use `viewportWidth` project option for that.\n',
                        'IMPORTANT: For IE, this option should have bigger value than `viewportWidth`'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'height',
                    desc    : [
                        'Height of the test page, in pixels. Note, that this option sets the height of the test project page,',
                        'not the height of the individual test`s iframe. Use `viewportHeight` project option for that.\n',
                        'IMPORTANT: For IE, this option should have bigger value than `viewportHeight`'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'chunk-size',
                    desc    : [
                        'The number of tests, after which the browser will be restarted, default value is 20'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'max-workers',
                    desc    : [
                        'The maximum number of test pages that can be opened simultaneously. Default value is 1.',
                        'You can increase this option for the BrowserStack and SauceLabs for example.'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'pause',
                    desc    : [
                        'Pause between individual tests, in milliseconds, default value is 10. Overrides the',
                        '`pauseBetweenTests` project option.'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'rerun-failed',
                    desc    : [
                        'Experimental. When this option is enabled, after the test suite has completed execution,',
                        'if the number of failed tests is less than 10% from the total number of tests,',
                        'failed tests are re-run one more time.',
                        'If such tests will pass on the 2nd execution',
                        'they will be reported as passed. This option is automatically disabled, when --verbose option',
                        'is enabled and --max-workers=1 (because assertions will be streamed lived in this case)'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'show-cursor',
                    desc    : [
                        'Show the simulated mouse cursor, when running in automation mode. Not supported in IE.',
                        'Slightly affects performance'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'restart-attempts',
                    desc    : [
                        'The number of Siesta`s attempts to re-start a test if it has stopped functioning',
                        'for any reason (browser crashed, WebDriver exception, connection lost etc). Default value is 1 (restart one time)'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'coverage-report-format',
                    desc    : [
                        'Specifies the format of the code coverage report, recognized',
                        'values are any Nyc reporters, listed here: https://git.io/vHysA\n',
                        'Typical values are: `html`, `text`, `lcov`.',
                        'If provided, this option will enable the collection of the code coverage information.',
                        'This option can be repeated several times, resulting in several reports',
                        'saved in the same directory. Alternatively, several formats can be',
                        'concatenated with "," or "+": --coverage-report-format=html+text\n',
                        'Alias of the --nyc.reporter'
                    ],
                    group   : '30-coverage'
                },
                {
                    name    : 'coverage-report-dir',
                    desc    : [
                        'Specifies the output directory for the code coverage report.',
                        'Default value is "./coverage/"',
                        'Alias of the --nyc.report-dir'
                    ],
                    group   : '30-coverage'
                },
                {
                    name    : 'build',
                    desc    : [
                        'Name of the build. Will be provided to the cloud testing infrastructure in the apropriate capability.',
                        'Will be also available in the JSON reports as the `build` property and `name` attribute in JUnit report'
                    ],
                    group   : '70-ci'
                },
                {
                    name    : 'teamcity',
                    desc    : [
                        'Enables the special markup in the test suite output that is recognized by the',
                        'TeamCity to generate realtime progress information'
                    ],
                    group   : '70-ci'
                },
                {
                    name    : 'team-city',
                    desc    : [
                        'Synonym for --teamcity'
                    ],
                    group   : '70-ci'
                },
                {
                    name    : 'tc-suite',
                    desc    : [
                        'Name of the test suite to run (currently used only in TeamCity and requires --teamcity)'
                    ],
                    group   : '70-ci'
                },
                {
                    name    : 'jenkins',
                    desc    : [
                        'Forces launcher to always exit with 0 exit code (otherwise Jenkins thinks build has failed',
                        'and will not try to create a report)'
                    ],
                    group   : '70-ci'
                }
            ]
        },

        isRunning           : false,

        shutDownStarted     : false,

        manuallyProcessCoverageResults  : true
    },


    methods : {

        optionToString : function (value, name) {
            if (typeof value === 'object' && this.typeOf(value) === 'Boolean')
                return '--' + name
            else
                return '--' + name + '=' + value
        },


        prepareOptions : function () {
            var me              = this
            var processed       = this.processArguments(this.args)

            this.argv           = processed.argv
            this.options        = processed.options
            this.optionGroups   = processed.groups
            this.positionalGroups = processed.positionalGroups

            var options         = this.options

            // add trailing slash if missing
            this.binDir         = this.argv.shift().replace(/\/?$/, '/')

            this.terminalWidth  = this.argv.shift()

            if (options.version) {
                me.printVersion()

                return 8
            }

            if (options.help) {
                me.printHelp()

                return 8
            }

            var defaultConfig

            if (options[ 'config-file' ]) {
                defaultConfig       = this.readConfigFileOptions(options[ 'config-file' ])

                if (!defaultConfig) return false
            } else {
                try {
                    defaultConfig   = this.readDefaultConfig()
                } catch (e) {
                    return false
                }
            }

            if (defaultConfig) {
                this.options        = options = Joose.O.extend(this.stripLeadingMinuses(defaultConfig.cmd || {}), options)

                this.projectConfig  = defaultConfig.project || {}
            }

            Joose.O.each(options, function (value, name) {
                if (!me.hasOption(name)) me.onUnknownOption(value, name)
            })

            this.optionsWrapper = this.createOptionsWrapper(this.options)

            return this.optionsWrapper.validate()
        },


        onUnknownOption : function (value, name) {
            this.warn("Unknown option provided: " + name)
        },


        readDefaultConfig : function () {
            var up          = ''
            var path        = this.normalizePath('siesta.json')

            do {
                var isRoot  = /^\/siesta\.json/.test(path) || this.isWindows && /\w:[\\\/]siesta\.json/.test(path)

                if (this.fileExists(path)) {
                    var config  = this.readConfigFileOptions(path)

                    if (!config) throw "error"

                    return config
                }

                up          = '..' + this.sep + up

                path        = this.normalizePath(up + 'siesta.json')

            } while (!isRoot)

            return null
        },


        stripLeadingMinuses : function (obj) {
            var stripped    = {}

            Joose.O.each(obj, function (value, name) {
                stripped[ /^--/.test(name) ? name.substr(2) : name ] = value
            })

            return stripped
        },


        createOptionsWrapper : function (cfg) {
            return new Siesta.Launcher.Options.Base({ options : cfg, launcher : this })
        },


        getSiestaVersion : function () {
            return Siesta.Launcher.BaseLauncher.meta.VERSION
        },


        printVersion : function () {
            var version     = this.getSiestaVersion()

            if (version) this.print(this.style().bold("Siesta   : ") + version)
        },


        getPlatformId : function () {
            if (this.isMacOS) return 'macos'
            if (this.isWindows) return 'windows'

            if (this.is64Bit) return 'linux64'

            return 'linux32'
        },


        checkIsWindows : function () {
            throw new Error("Abstract method call: `checkIsWindows`")
        },


        checkIsMacOS : function () {
            throw new Error("Abstract method call: `checkIsMacOS`")
        },


        checkIs64Bit : function () {
            throw new Error("Abstract method call: `checkIs64Bit`")
        },


        print : function () {
            throw new Error("Abstract method call: `print`")
        },


        printErr : function () {
            throw new Error("Abstract method call: `printErr`")
        },


        doExit : function () {
            throw new Error("Abstract method call: `doExit`")
        },


        exit : function (code) {
            this.doExit(this.options.jenkins ? 0 : code)
        },


        // this method runs before the "prepareOptions" call
        createRunners : function () {
            throw new Error("Abstract method call: `createRunners`")
        },


        getTerminalWidth : function () {
            throw new Error("Abstract method call: `getTerminalWidth`")
        },


        destroyRunners : function () {
            var promises        = []

            Joose.A.each(this.runners, function (runner) { promises.push(runner.destroy()) })

            return promises
        },


        constructUrl : function (baseURL, options) {
            options         = options || {}

            if (!baseURL.match(/^https?:\/\//)) baseURL = 'http://' + baseURL

            var isFirst     = true

            for (var name in options) {
                var value       = options[ name ]

                // ignore `null` and `undefined` values
                if (value == null) continue

                var delimeter   = isFirst ? (baseURL.match(/\?/) ? '&' : '?') : '&'

                baseURL     += delimeter + name + '=' + encodeURIComponent(value)

                isFirst     = false
            }

            return baseURL
        },


        buildHarnessUrlQueryParams : function () {
            return {}
        },


        saveReport : function (reportFormat, reportFile, reportContent) {
            if (reportFormat == 'html')
                this.saveHtmlReport(reportFile, reportContent)
            else
                this.saveFile(reportFile, reportContent)
        },


        saveHtmlReport : function (reportDir, reportContent) {
            var binDir      = this.binDir

            this.copyFile(binDir + 'reports/html/index.html', reportDir + '/index.html')

            this.copyFile(binDir + '../resources/css/siesta-all.css', reportDir + '/css/siesta-html-report.css')
            this.copyFile(binDir + '../resources/css/siesta-all-part-1.css', reportDir + '/css/siesta-all-part-1.css')
            this.copyFile(binDir + '../resources/css/siesta-all-part-2.css', reportDir + '/css/siesta-all-part-2.css')
            this.copyFile(binDir + '../siesta-all.js', reportDir + '/siesta-html-report.js')

            this.copyFile(binDir + '../resources/images/loadmask/loading.gif', reportDir + '/images/loadmask/loading.gif')
            this.copyFile(binDir + '../resources/images/domcontainer-bg.png', reportDir + '/images/domcontainer-bg.png')

            this.copyTree(binDir + '../resources/css/fonts', reportDir + '/css/fonts')
            this.copyTree(binDir + '../resources/css/font-awesome', reportDir + '/css/font-awesome')
            this.copyTree(binDir + '../resources/css/font-ext', reportDir + '/css/font-ext')

            this.saveFile(reportDir + '/report-data.json', reportContent)
        },


        // promised method
        destroy : function () {
            this.isRunning  = false

            this.fireEvent('destroy')

            return Promise.all(this.destroyRunners())
        },


        start : function () {
            var me              = this
            var optionsCheck    = me.prepareOptions()

            if (optionsCheck === false) {
                return Promise.resolve(6)
            } if (typeof optionsCheck == 'number') {
                return Promise.resolve(optionsCheck)
            } else {
                // create "optionAlias" entries in the "options" object for the "option-alias"
                me.aliasOptions()

                return me.setup().then(function (res) {
                    if (res == 'instrumentation') {
                        // return `null` to not mask the exit code from the instrumentation instance (which is launched in NodeJS launcher)
                        return null
                    } else {
                        var options         = me.options

                        var dispatcher      = new Siesta.Launcher.Dispatcher({
                            // role can be applied to instance (it is called "trait" then)
                            trait                   :
                                options[ 'team-city' ] || options[ 'teamcity' ] ? Siesta.Launcher.Dispatcher.Reporter.TeamCity : null,

                            projectUrl              : me.constructUrl(options[ 'project-url' ], me.buildHarnessUrlQueryParams()),

                            options                 : options,
                            launcher                : me,
                            givenRunners            : me.runners = me.createRunners(),

                            reRunFailed             : options[ 'rerun-failed' ],
                            streamAssertions        : options[ 'max-workers' ] == null || options[ 'max-workers' ] == 1,
                            projectConfig           : me.getCommonProjectConfig()
                        })

                        me.debug("Dispatcher start")

                        me.isRunning    = true

                        return dispatcher.start()
                    }
                }).then(function (exitCode) {

                    return me.destroy().then(function () {
                        return exitCode
                    })
                })
            }
        },


        getCommonProjectConfig : function () {
            return Object.assign({}, this.projectConfig, this.optionGroups.project)
        },


        setup : function () {
//            Joose.C.debug           = true
            return Promise.resolve()
        }
    }
    // eof methods
})
;
if (typeof process != 'undefined') {;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {
/* header */

var fs      = require('fs')
var fse     = require('fs-extra')
var path    = require('path')

Role('Siesta.Launcher.FileSystem.NodeJS', {

    does        : Siesta.Launcher.FileSystem.Base,

    has : {
    },


    methods : {

        fileExists : function (fileName, mode) {
            fileName        = this.normalizePath(fileName)

            try {
                fs.accessSync(fileName, mode)
            } catch (e) {
                return false
            }

            return true
        },


        deleteFile : function (fileName) {
            try {
                fs.unlinkSync(fileName)
            } catch (e) {
                return false
            }

            return true
        },


        readFile : function (fileName, encoding) {
            fileName        = this.normalizePath(fileName)

            return fs.readFileSync(fileName, encoding === null ? null : 'utf8')
        },


        saveFile : function (fileName, content, encoding) {
            fileName        = this.normalizePath(fileName)

            fse.outputFileSync(fileName, content, encoding === null ? null : 'utf8')
        },


        copyFile : function (source, dest) {
            this.saveFile(dest, this.readFile(source, null), null)
        },


        copyTree : function (source, dest) {
            fse.copySync(source, dest, { clobber : true })
        },


        normalizePath : function (str) {
            return path.resolve(str)
        },

        // following methods are not part of the interface (only used in webdriver launcher)

        ensurePathExists : function (fileName) {
            fileName        = this.normalizePath(fileName)

            try {
                fse.ensureDirSync(path.dirname(fileName))
            } catch (e) {
                return false
            }

            return true
        }
    }
})

/* footer */
}();
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
;[ process.stdout, process.stderr ].forEach(function (s) {
    s && s.isTTY && s._handle && s._handle.setBlocking && s._handle.setBlocking(true)
})

Role('Siesta.Launcher.CommandLineTool.NodeJSTool', {

    does        : [
        Siesta.Launcher.FileSystem.NodeJS
    ],


    methods : {

        getTerminalWidth : function () {
            return process.stdout.columns
        },


        print : function (text, indentLevel) {
            process.stdout.write(this.prepareText(text, true, indentLevel))
        },


        printErr : function (text, indentLevel) {
            process.stderr.write(this.prepareText(text, true, indentLevel))
        },


        checkIsWindows : function () {
            return process.platform == 'win32'
        },


        checkIsMacOS : function () {
            return process.platform == 'darwin'
        },


        checkIs64Bit : function () {
            return process.arch == 'x64'
        },


        doExit : function (code) {
            process.exit(code)
        },


        gracefulShutdown : function () {
            this.exit(7)
        }
    },
    // eof methods

    override : {

        initialize : function () {
            var me      = this

            process.on('uncaughtException', function (err) {
                console.log("Caught unhandled exception: ", err, err.stack);

                me.gracefulShutdown()
            });

            process.on('unhandledRejection', function (err) {
                console.log("Caught unhandled rejection: ", err, err.stack);

                me.gracefulShutdown()
            });

            process.on('SIGTERM', this.gracefulShutdown.bind(this));
            process.on('SIGINT', this.gracefulShutdown.bind(this));
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
!function () {

const child_process                 = require('child_process')

const { LogLevel }                  = require('../src/generic/util/role/CanLog.js')
const { NodeJsPageRpcFunctionCall } = require('../src/nodejs/launcher/NodeJsPageRpc')
const { NodeJsPageParentEndPoint }  = require('../src/nodejs/launcher/NodeJsPageRpcParent')


Class('Siesta.Launcher.Page.NodeJS', {

    isa         : Siesta.Launcher.Page.BasePage,

    does        : [
    ],

    has : {
        nodeJsProcess       : null,
        channel             : null
    },


    methods : {

        openHarness : function (projectUrl, callback) {
            // avoid normalization to http url
            return this.SUPER(this.dispatcher.options[ 'project-url' ], callback)
        },


        open : function (url, callback) {
            var me              = this

            var options         = me.dispatcher.options

            // prepare browser args
            var nodeJsArgs      = options[ 'node-arg' ] || []
            if (!(nodeJsArgs instanceof Array)) nodeJsArgs = [ nodeJsArgs ]

            var stdio           = options[ 'isolate-console' ] ? 'ignore' : 'inherit'

            var inspect         = options[ 'inspect' ] || options[ 'inspect-brk' ]

            let nodeJsProcess   = me.nodeJsProcess = child_process.fork(
                process.argv[ 1 ],
                [ 'AS_CONNECTOR' ].concat(process.argv.slice(2)),
                {
                    stdio       : [ stdio, stdio, stdio, 'ipc' ],
                    execArgv    : nodeJsArgs.concat(
                        inspect
                        ?
                            inspect instanceof Boolean ? '--inspect' : '--inspect=' + inspect
                        :
                            []
                    )
                }
            )

            nodeJsProcess.on('exit', () => {
                me.nodeJsProcess    = null
            })

            me.channel          = new NodeJsPageParentEndPoint({ logLevel : LogLevel.debug })

            me.channel.connect(nodeJsProcess).then(() => {
                // in debugging mode, the inspector need some time to "attach" to external debugging UI,
                // so we wait 300ms by default
                // otherwise, some of the `debugger` breakpoints can be ignored
                // https://github.com/nodejs/node/issues/25215
                return !inspect ? Promise.resolve() : new Promise(resolve => setTimeout(resolve, options[ 'inspect-delay' ] || 300))
            }).then(
                () => callback(), e => callback(e)
            )
        },


        gracefullyKillDuring : function (subProcess, timeout) {

            return new Promise(resolve => {
                subProcess.once('exit', () => {
                    clearTimeout(handler)
                    resolve()
                })

                subProcess.kill('SIGTERM')

                var handler = setTimeout(() => {
                    subProcess.kill('SIGKILL')

                    setTimeout(resolve, 10)
                }, timeout)
            })
        },


        close : function () {
            this.channel.disconnect()

            var nodeJsProcess   = this.nodeJsProcess

            // child process has already exit
            if (!nodeJsProcess) return this.SUPER()

            var me              = this
            var options         = me.dispatcher.options
            var inspect         = options[ 'inspect' ] || options[ 'inspect-brk' ]

            if (inspect) {
                // in debugging mode, need to make sure previous nodejs processes have been closed
                // otherwise the debugger port will be busy and opening new session will fail
                // so we wait for `gracefullyKillDuring` promise to resolve
                return Promise.all([
                    this.SUPER(),
                    this.gracefullyKillDuring(nodeJsProcess, 100)
                ])
            } else {
                nodeJsProcess.kill('SIGTERM')

                // in normal mode, we just initiate the page close and return immediately, w/o waiting for close to complete
                return this.SUPER()
            }
        },


        executeSmallScriptPromised : function (text, ignoreException) {
            var me          = this

            return this.channel.sendRpcCall(
                new NodeJsPageRpcFunctionCall({ func : '(function() {' + text + '})' }).toJson()
            ).then(
                res => res,
                e => {
                    if (!ignoreException) {
                        me.print("<Exception from launcher>")
                        me.print("    While running small script: " + text.substring(0, 150))
                        me.print("    Exception: " + e)
                        me.print("</Exception from launcher>")

                        return Promise.reject(e)
                    } else
                        return Promise.resolve(null)
                }
            )
        }
    }
    // eof methods
})


}();
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.Runner.NodeJS', {

    isa     : Siesta.Launcher.Runner.BaseRunner,

    has : {
        pagePollInteval     : 300,

        maxWorkers          : 5
    },


    methods : {

        createPage : function (callback) {
            var me      = this

            callback(null, new Siesta.Launcher.Page.NodeJS({
                runner          : me,
                launcher        : me.launcher,
                dispatcher      : me.dispatcher,

                pollInterval    : me.pagePollInteval
            }))
        }
    }
})
;
/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class('Siesta.Launcher.NodeJS', {

    isa         : Siesta.Launcher.BaseLauncher,

    does        : [
        Siesta.Launcher.CommandLineTool.NodeJSTool,
        Siesta.Launcher.Role.CanWorkWithNyc
    ],

    has : {
        executableName          : 'nodejs',

        sharedNativeSimulator   : false,

        knownOptionGroups   : {
            init : {
                '15-nodejs' : {
                    name        : 'NodeJS options'
                }
            }
        },

        knownOptions            : {
            init : [
                {
                    name    : 'isolate-console',
                    desc    : [
                        'This option disables the "shared" console - the `stdin/stdout/stderr` streams of all test files will not be forwarded',
                        'to the main console.'
                    ],
                    group   : '20-misc'
                },
                {
                    name    : 'inspect',
                    desc    : [
                        'This option will be translated to the --inspect[=[host:]port] option of the Node.js process, starting',
                        'a debugger inspector instance on the given host/port, by default 127.0.0.1:9229.',
                        'It will also switch the test suite to --max-workers=1 mode, to avoid collision of the debugger instances',
                    ],
                    group   : '15-debug'
                },
                {
                    name    : 'inspect-brk',
                    desc    : [
                        'Same as --inspect, and will also stop on the breakpoint before launching every test',
                    ],
                    group   : '15-debug'
                },
                {
                    name    : 'node-arg',
                    desc    : [
                        'This option can be repeated several times, and specifies command line arguments for the derived NodeJS process',
                        'in the form --node-arg name=value, for example:\n',
                        '    --node-arg=\'--inspect-port=12345\' --node-arg=\'--no-deprecation\'\n',
                        'Full options list is listed in: > node --help\n',
                    ],
                    group   : '20-misc'
                },
                {
                    name    : '__instrumented-copy__',
                    desc    : 'System option, not for user',
                    group   : '20-misc'
                }
            ]
        },

        helpIntro               : function () {
            var style   = this.style()

            return [
                style.bold('Usage: ') + this.executableName + ' [glob] [OPTIONS]\n',
                'Will launch all tests matching ' + style.bold('glob') + ' (default value is "**/*.t.?(m)js").',
                'Use trailing ' + style.bold('/') + ' to match directories.',
                'All options are optional.',
                ''
            ]
        },

        manuallyProcessCoverageResults      : false
    },


    methods : {

        // getRawNycArgs : function () {
        //     return this.positionalGroups.nyc
        // },


        createOptionsWrapper : function (cfg) {
            return new Siesta.Launcher.Options.NodeJS({ options : cfg, launcher : this })
        },


        // this method runs before the "prepareOptions" call
        createRunners : function () {
            return [
                new Siesta.Launcher.Runner.NodeJS({
                    launcher    : this
                })
            ]
        },


        getCommonProjectConfig : function () {
            const options   = this.options
            const res       = this.SUPER()

            return options[ 'inspect-brk' ] ? Object.assign(res, { debuggerOnStart : true }) : res
        },


        printVersion : function () {
            this.SUPERARG(arguments)

            this.print(this.style().bold("NodeJS   : ") + process.version)
        },


        setup : function () {
            const instrumentedCopyOptionName    = '__instrumented-copy__'

            if (this.options.coverage && !this.options[ instrumentedCopyOptionName ]) {
                const path          = require('path')

                const foreground    = require('foreground-child')
                const sw            = require('spawn-wrap')

                const wrapper       = require.resolve('nyc/bin/wrap.js')

                let argv            = this.buildNycArgv(this.positionalGroups.nyc)

                // always exclude siesta files from instrumentation
                argv.exclude.push(
                    path.relative(argv.cwd, __dirname + '/../bin'),
                    path.relative(argv.cwd, __dirname + '/../src'),
                    path.relative(argv.cwd, __dirname + '/../index.js'),
                    path.relative(argv.cwd, __dirname + '/../siesta-nodejs-all.js'),
                    '**/*.t.js'
                )

                let nyc             = this.buildNyc(argv)

                if (argv.all) nyc.addAllFiles()

                let env             = {
                    NYC_CONFIG          : JSON.stringify(argv),
                    NYC_CWD             : process.cwd(),
                    NYC_ROOT_ID         : nyc.rootId,
                    NYC_INSTRUMENTER    : nyc.config.instrumenter
                }

                if (argv['babel-cache'] === false) {
                    // babel's cache interferes with some configurations, so is
                    // disabled by default. opt in by setting babel-cache=true.
                    env.BABEL_DISABLE_CACHE = process.env.BABEL_DISABLE_CACHE = '1'
                }

                sw([ wrapper ], env)

                return new Promise((resolve, reject) => {

                    foreground(
                        process.argv[ 0 ],
                        process.argv.slice(1).concat('--' + instrumentedCopyOptionName),
                        (done) => {
                            resolve('instrumentation')

                            this.nycReport(nyc)

                            return done()
                        }
                    )
                })
            } else
                return Promise.resolve()
        }
    }
    // eof methods
})
;
};
