StartTest(function(t) {

    t.diag("Siesta.Test keyboard simulation");

    var FormatHelper            = Class({ does : Siesta.Util.Role.CanFormatStrings })
    var formatStringHelper      = new FormatHelper()

    t.testExtJS(function (t) {

        var box = new Ext.form.TextField({
            width               : 400,
            enableKeyEvents     : true,
            renderTo            : Ext.getBody()
        });

        function testKeyEvents(t, textField, string, callback, scope) {
            textField.reset();

            var results     = {};
            var expected    = {};

            var generateListener = function(eventName) {
                var res = results[ eventName ]  = {};
                var exp = expected[ eventName ] = {};

                return function (field, e) {
                    // console.log("Event : " + e.type + ", key: " + e.getKey() + ", char: " + String.fromCharCode(e.getKey()))

                    var key     = e.getKey()

                    if (eventName === 'keypress') {
                        res[ String.fromCharCode(key) ]++
                    } else {
                        res[ key ] = res[ key ] || 0

                        res[ key ]++
                    }
                };
            };

            textField.on('keydown', generateListener('keydown'));
            textField.on('keypress', generateListener('keypress'));
            textField.on('keyup', generateListener('keyup'));

            var KC          = Siesta.Test.UserAgent.KeyCodes().keys;

            var keys        = formatStringHelper.extractKeysAndSpecialKeys(string)

            for (var i = 0; i < keys.length; i++) {
                var key                         = keys[ i ]
                var keyUp                       = key.toUpperCase().replace(/[\[\]]/g, '')
                var keyCode                     = KC[ keyUp ]

                // uppercased char - in native simulator is typed with SHIFT
                if (key.length == 1 && key.toLowerCase() != key && t.simulator.type == 'native' && !t.harness.isPuppeteer) {
                    expected.keydown[ KC.SHIFT ]    = (expected.keydown[ KC.SHIFT ] || 0) + 1
                    expected.keyup[ KC.SHIFT ]      = (expected.keyup[ KC.SHIFT ] || 0) + 1
                }

                expected.keydown[ keyCode ]     = (expected.keydown[ keyCode ] || 0) + 1
                expected.keypress[ key ]        = (expected.keypress[ key ] || 0) + 1
                expected.keyup[ keyCode ]       = (expected.keyup[ keyCode ] || 0) + 1
            }

            t.type(textField.inputEl, string, function() {
                t.isDeeply(results.keydown, expected.keydown, "All keydown events fired correctly by input field");
                // TODO our keypress simuation is incorrect - should not be simulated for BACKSPACE for example
                // t.isDeeply(results.keypress, expected.keypress, "All keypress events fired correctly by input field");
                t.isDeeply(results.keyup, expected.keyup, "All keyup events fired correctly by input field");

                callback && callback.call(scope || t);
            });
        }


        t.it('String with backspace', function (t) {
            testKeyEvents(t, box, "abc[BACKSPACE]", function() {
                t.is(box.getValue(), "ab", "Correct text in input field");
            });
        })


        t.it('Letters', function (t) {
            testKeyEvents(t, box, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", function() {
                t.is(box.getValue(), "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "Correct text in input field");
            });
        })


        t.it('Special chars', function (t) {
            testKeyEvents(t, box, ".,", function() {
                t.is(box.getValue(), ".,", "Correct text in input field");
            });
        })
    });
});
