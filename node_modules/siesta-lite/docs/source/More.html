<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
<span id='Siesta-Test-More'>/**
</span>@class Siesta.Test.More

A mixin with additional generic assertion methods, which can work cross-platform between browsers and NodeJS.
Is being consumed by {@link Siesta.Test}, so all of them are available in all tests.

*/
Role(&#39;Siesta.Test.More&#39;, {

    requires        : [ &#39;isFailed&#39;, &#39;typeOf&#39;, &#39;on&#39; ],


    has : {
        autoCheckGlobals        : false,
        expectedGlobals         : Joose.I.Array,

        disableGlobalsCheck     : false,

        browserGlobals : {
            init : [
                &#39;console&#39;,
                &#39;getInterface&#39;,
                &#39;ExtBox1&#39;,
                &#39;__IE_DEVTOOLBAR_CONSOLE_COMMAND_LINE&#39;,
                /__BROWSERTOOLS/, // IE11 with console open
                &#39;seleniumAlert&#39;,
                &#39;onload&#39;,
                &#39;onerror&#39;,
                &#39;StartTest&#39;,
                &#39;startTest&#39;,
                &#39;__loaderInstrumentationHookInstalled__&#39;,
                &#39;describe&#39;,
                // will be reported in IE8 after overriding
                &#39;setTimeout&#39;,
                &#39;clearTimeout&#39;,
                &#39;requestAnimationFrame&#39;,
                &#39;cancelAnimationFrame&#39;,
                &#39;__coverage__&#39;,
                /cov_\w+/
            ]
        },

<span id='Siesta-Test-More-cfg-waitForTimeout'>        /**
</span>         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000.
         */
        waitForTimeout                  : 10000,

        waitForPollInterval             : 100,

        suppressPassedWaitForAssertion  : false
    },


    methods : {

<span id='Siesta-Test-More-method-isGreater'>        /**
</span>         * This assertion passes, when the comparison of 1st with 2nd, using `&gt;` operator will return `true` and fails otherwise.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreater : function (value1, value2, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (value1 &gt; value2)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isGreaterPassTpl&#39;),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isGreater&#39;,

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get(&#39;needGreaterThan&#39;)
                })
        },


<span id='Siesta-Test-More-method-isLess'>        /**
</span>         * This assertion passes, when the comparison of 1st with 2nd, using `&lt;` operator will return `true` and fails otherwise.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLess : function (value1, value2, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (value1 &lt; value2)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isLessPassTpl&#39;),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isLess&#39;,

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get(&#39;needLessThan&#39;)
                })
        },


        isGE : function () {
            this.isGreaterOrEqual.apply(this, arguments)
        },

<span id='Siesta-Test-More-method-isGreaterOrEqual'>        /**
</span>         * This assertion passes, when the comparison of 1st with 2nd, using `&gt;=` operator will return `true` and fails otherwise.
         *
         * It has a synonym - `isGE`.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreaterOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (value1 &gt;= value2)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isGreaterEqualPassTpl&#39;),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isGreaterOrEqual&#39;,

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get(&#39;needGreaterEqualTo&#39;)
                })
        },



        isLE : function () {
            this.isLessOrEqual.apply(this, arguments)
        },

<span id='Siesta-Test-More-method-isLessOrEqual'>        /**
</span>         * This assertion passes, when the comparison of 1st with 2nd, using `&lt;=` operator will return `true` and fails otherwise.
         *
         * It has a synonym - `isLE`.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLessOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (value1 &lt;= value2)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isLessEqualPassTpl&#39;),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isLessOrEqual&#39;,

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get(&#39;needLessEqualTo&#39;)
                })
        },


<span id='Siesta-Test-More-method-isApprox'>        /**
</span>         * This assertion suppose to compare the numeric values. It passes when the passed values are approximately the same (the difference
         * is withing a threshold). A threshold can be provided explicitly (when assertion is called with 4 arguments),
         * or it will be set to 5% from the 1st value (when calling assertion with 3 arguments).
         *
         * @param {Number} value1 The 1st value to compare
         * @param {Number} value2 The 2nd value to compare
         * @param {Number} threshold The maximum allowed difference between values. This argument can be omitted.
         * @param {String} [desc] The description of the assertion
         */
        isApprox : function (value1, value2, threshold, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (arguments.length == 2) threshold  = Math.abs(value1 * 0.05)

            if (arguments.length == 3) {
                if (this.typeOf(threshold) == &#39;String&#39;) {
                    desc            = threshold
                    threshold      = Math.abs(value1 * 0.05)
                }
            }

            // this function normalizes the fractional numbers to fixed point presentation
            // for example in JS: 1.05 - 1 = 0.050000000000000044
            // so what we do is: (1.05 * 10^2 - 1 * 10^2) / 10^2 = (105 - 100) / 100 = 0.05
            var subtract    = function (value1, value2) {
                var fractionalLength    = function (v) {
                    var afterPointPart = (v + &#39;&#39;).split(&#39;.&#39;)[ 1 ]

                    return afterPointPart &amp;&amp; afterPointPart.length || 0
                }

                var maxLength           = Math.max(fractionalLength(value1), fractionalLength(value2))
                var k                   = Math.pow(10, maxLength);

                return (value1 * k - value2 * k) / k;
            };

            if (Math.abs(subtract(value2, value1)) &lt;= threshold)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isApproxToPassTpl&#39;),
                    value1              : value1,
                    value2              : value2,
                    annotation          : value2 == value1 ? R.get(&#39;exactMatch&#39;) : (R.get(&#39;withinThreshold&#39;) + &#39;: &#39; + threshold)
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isApprox&#39;,
                    got                 : value1,
                    need                : value2,
                    needDesc            : R.get(&#39;needApprox&#39;),
                    annotation          : R.get(&#39;thresholdIs&#39;) + &#39;: &#39; + threshold
                })
        },


<span id='Siesta-Test-More-method-like'>        /**
</span>         * This assertion passes when the passed `string` matches to a regular expression `regex`. When `regex` is a string,
         * assertion will check that it is a substring of `string`
         *
         * @param {String} string The string to check for &quot;likeness&quot;
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        like : function (string, regex, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(regex) == &quot;RegExp&quot;)

                if (string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get(&#39;stringMatchesRe&#39;),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;like&#39;,
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get(&#39;needStringMatching&#39;)
                    })
            else

                if (string.indexOf(regex) != -1)
                    this.pass(desc, {
                        descTpl             : R.get(&#39;stringHasSubstring&#39;),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;like&#39;,
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get(&#39;needStringContaining&#39;)
                    })
        },

<span id='Siesta-Test-More-method-unlike'>        /**
</span>         * This method is the opposite of &#39;like&#39;, it adds failed assertion, when the string matches the passed regex.
         *
         * @param {String} string The string to check for &quot;unlikeness&quot;
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        unlike : function(string, regex, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(regex) == &quot;RegExp&quot;)

                if (!string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get(&#39;stringNotMatchesRe&#39;),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;unlike&#39;,
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get(&#39;needStringNotMatching&#39;)
                    })
            else

                if (string.indexOf(regex) == -1)
                    this.pass(desc, {
                        descTpl             : R.get(&#39;stringHasNoSubstring&#39;),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;unlike&#39;,
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get(&#39;needStringNotContaining&#39;)
                    })
        },


        &quot;throws&quot; : function () {
            this.throwsOk.apply(this, arguments)
        },

        throws_ok : function () {
            this.throwsOk.apply(this, arguments)
        },

<span id='Siesta-Test-More-method-throwsOk'>        /**
</span>         * This assertion passes if the `func` function throws an exception during executing, and the
         * stringified exception passes the &#39;like&#39; assertion (with &#39;expected&#39; parameter).
         *
         * It has synonyms - `throws_ok` and `throws`.
         *
         *      t.throwsOk(function(){
         *          throw &quot;oopsie&quot;;
         *      }, &#39;oopsie&#39;, &#39;Some description text&#39;);
         *
         * See also {@link Siesta.Test#livesOk} method.
         *
         * @param {Function} func The function which should throw an exception
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        throwsOk : function (func, expected, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(func) != &#39;Function&#39;) throw new Error(R.get(&#39;throwsOkInvalid&#39;))

            var e = this.getExceptionCatcher()(func)

            // assuming no one will throw undefined exception..
            if (e === undefined) {
                this.fail(desc, {
                    assertionName       : &#39;throws_ok&#39;,
                    annotation          : R.get(&#39;didntThrow&#39;)
                })

                return
            }

            if (e instanceof this.getTestErrorClass())
                //IE uses non-standard &#39;description&#39; property for error msg
                e = e.message || e.description

            e = &#39;&#39; + e

            if (this.typeOf(expected) == &quot;RegExp&quot;)

                if (e.match(expected))
                    this.pass(desc, {
                        descTpl             : R.get(&#39;exMatchesRe&#39;),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;throws_ok&#39;,
                        got                 : e,
                        gotDesc             : R.get(&#39;exceptionStringifiesTo&#39;),
                        need                : expected,
                        needDesc            : R.get(&#39;needStringMatching&#39;)
                    })
            else

                if (e.indexOf(expected) != -1)
                    this.pass(desc, {
                        descTpl             : R.get(&#39;exContainsSubstring&#39;),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : &#39;throws_ok&#39;,
                        got                 : e,
                        gotDesc             : R.get(&#39;exceptionStringifiesTo&#39;),
                        need                : expected,
                        needDesc            : R.get(&#39;needStringContaining&#39;)
                    })
        },



        lives_ok : function () {
            this.livesOk.apply(this, arguments)
        },

        lives : function () {
            this.livesOk.apply(this, arguments)
        },

<span id='Siesta-Test-More-method-livesOk'>        /**
</span>         * This assertion passes, when the supplied `func` function doesn&#39;t throw an exception during execution.
         *
         * See also {@link Siesta.Test#throwsOk} method.
         *
         * This method has two synonyms: `lives_ok` and `lives`
         *
         * @param {Function} func The function which is not supposed to throw an exception
         * @param {String} [desc] The description of the assertion
         */
        livesOk : function (func, desc) {
            if (this.typeOf(func) != &#39;Function&#39;) {
                func = [ desc, desc = func ][ 0 ]
            }

            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);
            var e       = this.getExceptionCatcher()(func)

            if (e === undefined)
                this.pass(desc, {
                    descTpl             : R.get(&#39;fnDoesntThrow&#39;)
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;lives_ok&#39;,
                    annotation          : R.get(&#39;fnThrew&#39;) + &#39;: &#39; + e
                })
        },


        isa_ok : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },


        isaOk : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },

<span id='Siesta-Test-More-method-isInstanceOf'>        /**
</span>         * This assertion passes, when the supplied `value` is the instance of the `className`. The check is performed with
         * `instanceof` operator. The `className` parameter can be supplied as class constructor or as string, representing the class
         * name. In the latter case the `class` will eval&#39;ed to receive the class constructor.
         *
         * This method has synonyms: `isaOk`, `isa_ok`
         *
         * @param {Mixed} value The value to check for &#39;isa&#39; relationship
         * @param {Class/String} className The class to check for &#39;isa&#39; relationship with `value`
         * @param {String} [desc] The description of the assertion
         */
        isInstanceOf : function (value, className, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            try {
                if (this.typeOf(className) == &#39;String&#39;) className = this.global.eval(className)
            } catch (e) {
                this.fail(desc, {
                    assertionName       : &#39;isa_ok&#39;,
                    annotation          : Siesta.Resource(&#39;Siesta.Test.Function&#39;, &#39;exceptionEvalutingClass&#39;)
                })

                return
            }

            if (value instanceof className)
                this.pass(desc, {
                    descTpl             : R.get(&#39;isInstanceOfPass&#39;)
                })
            else
                this.fail(desc, {
                    assertionName       : &#39;isa_ok&#39;,
                    got                 : value,
                    need                : String(className),
                    needDesc            : R.get(&#39;needInstanceOf&#39;)
                })
        },


<span id='Siesta-Test-More-method-isString'>        /**
</span>         * This assertion passes, if supplied value is a String.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isString : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;String&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isAString&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aStringValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isObject'>        /**
</span>         * This assertion passes, if supplied value is an Object
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isObject : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Object&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isAnObject&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;anObject&#39;)
                })
        },


<span id='Siesta-Test-More-method-isArray'>        /**
</span>         * This assertion passes, if supplied value is an Array
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isArray : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Array&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isAnArray&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;anArrayValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isNumber'>        /**
</span>         * This assertion passes, if supplied value is a Number.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isNumber : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Number&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isANumber&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aNumberValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isBoolean'>        /**
</span>         * This assertion passes, if supplied value is a Boolean.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isBoolean : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Boolean&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isABoolean&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aBooleanValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isDate'>        /**
</span>         * This assertion passes, if supplied value is a Date.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isDate : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Date&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isADate&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aDateValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isRegExp'>        /**
</span>         * This assertion passes, if supplied value is a RegExp.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isRegExp : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;RegExp&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isARe&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aReValue&#39;)
                })
        },


<span id='Siesta-Test-More-method-isFunction'>        /**
</span>         * This assertion passes, if supplied value is a Function.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isFunction : function (value, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.typeOf(value) == &#39;Function&#39; || this.typeOf(value) == &#39;AsyncFunction&#39;)
                this.pass(desc, {
                    descTpl     : R.get(&#39;isAFunction&#39;),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get(&#39;aFunctionValue&#39;)
                })
        },


        is_deeply : function (obj1, obj2, desc) {
            this.isDeeply.apply(this, arguments)
        },

<span id='Siesta-Test-More-method-isDeeply'>        /**
</span>         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with &#39;==&#39; operator, so `[ 1 ]` and `[ &quot;1&quot; ] objects will be equal. The objects should not contain cyclic references.
         *
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         *
         * This method has a synonym: `is_deeply`
         *
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeply : function (obj1, obj2, desc) {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            var diff

            if (this.typeOf(obj1) === this.typeOf(obj2) &amp;&amp; this.compareObjects(obj1, obj2)) {

                this.pass(desc, {
                    descTpl             : R.get(&#39;isDeeplyPassTpl&#39;),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            // DeepDiff Not supported in IE8
            else if (typeof DeepDiff != &#39;undefined&#39; &amp;&amp; (diff = DeepDiff(obj1, obj2))) {

                if (diff.length &gt; 5) {
                    this.diag(R.get(&#39;tooManyDifferences&#39;, { num : 5, total : diff.length}))
                }

                for (var i = 0; i &lt; Math.min(diff.length, 5); i++) {
                    var diffItem    = diff[i];
                    var path        = (diffItem.path || []).join(&#39;.&#39;);
                    var saw         = path ? (path + &#39;: &#39; + diffItem.lhs) : obj1;
                    var expected    = path ? (path + &#39;: &#39; + diffItem.rhs) : obj2;

                    this.fail(desc, {
                        assertionName       : &#39;isDeeply&#39;,
                        got                 : saw,
                        need                : expected
                    })

                    // Also log it to console for easy inspection
                    window.console &amp;&amp; console.log(&#39;DIFF RESULT:&#39;, diffItem);
                }

            } else {
                this.fail(desc, {
                    assertionName       : &#39;isDeeply&#39;,
                    got                 : obj1,
                    need                : obj2
                })
            }
        },


<span id='Siesta-Test-More-method-isDeeplyStrict'>        /**
</span>         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with &#39;===&#39; operator, so `[ 1 ]` and `[ &quot;1&quot; ] objects will be different. The objects should not contain cyclic references.
         *
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         *
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeplyStrict : function (obj1, obj2, desc) {
            if (this.typeOf(obj1) === this.typeOf(obj2) &amp;&amp; this.compareObjects(obj1, obj2, true)) {

                var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

                this.pass(desc, {
                    descTpl             : R.get(&#39;isDeeplyStrictPassTpl&#39;),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            else
                this.fail(desc, {
                    assertionName       : &#39;isDeeplyStrict&#39;,
                    got                 : obj1,
                    need                : obj2
                })
        },

        expectGlobal : function () {
            this.expectGlobals.apply(this, arguments)
        },


<span id='Siesta-Test-More-method-expectGlobals'>        /**
</span>         * This method accepts a variable number of names of expected properties in the global scope. When verifying the globals with {@link #verifyGlobals}
         * assertions, the expected gloabls will not be counted as failed assertions.
         *
         * This method has a synonym with singular name: `expectGlobal`
         *
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        expectGlobals : function () {
            this.expectedGlobals.push.apply(this.expectedGlobals, arguments)
        },


        isGlobalExpected : function (name, index) {
            var me                  = this

            if (!index || index &amp;&amp; !index.expectedStrings) {
                if (!index) index   = {}

                Joose.O.extend(index, {
                    expectedStrings     : {},
                    expectedRegExps     : []
                })

                Joose.A.each(this.expectedGlobals.concat(this.browserGlobals), function (value) {
                    if (me.typeOf(value) == &#39;RegExp&#39;)
                        index.expectedRegExps.push(value)
                    else
                        index.expectedStrings[ value ] = true
                })
            }

            if (index.expectedStrings[ name ]) return true

            var imageWithIdCreatesGlobalEnumerable  = Siesta.Project.Browser.FeatureSupport().supports.imageWithIdCreatesGlobalEnumerable;

            // remove after https://bugzilla.mozilla.org/show_bug.cgi?id=959992 will be fixed
            if (imageWithIdCreatesGlobalEnumerable) {
                var domEl       = this.global.document.getElementById(name)

                if (domEl &amp;&amp; domEl.tagName.toLowerCase() == &#39;img&#39;) return true;
            }

            for (var i = 0; i &lt; index.expectedRegExps.length; i++)
                if (index.expectedRegExps[ i ].test(name)) return true

            return false
        },


        forEachUnexpectedGlobal : function (func, scope) {
            scope                   = scope || this

            var index               = {}

            for (var name in this.global)
                if (!this.isGlobalExpected(name, index)) {
                    if (func.call(scope, name) === false) {
                        break;
                    }
                }
        },


<span id='Siesta-Test-More-method-verifyGlobals'>        /**
</span>         * This method accepts a variable number of names of expected properties in the global scope and then performs a globals check.
         *
         * It will scan all globals properties in the scope of test and compare them with the list of expected globals. Expected globals can be provided with:
         * {@link #expectGlobals} method or {@link Siesta.Project#expectedGlobals expectedGlobals} configuration option of project.
         *
         * You can enable this assertion to automatically happen at the end of each test, using {@link Siesta.Project#autoCheckGlobals autoCheckGlobals} option of the project.
         *
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        verifyGlobals : function () {
            var R       = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            if (this.disableGlobalsCheck) {
                this.diag(R.get(&#39;globalCheckNotSupported&#39;));

                return
            }

            this.expectGlobals.apply(this, arguments)

            this.diag(R.get(&#39;globalVariables&#39;))

            var failed          = false
            var i               = 0
            this.forEachUnexpectedGlobal(function (name) {
                this.fail(
                    R.get(&#39;globalFound&#39;),
                    R.get(&#39;globalName&#39;) + &#39;: &#39; + name + &#39;, &#39; + R.get(&#39;value&#39;) + &#39;: &#39; + Siesta.Util.Serializer.stringify(this.global[ name ])
                )

                failed      = true
                return i++ &lt; 50 // Only report first 50 globals to protect against legacy apps with thousands of globals
            })

            if (!failed) this.pass(R.get(&#39;noGlobalsFound&#39;))
        },


        // will create a half-realized, &quot;phantom&quot;, &quot;isWaitFor&quot; assertion, which is only purposed
        // for user to get the instant feedback about &quot;waitFor&quot; actions
        // this assertion will be &quot;finalized&quot; and added to the test results in the &quot;finalizeWaiting&quot;
        startWaiting : function (description, sourceLine) {
            var result = new Siesta.Result.Assertion({
                description     : description,
                isWaitFor       : true,
                sourceLine      : sourceLine
            });

            this.fireEvent(&#39;testupdate&#39;, this, result, this.getResults())

            return result;
        },


        finalizeWaiting : function (result, passed, desc, annotation, errback, suppressPassedWaitForAssertion) {
            // Treat this is an ordinary assertion from now on
            result.completed = true;

            if (passed) {
                if (this.suppressPassedWaitForAssertion || suppressPassedWaitForAssertion) {
                    // Make sure UI is updated and the &quot;noise&quot; is removed
                    this.fireEvent(&#39;assertiondiscard&#39;, this, result)
                } else {
                    this.pass(desc, annotation, result)
                }
            }
            else {
                this.fail(desc, annotation, result);

                errback &amp;&amp; errback()
            }
        },


<span id='Siesta-Test-More-method-waitFor'>        /**
</span>         * Waits for passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * As an additional feature, the callback will receive the result from the checker method as the 1st argument.
         *

    t.waitFor(
        function () { return document.getElementById(&#39;someEl&#39;) },
        function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument &quot;el&quot;
        }
    )

         * You can also call this method with a single Object having the following properties: `method`, `callback`, `scope`, `timeout`, `interval`, `description`:

    t.waitFor({
        method      : function () { return document.getElementById(&#39;someEl&#39;) },
        callback    : function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument &quot;el&quot;
        }
    })

         *
         * @param {Function/Number/Object} condition Either a function which should return true (or any other &quot;truthy&quot; value) when a certain condition has been fulfilled,
         * or a number of ms to wait before calling the callback. Can be also an object with the following properties:
         * @param {Function} condition.callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Function} condition.method A condition checker function.
         * @param {Object} condition.scope The scope for the callback.
         * @param {Number} condition.timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * @param {Number} condition.interval The polling interval (in milliseconds)
         * @param {String} condition.description The assertion description
         *
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Promise} A promise which will be resolved when wait completes (either successfully or by timeout). In case of successfull resolution
         * promise will be resolved to the result from the checker function. Additionally it has a `force` property as noted below.
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitFor : function (method, callback, scope, timeout, interval)  {
            var R                       = Siesta.Resource(&#39;Siesta.Test.More&#39;);
            var description             = &#39; &#39; + R.get(&#39;conditionToBeFulfilled&#39;);
            var assertionName           = &#39;waitFor&#39;;
            var me                      = this;
            var sourceLine              = me.getSourceLine();
            var originalSetTimeout      = me.originalSetTimeout;
            var originalClearTimeout    = me.originalClearTimeout;
            var errback;
            var suppressAssertion;

            if (arguments.length === 1 &amp;&amp; this.typeOf(method) == &#39;Object&#39;) {
                var options         = method;

                method              = options.method;
                callback            = options.callback;
                scope               = options.scope;
                timeout             = options.timeout;
                interval            = options.interval

                description         = options.description || description;
                assertionName       = options.assertionName || assertionName;
                suppressAssertion   = options.suppressAssertion;

                // errback is called in case &quot;waitFor&quot; has failed
                errback             = options.errback
            } else
                options             = {}

            var isWaitingForTime        = this.typeOf(method) == &#39;Number&#39;

            callback                    = callback || function () {}
            description                 = isWaitingForTime ? (method + &#39; &#39; + R.get(&#39;ms&#39;)) : description;

            var pollTimeout

            // early notification about the started &quot;waitFor&quot; operation
            var waitAssertion           = me.startWaiting(R.get(&#39;waitingFor&#39;) + &#39; &#39; + description, sourceLine);

            interval                    = interval || this.waitForPollInterval
            timeout                     = timeout || this.waitForTimeout

            var resolve

            var res = new Promise(function (resolution) {
                resolve = resolution
            })

            // this async frame is not supposed to fail, because it&#39;s delayed to `timeout + 3 * interval`
            // failure supposed to be generated in the &quot;pollFunc&quot; and this async frame to be closed
            // however, in IE the async frame may end earlier than failure from &quot;pollFunc&quot;
            // in such case we report the same error as in &quot;pollFunc&quot;
            var async                   = this.beginAsync((isWaitingForTime ? method : timeout) + 3 * interval, function () {
                isDone      = true

                originalClearTimeout(pollTimeout)

                me.finalizeWaiting(waitAssertion, false, R.get(&#39;waitedTooLong&#39;) + &#39;: &#39; + description, {
                    assertionName       : assertionName,
                    annotation          : me.typeOf(options.annotation) === &#39;Function&#39; ? options.annotation() : R.get(&#39;conditionNotFulfilled&#39;) + &#39; &#39; + timeout + R.get(&#39;ms&#39;) + &#39;. \n\n [code]&#39; + method.toString() + &#39;[/code]&#39;
                }, errback, suppressAssertion)

                resolve()

                return true
            })

            var isDone      = false

            // stop polling, if this test instance has finalized (probably because of exception)
            this.on(&#39;beforetestfinalize&#39;, function () {
                if (!isDone) {
                    isDone      = true

                    me.finalizeWaiting(waitAssertion, false, R.get(&#39;waitingAborted&#39;), null, null, suppressAssertion);
                    me.endAsync(async)

                    originalClearTimeout(pollTimeout)
                }
            }, null, { single : true })

            if (isWaitingForTime) {
                if (method &lt; 0) {
                    throw new Error(&#39;Cannot wait for a negative amount of time&#39;);
                }
                pollTimeout = originalSetTimeout(function() {
                    isDone      = true

                    me.finalizeWaiting(waitAssertion, true, R.get(&#39;Waited&#39;) + &#39; &#39; + method + &#39; &#39; + R.get(&#39;ms&#39;), null, null, suppressAssertion || method === 0);
                    me.endAsync(async);
                    me.processCallbackFromTest(callback, [], scope || me)

                    resolve()
                }, method);

            } else {

                var result;
                var startDate   = new Date()

                var pollFunc    = function () {
                    var time = new Date() - startDate;

                    if (time &gt; timeout) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, R.get(&#39;waitedTooLong&#39;) + &#39;: &#39; + description, {
                            assertionName       : assertionName,
                            annotation          : me.typeOf(options.annotation) === &#39;Function&#39; ? options.annotation() : R.get(&#39;conditionNotFulfilled&#39;) + &#39; &#39; + timeout + R.get(&#39;ms&#39;) + &#39;. \n\n [code]&#39; + method.toString() + &#39;[/code]&#39;
                        }, errback, suppressAssertion)

                        isDone      = true

                        resolve()

                        return
                    }

                    try {
                        result = method.call(scope || me);
                    } catch (e) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, assertionName + &#39; &#39; + R.get(&#39;checkerException&#39;), {
                            assertionName       : assertionName,
                            got                 : e.toString(),
                            gotDesc             : R.get(&#39;Exception&#39;)
                        }, errback, suppressAssertion)

                        isDone      = true

                        resolve()

                        return
                    }

                    if (result != null &amp;&amp; result !== false) {
                        me.endAsync(async);

                        isDone      = true
                        me.finalizeWaiting(
                            waitAssertion,
                            true,
                            R.get(&#39;Waited&#39;) + &#39; &#39; + time + &#39; &#39; + R.get(&#39;msFor&#39;) + &#39; &#39; + description,
                            me.typeOf(options.annotation) === &#39;Function&#39; ? options.annotation() : null,
                            null,
                            // always add assertion (set &quot;suppress&quot; to false), if user has provided description
                            (suppressAssertion || time === 0) &amp;&amp; !options.description
                        );

                        me.processCallbackFromTest(callback, [ result ], scope || me)

                        resolve(result)
                    } else
                        pollTimeout = originalSetTimeout(pollFunc, interval)
                }

                pollFunc()
            }

            res.force = function () {
                // wait operation already completed
                if (isDone) return

                isDone      = true

                originalClearTimeout(pollTimeout)

                me.endAsync(async);

                me.finalizeWaiting(waitAssertion, true, R.get(&#39;forcedWaitFinalization&#39;) + &#39; &#39; + description, null, null, suppressAssertion);

                me.processCallbackFromTest(callback, [], scope || me)

                resolve()
            }

            return res
        },

<span id='Siesta-Test-More-method-waitForMs'>        /**
</span>         * Waits for the number of a number millseconds and calls the callback when after waiting. This is just a convenience synonym for the {@link #waitFor} method.

         t.waitForMs(1500, callback)

         *
         * @param {Number} method The number of ms to wait before calling the callback.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForMs : function() {
            return this.waitFor.apply(this, arguments);
        },


<span id='Siesta-Test-More-method-waitForFn'>        /**
</span>         * Waits for the passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * This is just a convenience synonym for the {@link #waitFor} method.
         *

         t.waitForFn(function() { return true; }, callback)

         *
         * @param {Function} fn The checker function.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForFn : function() {
            return this.waitFor.apply(this, arguments);
        },

        // takes the step function and tries to analyze if it is missing the call to &quot;next&quot;
        // returns &quot;true&quot; if &quot;next&quot; is used,
        analyzeChainStep : function (func) {
            var sources         = func.toString()

            var isArrow         = !sources.match(/^function/)
            var firstArg

            if (isArrow) {
                if (sources.match(/^\(/))
                    // args wrapper in ()
                    firstArg    = sources.match(/\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
                else
                    // single argument not wrapped in ()
                    firstArg    = sources.match(/(.*?)\s*=&gt;/)[ 1 ]
            } else {
                firstArg        = sources.match(/function\s*[^(]*\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
            }

            if (!firstArg) return false

            var body

            if (isArrow)
                body            = sources.match(/=&gt;\s*([\s\S]*)/)[ 1 ]
            else
                body            = sources.match(/\{([\s\S]*)\}/)[ 1 ]

            return body.indexOf(firstArg) != -1
        },


        stringifyChainStep : function (step) {
            return this.typeOf(step).match(/^(Async)?Function$/) ? step.toString() : Siesta.Util.Serializer.stringify(step)
        },


<span id='Siesta-Test-More-method-chain'>        /**
</span>         * This method accepts a variable number of steps, either as individual arguments or as a single array containing them. Steps and arrays
         * of steps are handled just fine, and any step-arrays passed will be flattened. Each step should be either a function or configuration
         * object for {@link Siesta.Test.Action test actions}. These functions / actions will be executed in order.
         *
         * 1) For a function step, it will receive a callback as the 1st argument, to call when the step is completed.
         * As the 2nd and further arguments, the step function will receive the arguments passed to the previous callback.
         *
         * If a function step returns a promise, it should not call the callback, but instead Siesta will wait until the promise returned is
         * resolved / rejected. This plays nicely with the `async/await` functions:
         *

    let someAsyncOperation =
        t =&gt; new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; { resolve(&quot;someValue&quot;) }, 300)
        })

    t.it(&#39;Doing async stuff&#39;, t =&gt; {
        t.chain(
            // function step, that returns a promise (sugared with async/await)
            async () =&gt; {
                return await someAsyncOperation(t)
            },
            // desugared version
            function (next, result) {
                return someAsyncOperation(t)
            }
        )
    })

         *
         * The last step will receive a no-op callback, which can be ignored or still called. **Note**, that last step is assumed to
         * complete synchronously! If you need to launch some asynchronous process in the last step, you may need to add another empty function step
         * to the end of the chain.
         *
         * 2) For `Siesta.Test.Action` objects, the callback will be called by the action class automatically,
         * there&#39;s no need to provide any callback manually. The configuration object should contain an &quot;action&quot; property, specifying the action class
         * along with other config options depending on the action class. For brevity, instead of using the &quot;action&quot; property, the configuration
         * object can contain the property corresponding to the action name itself, with the action&#39;s target (or even a test method with arguments).
         * See the following examples and also refer to the documentation of the action classes.
         *
         * If the configuration object will contain a `desc` property, a passing assertion with its value will be added to the test, after this step has completed.
         *
         * 3) If a step is a sub test instance, created with {@link #getSubTest} method, then the step will launch it.
         *
         * It&#39;s better to see how it works in action. For example, when using using only functions:

    t.chain(
        // function receives a callback as 1st argument
        function (next) {
            // we pass that callback to the &quot;click&quot; method
            t.click(buttonEl, next)
        },
        function (next) {
            t.type(fieldEl, &#39;Something&#39;, next)
        },
        function (next) {
            t.is(fieldEl.value == &#39;Something&#39;, &#39;Correct value in the field&#39;)

            // call the callback with some arguments
            next(&#39;foo&#39;, &#39;bar&#39;)
        },
        // those arguments are now available as arguments of next step
        function (next, value1, value2) {
            t.is(value1, &#39;foo&#39;, &#39;The arguments for the callback are translated to the arguments of the step&#39;)
            t.is(value2, &#39;bar&#39;, &#39;The arguments for the callback are translated to the arguments of the step&#39;)
        }
    )

         *
         * The same example, using action configuration objects for first 2 steps. For the list of available actions
         * please refer to the classes in the `Siesta.Test.Action` namespace.

    t.chain(
        {
            action      : &#39;click&#39;,
            target      : buttonEl,
            desc        : &quot;Clicked on the button&quot;
        },
        // or
        {
            click       : buttonEl,
            desc        : &quot;Clicked on the button&quot;
        },

        {
            action      : &#39;type&#39;,
            target      : fieldEl,
            text        : &#39;Something&#39;,
            desc        : &quot;Typed in the field&quot;
        },
        // or
        {
            type        : &#39;Something&#39;,
            target      : fieldEl,
            desc        : &quot;Typed in the field&quot;
        },

        {
            waitFor     : &#39;Selector&#39;,
            args        : &#39;.selector&#39;
        }
        // or, using Siesta.Test.Action.MethodCall notation:
        {
            waitForSelector : &#39;.selector&#39;
        }

        function (next) {
            t.is(fieldEl.value == &#39;Something&#39;, &#39;Correct value in the field&#39;)

            next(&#39;foo&#39;, &#39;bar&#39;)
        },
        ...
    )

         * Please note, that by default, each step is expected to complete within the {@link Siesta.Project#defaultTimeout} time.
         * You can change this with the `timeout` property of the step configuration object, allowing some steps to last longer.
         * Steps with sub-tests are expected to complete within {@link Siesta.Project#subTestTimeout}.
         *
         * In a special case, `action` property of the step configuration object can be a function. In this case you can also
         * provide a `timeout` property, otherwise this case is identical to using functions:
         *

    t.chain(
        {
            action      : function (next) { ... },
            // allow 50s for the function to call &quot;next&quot; before step will be considered timed-out
            timeout     : 50000
        },
        ...
    )

         *  **Tip**:
         *
         *  If a step is presented with a `null` or `undefined` value it will be ignored. Additionally, a step can be
         *  an array of steps - all arrays passed to t.chain will be flattened.
         *
         *  These tips allows us to implement conditional steps processing, like this:
         *

    var el1IsInDom          = t.$(&#39;.some-class1&#39;)[ 0 ]
    var el2IsInDom          = t.$(&#39;.some-class2&#39;)[ 0 ]

    t.chain(
        { click : &#39;.some-other-el&#39; },

        el1IsInDom ? [
            { click : el1IsInDom },

            el2IsInDom ? [
                { click : el1IsInDom }
            ] : null,
        ] : null,

        ...
    )

         *
         *  See also : {@link #chainForArray}.
         *
         *  @param {Function/Object/Array} step1 The function to execute or action configuration, or an array of steps
         *  @param {Function/Object} step2 The function to execute or action configuration
         *  @param {Function/Object} stepN The function to execute or action configuration
         */
        chain : function () {
            // inline any arrays in the arguments into one array
            var steps       = this.flattenArray(arguments)
            var R           = Siesta.Resource(&#39;Siesta.Test.More&#39;);

            var nonEmpty    = []
            Joose.A.each(steps, function (step) { if (step) nonEmpty.push(step) })

            steps           = nonEmpty

            var len         = steps.length

            // do nothing
            if (!len) return;

            var me          = this
            var self        = arguments.callee

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                // some dirt - &quot;chain&quot; is generic method and does not know about `simulator`, which appears on browser level only
                interval        : self.hasOwnProperty(&#39;actionDelay&#39;) ? self.actionDelay : (this.simulator ? this.simulator.actionDelay : 1),

                observeTest     : this
            })

            // hack to allow configuration of `actionDelay`...
            delete self.actionDelay

            var sourceLine  = me.getSourceLine();

            var args        = []

            Joose.A.each(steps, function (step, index) {

                var isLast      = index == len - 1

                queue.addAsyncStep({
                    processor : function (data) {
                        var initStep = function (stepHasOwnAsyncFrame) {

                            if (!stepHasOwnAsyncFrame) {
                                var timeout     = step.timeout || me.defaultTimeout

                                // + 100 to allow `waitFor` steps (which will be waiting the `timeout` time) to
                                // generate their own failures
                                var async       = me.beginAsync(timeout + 100, function () {
                                    me.fail(
                                        R.get(&#39;chainStepNotCompleted&#39;),
                                        {
                                            sourceLine      : sourceLine,
                                            annotation      : R.get(&#39;stepNumber&#39;) + &#39;: &#39; + (index + 1) + &#39; &#39; + R.get(&#39;oneBased&#39;)
                                                + (sourceLine ? (&#39;\n&#39; + R.get(&#39;atLine&#39;) + &#39;: &#39; + sourceLine) : &#39;&#39;)
                                                + &#39;\nStep source: &#39; + me.stringifyChainStep(step),
                                            ownTextOnly     : true
                                        }
                                    )

                                    return true
                                })
                            }

                            return {
                                next    : function () {
                                    var self    = arguments.callee
                                    if (self.__CALLED__) me.fail(R.get(&#39;calledMoreThanOnce&#39;, { num : index + 1, line : sourceLine }))

                                    self.__CALLED__ = true

                                    if (!stepHasOwnAsyncFrame) me.endAsync(async)

                                    args        =  Array.prototype.slice.call(arguments)

                                    if (step.desc) me.pass(step.desc)

                                    data.next()
                                },
                                async   : async
                            }
                        }

                        if (step instanceof Siesta.Test) {

                            me.launchSubTest(step, initStep(true).next)

                        } else if (me.typeOf(step).match(/^(Async)?Function$/) || me.typeOf(step.action).match(/^(Async)?Function$/)) {
                            var func            = me.typeOf(step).match(/^(Async)?Function$/) ? step : step.action

                            var stepInitData    = initStep(false)
                            // if the last step is a function - then provide empty function as the &quot;next&quot; callback for it
                            var next            = isLast ? function () {} : stepInitData.next

                            args.unshift(next)

                            var result

                            if (me.transparentEx)
                                result = func.apply(me, args)
                            else {
                                var e = me.getExceptionCatcher()(function () {
                                    result = func.apply(me, args)
                                })

                                if (e !== undefined) {
                                    // the &quot;me.endAsync()&quot; here is not enough, because for the t.beforeEach()
                                    // hook, we have a nested chain - one in the &quot;launchSpecs&quot;,
                                    // 2nd in the &quot;runBeforeSpecHooks&quot;, thats why in the following statement
                                    // we finalize the whole test, to avoid extra waiting for the
                                    // &quot;chain step can not proceed&quot; message
                                    // for `isLast` case `endAsync` will be done below
                                    if (!isLast) me.endAsync(stepInitData.async)

                                    me.failWithException(e, R.get(&#39;chainStepEx&#39;))
                                }
                            }

                            // if there&#39;s no returning value from the step, then it must call `next` to continue
                            if (!result &amp;&amp; !isLast &amp;&amp; !me.analyzeChainStep(func)) me.fail(R.get(&#39;stepFn&#39;) + &#39; [&#39; + func.toString() + &#39;] &#39; + R.get(&#39;notUsingNext&#39;))

                            if (result) me.handleReturnedPromise(
                                result,
                                next,
                                me.formatString(
                                    &#39;The promise returned from the chain step [&#39; + me.stringifyChainStep(step) + &#39;] did not resolve within {time}ms&#39;,
                                    { time : me.defaultTimeout }
                                )
                            )

                            // and finalize the async frame manually, as the &quot;nextFunc&quot; for last step will never be called
                            if (isLast) {
                                me.endAsync(stepInitData.async)

                                if (step.desc) me.pass(step.desc)
                            }

                        } else if (me.typeOf(step) == &#39;String&#39;) {
                            var action      = new Siesta.Test.Action.Eval({
                                actionString        : step,
                                next                : initStep(false).next,
                                test                : me
                            })

                            action.process()

                        } else {
                            var action      = Siesta.Test.ActionRegistry().create(step, me, args, initStep)

                            action.process()
                        }
                    }
                })
            })

            queue.run()
        },


<span id='Siesta-Test-More-method-chainForArray'>        /**
</span>         * This is a wrapper around the {@link #chain} method, which allows you to run the chain over the steps, generated from the elements
         * of some array. For example, if in some step of outer chain, we need to click the elements with ids, given as the array, we can do:
         *

    function (next) {
        var ids     = [ &#39;button-1&#39;, &#39;button-2&#39;, &#39;button-3&#39; ]

        t.chainForArray(ids, function (elId) {
            return { click : &#39;#&#39; + elId }
        }, next)
    }
         *
         * @param {Array} array An array with arbitrary elements
         * @param {Function} generator A function, which will be called for every element of the `array`. It should return
         * a chain step, generated from that element. This function can return an array of steps as well. If generator will return `null` or
         * `undefined` nothing will be added to the chain.
         * @param {Function} generator.el An element of the `array`
         * @param {Function} generator.index An index of the element
         * @param {Function} [callback] A function to call, once the chain is completed.
         */
        chainForArray : function (array, generator, callback, reverse) {
            var me          = this
            var steps       = []

            Joose.A[ reverse ? &#39;eachR&#39; : &#39;each&#39; ](array, function (el, index) {
                var res     = generator.call(me, el, index)

                if (me.typeOf(res) == &#39;Array&#39;)
                    steps.push.apply(steps, res)
                else
                    if (res) steps.push(res)
            })

            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })

            this.chain(steps)
        },


        verifyExpectedNumber : function (actual, expected) {
            var operator        = &#39;==&#39;

            if (this.typeOf(expected) == &#39;String&#39;) {
                var match       = /([&lt;&gt;=]=?)\s*(\d+)/.exec(expected)
                var R               = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);

                if (!match) throw new Error(R.get(&#39;wrongFormat&#39;)  + &quot;: &quot; + expected)

                operator        = match[ 1 ]
                expected        = Number(match[ 2 ])
            }

            switch (operator) {
                case &#39;==&#39; : return actual == expected
                case &#39;&lt;=&#39; : return actual &lt;= expected
                case &#39;&gt;=&#39; : return actual &gt;= expected
                case &#39;&lt;&#39; : return actual &lt; expected
                case &#39;&gt;&#39; : return actual &gt; expected
            }
        },


        getMaximalTimeout : function () {
            return Math.max(this.waitForTimeout, this.defaultTimeout, this.subTestTimeout, this.timeout || 0, this.isReadyTimeout)
        }
    },


    after : {

        onBeforeTestFinalize : function () {
            if (this.autoCheckGlobals &amp;&amp; !this.isFailed() &amp;&amp; !this.parent) this.verifyGlobals()
        }
    }
})
//eof Siesta.Test.More
</pre>
</body>
</html>
