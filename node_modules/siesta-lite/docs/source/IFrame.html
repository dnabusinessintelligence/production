<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Class(&#39;Scope.Provider.IFrame&#39;, {
    
    isa     : Scope.Provider,
    
    does    : Scope.Provider.Role.WithDOM,
    
    
    have : {
        iframe          : null,
        cls             : null,
        
        performWrap     : false,
        wrapCls         : null,
        wrapper         : null,
        
        // should be inside of the `wrapper` el
        iframeParentEl  : null,
        parentEl        : null,
        
        cleanupDelay    : 1000
    },
    

    methods : {
        
        getDocument : function () {
            return this.iframe.contentWindow.document
        },
        
        
        setViewportSize : function (width, height) {
            var iframe              = this.iframe
            
            if (!iframe) return
            
            iframe.style.width      = width + &#39;px&#39;
            iframe.style.height     = height + &#39;px&#39;
        },
        
        
        create : function (onLoadCallback) {
            var me                  = this
            var doc                 = this.parentWindow.document
            var iframe              = this.iframe = doc.createElement(&#39;iframe&#39;)
            
            var minViewportSize     = this.minViewportSize
            
            iframe.className        = this.cls || &#39;&#39;
            iframe.style.width      = (minViewportSize &amp;&amp; minViewportSize.width || 1024) + &#39;px&#39;
            iframe.style.height     = (minViewportSize &amp;&amp; minViewportSize.height || 768) + &#39;px&#39;
            iframe.setAttribute(&#39;frameborder&#39;, 0)
            
            if (this.name) iframe.setAttribute(&#39;name&#39;, this.name)

            var ignoreOnLoad        = false    
            
            var callback = function () {
                if (ignoreOnLoad) return
                
                if (iframe.detachEvent) 
                    iframe.detachEvent(&#39;onload&#39;, callback)
                else
                    iframe.onload = null
                    
                try {
                    var headContent = me.getHead().innerHTML
                    
                    onLoadCallback &amp;&amp; onLoadCallback(me)
                } catch (e) {
                    // cross-origin exception
                    me.crossOriginFailed    = true
                    
                    onLoadCallback &amp;&amp; onLoadCallback(me, e)
                }
            }
            
            if (iframe.attachEvent) 
                iframe.attachEvent(&#39;onload&#39;, callback)
            else
                iframe.onload   = callback
            
            iframe.src = this.sourceURL || &#39;about:blank&#39;
            
            if (this.performWrap) {
                var wrapper             = this.wrapper
                
                if (!wrapper) {
                    wrapper             = this.wrapper = doc.createElement(&#39;div&#39;)
                    wrapper.className   = this.wrapCls || &#39;&#39;
                }
                
                ;(this.iframeParentEl || wrapper).appendChild(iframe)
                
                // no required anymore, since whole wrapper will be removed
                this.iframeParentEl     = null
            } 
            
            ;(this.parentEl || doc.body).appendChild(wrapper || iframe)
            
            var scope       = this.scope = iframe.contentWindow
            
            // dances with tambourine around the IE (probably for some old version, remove one day)
            if (&#39;v&#39; == &#39;\v&#39; || Boolean(this.parentWindow.msWriteProfilerMark)) {
                try {
                    var scopeDoc    = this.getDocument()
                    // only ignore the 1st call to callback when there is a `sourceURL` config
                    // which will later be assigned to `iframe.src` and will trigger a new iframe loading
                    if (this.sourceURL) ignoreOnLoad = true
                    
                    scopeDoc.open()
                    scopeDoc.write([
                        this.useStrictMode ? &#39;&lt;!DOCTYPE html&gt;&#39; : &#39;&#39;,
                        &#39;&lt;html style=&quot;width: 100%; height: 100%; margin : 0; padding : 0;&quot;&gt;&#39;,
                            &#39;&lt;head&gt;&#39;,
                            &#39;&lt;/head&gt;&#39;,
                            &#39;&lt;body style=&quot;margin : 0; padding : 0; width: 100%; height: 100%&quot;&gt;&#39;,
                            &#39;&lt;/body&gt;&#39;,
                        &#39;&lt;/html&gt;&#39;
                    ].join(&#39;&#39;))
                    scopeDoc.close()
                    
                    ignoreOnLoad = false
                } catch (e) {
                    // cross-origin exception
                    me.crossOriginFailed    = true
                }
                
                iframe.onreadystatechange = function () {
                    if (iframe.readyState == &#39;complete&#39;) iframe.onreadystatechange = null
                    
                    // trying to add the &quot;early&quot; onerror handler on each &quot;readyState&quot; change
                    // for some mystical reasons can&#39;t use `me.installOnErrorHandler` need to inline the call
                    if (me.cachedOnError &amp;&amp; !me.crossOriginFailed) me.attachToOnError(scope, me.scopeId, me.cachedOnError)
                }
                
                if (this.sourceURL) iframe.src = this.sourceURL
            }
            
            // trying to add the &quot;early&quot; onerror handler - installing it in this stage will only work in FF 
            // (other browsers will clear on varios stages)
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        cleanup : function () {
            var wrapper     = this.wrapper || this.iframe
            var iframe      = this.iframe
            var me          = this
            
            // remove this property one more time, because sometimes it is not cleared in IE
            // (seems &quot;onreadystatechange&quot; is not fired)
            iframe.onreadystatechange   = null
            
            wrapper.style.display    = &#39;none&#39;
            
            var onUnloadChecker = function () {
                if (!window.onunload) window.onunload = function () { return &#39;something&#39; }
            }
            
            // add the `onunload` handler if there&#39;s no any - attempting to prevent browser from caching the iframe
            // trying to create the handler from inside of the scope
            this.runCode(&#39;;(&#39; + onUnloadChecker.toString() + &#39;)();&#39;)

            this.iframe     = null
            this.scope      = null
            this.wrapper    = null

            if (me.beforeCleanupCallback) me.beforeCleanupCallback()
            me.beforeCleanupCallback    = null
            
            if (!me.crossOriginFailed)
                // chaging the page, triggering `onunload` and hopefully preventing browser from caching the content of iframe
                iframe.src      = &#39;javascript:false&#39;
            
            // wait again before removing iframe from the DOM, as recommended by some online sources
            setTimeout(function () {
                ;(me.parentEl || me.parentWindow.document.body).removeChild(wrapper)
                
                wrapper     = null
                iframe      = null
                
                me.parentEl = null
                
                me.cleanupHandlers()
                
                if (me.cleanupCallback) me.cleanupCallback()
                me.cleanupCallback  = null
                
            }, me.cleanupDelay)
        }
    }
})

<span id='global-property-'>/**
</span>
Name
====

Scope.Provider.IFrame - scope provider, which uses the iframe.


SYNOPSIS
========

        var provider = new Scope.Provider.IFrame()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == &#39;some_value&#39;) {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.IFrame` is an implementation of the scope provider, which uses the iframe, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: &lt;http://github.com/SamuraiJack/Scope-Provider/issues&gt;

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&amp;channels=joose&amp;prompt=1)
 
Or the mailing list: &lt;http://groups.google.com/group/joose-js&gt;
 


SEE ALSO
========

Web page of this module: &lt;http://github.com/SamuraiJack/Scope-Provider/&gt;

General documentation for Joose: &lt;http://joose.github.com/Joose&gt;


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at &lt;http://github.com/SamuraiJack/Scope-Provider/issues&gt;



AUTHORS
=======

Nickolay Platonov &lt;nplatonov@cpan.org&gt;





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov &lt;nplatonov@cpan.org&gt;.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/</pre>
</body>
</html>
