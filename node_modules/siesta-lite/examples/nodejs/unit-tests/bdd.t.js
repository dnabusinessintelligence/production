describe("My test suite", t => {

    t.beforeEach(() => {
        // Do some setup code code here
    });

    t.afterEach(() => {
        // Do some cleanup code code here
    });

    // the difference between `describe` and `it` is purely semantical - both are just "sub-tests" in Siesta terms
    t.describe("Both assertion types should work", t => {

        t.it("Perl-style assertions", t => {

            t.it("Ok assertions", t => {
                t.ok(true, 'True is ok')
                t.ok(1, '1 is ok')
                t.ok({}, '{} is ok')

                t.notOk(false, 'false is not ok')
                t.notOk(0, '0 is not ok')
                t.notOk(undefined, '`undefined` is not ok')
            })


            t.it("Is assertions", t => {
                t.is(1, 1, '1 is 1')
                t.is(1, "1", '1 is "1"')

                t.is(null, undefined, 'null is undefined')
                t.isnt(1, 2, "1 isn't 2")
            })


            t.it("Like assertions", t => {
                t.like('Yo', /yo/i, '"Yo" is like "yo"')
                t.like('Yoda', 'Yo', '"Yoda" contains "Yo"')

                t.like(__filename, /bdd\.t\.js$/, 'Correct file name')
            })
        })

        t.it("Expectations should work", t => {
            t.expect(1).toBe(1)
            t.expect(1).not.toBe(2)

            t.expect([]).toEqual([])
            t.expect([]).not.toEqual({})

            t.expect([]).not.toBeNull()
            t.expect(null).toBeNull()

            t.expect(NaN).toBeNaN()

            t.expect(1).toBeDefined()
            t.expect(undefined).toBeUndefined()

            t.expect("Foo").toMatch(/foo/i)
            t.expect("Bar").not.toMatch(/foo/i)

            t.expect([ 1 ]).toContain(1)
            t.expect([ 1 ]).not.toContain(2)

            t.expect("Foo").toContain("oo")
            t.expect("Bar").not.toContain("oo")

            t.expect(1).toBeCloseTo(1.01, 1)

            t.expect(() => {
                throw new Error("exception");
            }).toThrow()

            t.expect(() => {
            }).not.toThrow()

            // this is a regular Siesta method
            t.waitFor(10, () => {})
        })
    })

    t.describe("Nested Describe", t => {

        t.it("Nested it", t => {

        })
    })
})
