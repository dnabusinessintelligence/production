import {Base, Constructable, Mixin} from "../../../generic/util/Common.js";
import {Channel, Envelop, Message} from "../../../generic/channel/Types.js";
import {ChannelEndPoint} from "../../../generic/channel/ChannelEndPoint.js";
import {BrowserLogger} from "../../util/role/BrowserLogger.js";
import {parseJsonSafely} from "../../../generic/util/helper/ParseJsonSafely.js";



export class ChildEndPoint extends ChannelEndPoint(BrowserLogger(Base)) {

    socket      : WebSocket

    host        : string
    port        : number


    doConnect (channel : Channel) : Promise<any> {
        return new Promise((resolve, reject) => {
            var socket

            // wrapping WebSocket instantiation in try/catch in attempt to hide the connection exception
            // (if server is not running for example)
            // does not work unfortunately (seems by current browsers design)
            try {
                socket      = this.socket = new WebSocket('ws://' + this.host + ':' + this.port)
            } catch (e) {
                reject("Connection error")
                return
            }

            socket.addEventListener('open', event => {
                socket.removeEventListener('close', connectionErrorRejection)
                socket.addEventListener('close', event => {
                    this.onSocketClose(event)

                    this.disconnect()
                })

                socket.addEventListener('message', event => this.onRawChannelMessage(event))

                this.onSocketOpen(event)

                resolve()
            })

            const connectionErrorRejection = event => reject("Connection error")

            socket.addEventListener('close', connectionErrorRejection)
        })
    }


    doDisconnect () {
        const socket        = this.socket

        if (socket && socket.readyState != socket.CLOSED) {
            socket.close()

            this.socket     = null
        }
    }


    onSocketOpen (event : object) {
    }


    onSocketClose (event : object) {
    }


    sendMessage (message : Message) {
        this.info("Sending message: " + message)

        this.socket.send(message)
    }


    messageToEnvelop (message : Message) : Envelop | undefined {
        const envelop : Envelop  = parseJsonSafely(message.data) as Envelop

        if (envelop && envelop.id == null) return undefined

        return envelop
    }


    envelopToMessage (envelop : Envelop) : Message {
        return JSON.stringify(envelop)
    }
}
