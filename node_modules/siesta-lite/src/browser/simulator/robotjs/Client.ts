import {timeout} from "../../../generic/util/helper/Delay.js";
import {RemoteSimulatorClient} from "../RemoteClient.js";
import {Calibrate} from "../../../generic/simulator/Commands.js";


export class RemoteSimulatorClientRobotJs extends RemoteSimulatorClient {

    calibratedAtPosition        : {
        x           : number,
        y           : number
    } = null


    setup () : Promise<any> {
        return super.setup().then(() => this.calibrate())
    }


    calibrate () : Promise<any> {
        var me      = this

        return new Promise((resolve, reject) => {
            const body      = document.body
            let mask        = document.createElement('div')

            mask.setAttribute('style',"position:absolute; height:100%; width:100%; z-index: 10000")

            var prevBodyPosition = body.style.position

            body.style.position = 'relative'

            body.appendChild(mask)

            const removeMask = () => {
                if (mask) {
                    body.removeChild(mask)

                    body.style.position = prevBodyPosition

                    mask    = null
                }
            }

            const cancelCalibrationTimeout = timeout(this.commandTimeout, () => {
                removeMask()

                reject("timeout")
            })


            let mouseMoveEvent
            let continuation : Function

            const mouseMoveHandler = event => {
                document.removeEventListener('mousemove', mouseMoveHandler, true);

                removeMask()

                if (continuation)
                    continuation(event)
                else
                    mouseMoveEvent  = event
            }

            document.addEventListener('mousemove', mouseMoveHandler, true)


            let calibrationResult

            this.calibratedAtPosition = { x : window.screenX, y : window.screenY }

            this.sendRpcCall(<Calibrate>{
                type        : 'calibrate',

                left        : window.screenX,
                top         : window.screenY,
                width       : window.outerWidth,
                height      : window.outerHeight
            }, this.commandTimeout).then(result => {
                calibrationResult = result

                return new Promise((resolve) => {
                    if (mouseMoveEvent)
                        resolve(mouseMoveEvent)
                    else
                        continuation    = resolve
                })

            }).then((event : any) => {
                cancelCalibrationTimeout()

                me.screenDeltaX     = calibrationResult.x - event.clientX
                me.screenDeltaY     = calibrationResult.y - event.clientY

                resolve()
            }, reason => {
                cancelCalibrationTimeout()

                reject(reason)
            })
        })
    }


    recalibrateIfNeeded () : Promise<void> {
        const calibratedAtPosition  = this.calibratedAtPosition

        if (!calibratedAtPosition || calibratedAtPosition.x != window.screenX || calibratedAtPosition.y != window.screenY) {
            return this.calibrate()
        } else
            return Promise.resolve()
    }
}
